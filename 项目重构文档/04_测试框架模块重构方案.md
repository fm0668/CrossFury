# 测试框架模块重构方案

## 1. 模块概述

测试框架模块是 CrossFury 系统质量保证的核心，提供完整的测试基础设施，包括模拟连接器、测试数据生成、自动化测试套件和性能基准测试。本模块采用**分层测试架构**，确保系统各个层次的功能正确性和性能表现。

**本重构方案将严格遵循 `CrossFury_核心Trait定义.md` 中定义的接口规范，确保测试框架与系统其他模块的完美集成。**

### 1.1 核心职责
- **模拟连接器**：提供完整的交易所API模拟，支持离线测试
- **测试数据管理**：生成和管理各种测试场景的市场数据
- **单元测试框架**：针对各个模块的独立功能测试
- **集成测试框架**：验证模块间协作和数据流
- **性能测试框架**：压力测试和性能基准测试
- **回测框架**：历史数据回测和策略验证
- **测试报告**：自动化测试报告和覆盖率分析

### 1.2 设计原则
- **真实性**：模拟环境尽可能接近真实交易环境
- **可重现性**：测试结果可重现，支持确定性测试
- **全面性**：覆盖正常场景、边界条件和异常情况
- **自动化**：支持CI/CD集成，自动化测试执行
- **可扩展性**：易于添加新的测试场景和交易所支持
- **性能导向**：重点关注高频交易场景的性能测试
- **Trait统一**：所有测试组件严格实现核心trait定义，确保接口一致性

### 1.3 旧代码替换规划

#### 1.3.1 现有测试代码分析
当前项目中的测试相关代码主要分布在：
- `tests/` 目录：现有的单元测试和集成测试
- `src/` 目录中的测试模块：内嵌的测试代码
- 各模块中的 `#[cfg(test)]` 代码块
- 可能存在的性能测试和基准测试代码

#### 1.3.2 迁移策略
1. **保留旧代码**：将现有测试代码移动到 `src/legacy_tests/` 目录
2. **创建新结构**：建立新的 `src/testing/` 模块结构
3. **逐步迁移**：按模块逐步将测试迁移到新框架
4. **适配器模式**：创建适配器连接新旧测试系统
5. **渐进替换**：确保测试覆盖率不降低的前提下逐步替换

## 2. 模拟连接器设计

### 2.1 核心Trait定义引用

**模拟连接器严格遵循 `CrossFury_核心Trait定义.md` 中定义的接口规范：**

#### 2.1.1 核心Trait实现要求
- **ExchangeConnector**: 模拟连接器必须完整实现此trait
- **TestConnector**: 专门为测试设计的扩展trait
- **MockDataProvider**: 测试数据提供者trait
- **TestFramework**: 测试框架管理trait

#### 2.1.2 支持的测试场景
- **单元测试**: 模拟单个组件的行为
- **集成测试**: 模拟多组件协作场景
- **性能测试**: 高并发和压力测试
- **回测测试**: 历史数据回放测试
- **错误测试**: 异常情况和边界条件测试

#### 2.1.3 旧代码适配器实现
```rust
// src/testing/legacy_adapter.rs
use crate::traits::{ExchangeConnector, TestConnector};
use crate::legacy_tests::*;

/// 旧测试代码适配器
pub struct LegacyTestAdapter {
    legacy_test_runner: LegacyTestRunner,
    connector: Box<dyn ExchangeConnector>,
}

impl LegacyTestAdapter {
    pub fn new(legacy_runner: LegacyTestRunner) -> Self {
        Self {
            legacy_test_runner: legacy_runner,
            connector: Box::new(MockConnector::new(MockConnectorConfig::default())),
        }
    }
    
    /// 将旧测试转换为新格式
    pub async fn convert_legacy_test(&self, test_name: &str) -> Result<TestCase, TestError> {
        // 实现旧测试到新测试的转换逻辑
        todo!()
    }
}
```

### 2.2 MockConnector 实现

```rust
// src/testing/mock_connector.rs
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex, mpsc, broadcast};
use crate::traits::*;  // 引用核心trait定义
use crate::types::*;
use crate::testing::market_simulator::*;

// 🔥 模拟连接器（核心测试基础设施）
pub struct MockConnector {
    // 基本信息
    exchange_type: ExchangeType,
    market_type: MarketType,
    
    // 模拟状态
    connection_state: Arc<RwLock<ConnectionState>>,
    
    // 市场数据模拟
    market_simulator: Arc<MarketSimulator>,
    order_book_cache: Arc<RwLock<HashMap<String, OrderBook>>>,
    trade_cache: Arc<RwLock<HashMap<String, Vec<Trade>>>>,
    
    // 用户数据模拟
    account_simulator: Arc<AccountSimulator>,
    order_manager: Arc<MockOrderManager>,
    position_tracker: Arc<MockPositionTracker>,
    
    // 数据流
    market_data_sender: Arc<Mutex<Option<mpsc::UnboundedSender<HighFrequencyData>>>>,
    user_data_sender: Arc<Mutex<Option<mpsc::UnboundedSender<UserDataEvent>>>>,
    system_event_sender: Arc<Mutex<Option<broadcast::Sender<SystemEvent>>>>,
    
    // 配置和控制
    config: MockConnectorConfig,
    latency_simulator: Arc<LatencySimulator>,
    error_simulator: Arc<ErrorSimulator>,
}

#[derive(Debug, Clone)]
pub struct MockConnectorConfig {
    pub exchange_type: ExchangeType,
    pub market_type: MarketType,
    pub supported_symbols: Vec<String>,
    
    // 🔥 延迟模拟配置
    pub latency_config: LatencyConfig,
    
    // 🔥 错误模拟配置
    pub error_config: ErrorConfig,
    
    // 🔥 市场数据配置
    pub market_data_config: MarketDataConfig,
    
    // 🔥 账户配置
    pub account_config: AccountConfig,
    
    // 🔥 订单执行配置
    pub execution_config: ExecutionConfig,
}

#[derive(Debug, Clone)]
pub struct LatencyConfig {
    pub base_latency: Duration,           // 基础延迟
    pub latency_variance: Duration,      // 延迟方差
    pub network_jitter: Duration,        // 网络抖动
    pub enable_realistic_latency: bool,  // 启用真实延迟模拟
}

#[derive(Debug, Clone)]
pub struct ErrorConfig {
    pub connection_error_rate: f64,      // 连接错误率
    pub order_error_rate: f64,           // 订单错误率
    pub market_data_error_rate: f64,     // 市场数据错误率
    pub timeout_rate: f64,               // 超时率
    pub enable_random_errors: bool,      // 启用随机错误
}

#[derive(Debug, Clone)]
pub struct MarketDataConfig {
    pub tick_interval: Duration,         // 行情更新间隔
    pub price_volatility: f64,           // 价格波动率
    pub volume_range: (Decimal, Decimal), // 成交量范围
    pub spread_range: (Decimal, Decimal), // 价差范围
    pub enable_realistic_movement: bool,  // 启用真实价格走势
}

#[derive(Debug, Clone)]
pub struct AccountConfig {
    pub initial_balances: HashMap<String, Decimal>, // 初始余额
    pub trading_fees: HashMap<String, Decimal>,     // 交易手续费
    pub margin_requirements: HashMap<String, Decimal>, // 保证金要求
    pub max_leverage: Option<Decimal>,               // 最大杠杆
}

#[derive(Debug, Clone)]
pub struct ExecutionConfig {
    pub partial_fill_probability: f64,   // 部分成交概率
    pub slippage_range: (f64, f64),      // 滑点范围
    pub execution_delay: Duration,       // 执行延迟
    pub enable_realistic_execution: bool, // 启用真实执行模拟
}

#[async_trait]
impl ExchangeConnector for MockConnector {
    // 🔥 基本信息
    fn get_exchange_type(&self) -> ExchangeType {
        self.exchange_type
    }
    
    fn get_market_type(&self) -> MarketType {
        self.market_type
    }
    
    fn get_supported_symbols(&self) -> Vec<String> {
        self.config.supported_symbols.clone()
    }
    
    // 🔥 连接管理
    async fn connect(&self) -> Result<(), ConnectorError> {
        // 模拟连接延迟
        self.latency_simulator.simulate_connection_latency().await;
        
        // 模拟连接错误
        if self.error_simulator.should_simulate_connection_error().await {
            return Err(ConnectorError::ConnectionFailed("Mock connection error".to_string()));
        }
        
        // 更新连接状态
        {
            let mut state = self.connection_state.write().await;
            *state = ConnectionState::Connected;
        }
        
        // 启动市场数据模拟
        self.market_simulator.start().await;
        
        // 启动账户数据模拟
        self.account_simulator.start().await;
        
        log::info!("MockConnector connected: {:?} {:?}", self.exchange_type, self.market_type);
        Ok(())
    }
    
    async fn disconnect(&self) -> Result<(), ConnectorError> {
        // 停止模拟器
        self.market_simulator.stop().await;
        self.account_simulator.stop().await;
        
        // 更新连接状态
        {
            let mut state = self.connection_state.write().await;
            *state = ConnectionState::Disconnected;
        }
        
        log::info!("MockConnector disconnected: {:?} {:?}", self.exchange_type, self.market_type);
        Ok(())
    }
    
    async fn get_connection_state(&self) -> ConnectionState {
        self.connection_state.read().await.clone()
    }
    
    // 🔥 推送式数据流（核心功能）
    async fn get_market_data_stream(&self) -> Result<mpsc::UnboundedReceiver<HighFrequencyData>, ConnectorError> {
        let (sender, receiver) = mpsc::unbounded_channel();
        
        // 保存发送器
        {
            let mut market_sender = self.market_data_sender.lock().await;
            *market_sender = Some(sender.clone());
        }
        
        // 启动市场数据推送
        self.start_market_data_push(sender).await;
        
        Ok(receiver)
    }
    
    async fn get_user_data_stream(&self) -> Result<mpsc::UnboundedReceiver<UserDataEvent>, ConnectorError> {
        let (sender, receiver) = mpsc::unbounded_channel();
        
        // 保存发送器
        {
            let mut user_sender = self.user_data_sender.lock().await;
            *user_sender = Some(sender.clone());
        }
        
        // 启动用户数据推送
        self.start_user_data_push(sender).await;
        
        Ok(receiver)
    }
    
    // 🔥 本地缓存快照读取
    async fn get_order_book_snapshot(&self, symbol: &str) -> Result<OrderBook, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        let order_books = self.order_book_cache.read().await;
        order_books.get(symbol)
            .cloned()
            .ok_or_else(|| ConnectorError::SymbolNotFound(symbol.to_string()))
    }
    
    async fn get_recent_trades(&self, symbol: &str, limit: Option<u32>) -> Result<Vec<Trade>, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        let trades = self.trade_cache.read().await;
        if let Some(symbol_trades) = trades.get(symbol) {
            let limit = limit.unwrap_or(100) as usize;
            Ok(symbol_trades.iter().rev().take(limit).cloned().collect())
        } else {
            Err(ConnectorError::SymbolNotFound(symbol.to_string()))
        }
    }
    
    async fn get_account_balance(&self) -> Result<HashMap<String, Balance>, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        self.account_simulator.get_balances().await
    }
    
    async fn get_positions(&self) -> Result<HashMap<String, Position>, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        self.position_tracker.get_positions().await
    }
    
    // 🔥 订单操作（核心交易功能）
    async fn place_order(&self, order: OrderRequest) -> Result<OrderResponse, ConnectorError> {
        // 模拟执行延迟
        self.latency_simulator.simulate_execution_latency().await;
        
        // 模拟订单错误
        if self.error_simulator.should_simulate_order_error().await {
            return Err(ConnectorError::OrderRejected("Mock order rejection".to_string()));
        }
        
        // 执行订单
        let response = self.order_manager.place_order(order).await?;
        
        // 发送用户数据更新
        self.send_order_update(&response).await;
        
        Ok(response)
    }
    
    async fn cancel_order(&self, order_id: &str) -> Result<OrderResponse, ConnectorError> {
        // 模拟执行延迟
        self.latency_simulator.simulate_execution_latency().await;
        
        // 执行取消
        let response = self.order_manager.cancel_order(order_id).await?;
        
        // 发送用户数据更新
        self.send_order_update(&response).await;
        
        Ok(response)
    }
    
    async fn get_order_status(&self, order_id: &str) -> Result<OrderStatus, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        self.order_manager.get_order_status(order_id).await
    }
    
    async fn get_open_orders(&self, symbol: Option<&str>) -> Result<Vec<Order>, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        self.order_manager.get_open_orders(symbol).await
    }
    
    async fn get_order_history(&self, symbol: Option<&str>, limit: Option<u32>) -> Result<Vec<Order>, ConnectorError> {
        // 模拟网络延迟
        self.latency_simulator.simulate_api_latency().await;
        
        self.order_manager.get_order_history(symbol, limit).await
    }
}

impl MockConnector {
    // 🔥 构造函数
    pub fn new(config: MockConnectorConfig) -> Self {
        let market_simulator = Arc::new(MarketSimulator::new(config.market_data_config.clone()));
        let account_simulator = Arc::new(AccountSimulator::new(config.account_config.clone()));
        let order_manager = Arc::new(MockOrderManager::new(config.execution_config.clone()));
        let position_tracker = Arc::new(MockPositionTracker::new());
        let latency_simulator = Arc::new(LatencySimulator::new(config.latency_config.clone()));
        let error_simulator = Arc::new(ErrorSimulator::new(config.error_config.clone()));
        
        Self {
            exchange_type: config.exchange_type,
            market_type: config.market_type,
            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),
            market_simulator,
            order_book_cache: Arc::new(RwLock::new(HashMap::new())),
            trade_cache: Arc::new(RwLock::new(HashMap::new())),
            account_simulator,
            order_manager,
            position_tracker,
            market_data_sender: Arc::new(Mutex::new(None)),
            user_data_sender: Arc::new(Mutex::new(None)),
            system_event_sender: Arc::new(Mutex::new(None)),
            config,
            latency_simulator,
            error_simulator,
        }
    }
    
    // 🔥 启动市场数据推送
    async fn start_market_data_push(&self, sender: mpsc::UnboundedSender<HighFrequencyData>) {
        let market_simulator = self.market_simulator.clone();
        let order_book_cache = self.order_book_cache.clone();
        let trade_cache = self.trade_cache.clone();
        let symbols = self.config.supported_symbols.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_millis(100));
            
            loop {
                interval.tick().await;
                
                for symbol in &symbols {
                    // 生成订单簿更新
                    if let Ok(order_book) = market_simulator.generate_order_book(symbol).await {
                        // 更新缓存
                        {
                            let mut cache = order_book_cache.write().await;
                            cache.insert(symbol.clone(), order_book.clone());
                        }
                        
                        // 发送数据
                        let data = HighFrequencyData::OrderBook {
                            symbol: symbol.clone(),
                            order_book,
                            timestamp: Utc::now(),
                        };
                        
                        if sender.send(data).is_err() {
                            break;
                        }
                    }
                    
                    // 生成交易数据
                    if let Ok(trades) = market_simulator.generate_trades(symbol, 5).await {
                        // 更新缓存
                        {
                            let mut cache = trade_cache.write().await;
                            cache.entry(symbol.clone()).or_insert_with(Vec::new).extend(trades.clone());
                            
                            // 保持缓存大小
                            let symbol_trades = cache.get_mut(symbol).unwrap();
                            if symbol_trades.len() > 1000 {
                                symbol_trades.drain(0..symbol_trades.len() - 1000);
                            }
                        }
                        
                        // 发送数据
                        for trade in trades {
                            let data = HighFrequencyData::Trade {
                                symbol: symbol.clone(),
                                trade,
                                timestamp: Utc::now(),
                            };
                            
                            if sender.send(data).is_err() {
                                return;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // 🔥 启动用户数据推送
    async fn start_user_data_push(&self, sender: mpsc::UnboundedSender<UserDataEvent>) {
        let order_manager = self.order_manager.clone();
        let account_simulator = self.account_simulator.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(1));
            
            loop {
                interval.tick().await;
                
                // 发送账户余额更新
                if let Ok(balances) = account_simulator.get_balances().await {
                    let event = UserDataEvent::BalanceUpdate { balances };
                    if sender.send(event).is_err() {
                        break;
                    }
                }
                
                // 发送订单状态更新
                if let Ok(order_updates) = order_manager.get_pending_updates().await {
                    for update in order_updates {
                        let event = UserDataEvent::OrderUpdate { order: update };
                        if sender.send(event).is_err() {
                            return;
                        }
                    }
                }
            }
        });
    }
    
    // 🔥 发送订单更新
    async fn send_order_update(&self, response: &OrderResponse) {
        if let Some(sender) = self.user_data_sender.lock().await.as_ref() {
            let event = UserDataEvent::OrderUpdate {
                order: Order {
                    id: response.order_id.clone(),
                    client_order_id: response.client_order_id.clone(),
                    symbol: response.symbol.clone(),
                    side: response.side,
                    order_type: response.order_type,
                    quantity: response.quantity,
                    price: response.price,
                    status: response.status,
                    filled_quantity: response.filled_quantity,
                    average_price: response.average_price,
                    created_at: response.created_at,
                    updated_at: response.updated_at,
                    fees: response.fees.clone(),
                },
            };
            
            let _ = sender.send(event);
        }
    }
    
    // 🔥 测试辅助方法
    pub async fn set_market_price(&self, symbol: &str, price: Decimal) {
        self.market_simulator.set_price(symbol, price).await;
    }
    
    pub async fn trigger_connection_error(&self) {
        self.error_simulator.trigger_connection_error().await;
    }
    
    pub async fn set_latency(&self, latency: Duration) {
        self.latency_simulator.set_base_latency(latency).await;
    }
    
    pub async fn get_order_book_cache(&self) -> HashMap<String, OrderBook> {
        self.order_book_cache.read().await.clone()
    }
    
    pub async fn get_trade_cache(&self) -> HashMap<String, Vec<Trade>> {
        self.trade_cache.read().await.clone()
    }
}
```

### 2.2 市场数据模拟器

```rust
// src/testing/market_simulator.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use rand::Rng;
use crate::types::*;
use crate::testing::mock_connector::MarketDataConfig;

// 🔥 市场数据模拟器
pub struct MarketSimulator {
    config: MarketDataConfig,
    
    // 价格状态
    current_prices: Arc<RwLock<HashMap<String, Decimal>>>,
    price_trends: Arc<RwLock<HashMap<String, PriceTrend>>>,
    
    // 订单簿状态
    order_book_depths: Arc<RwLock<HashMap<String, u32>>>,
    
    // 随机数生成器
    rng: Arc<RwLock<rand::rngs::ThreadRng>>,
    
    // 运行状态
    is_running: Arc<RwLock<bool>>,
}

#[derive(Debug, Clone)]
pub struct PriceTrend {
    pub direction: TrendDirection,
    pub strength: f64,        // 0.0 - 1.0
    pub duration: Duration,   // 趋势持续时间
    pub started_at: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum TrendDirection {
    Up,
    Down,
    Sideways,
}

impl MarketSimulator {
    pub fn new(config: MarketDataConfig) -> Self {
        Self {
            config,
            current_prices: Arc::new(RwLock::new(HashMap::new())),
            price_trends: Arc::new(RwLock::new(HashMap::new())),
            order_book_depths: Arc::new(RwLock::new(HashMap::new())),
            rng: Arc::new(RwLock::new(rand::thread_rng())),
            is_running: Arc::new(RwLock::new(false)),
        }
    }
    
    // 🔥 启动模拟器
    pub async fn start(&self) {
        {
            let mut running = self.is_running.write().await;
            *running = true;
        }
        
        // 初始化价格
        self.initialize_prices().await;
        
        // 启动价格更新任务
        self.start_price_update_task().await;
    }
    
    // 🔥 停止模拟器
    pub async fn stop(&self) {
        let mut running = self.is_running.write().await;
        *running = false;
    }
    
    // 🔥 生成订单簿
    pub async fn generate_order_book(&self, symbol: &str) -> Result<OrderBook, SimulatorError> {
        let current_price = self.get_current_price(symbol).await
            .ok_or_else(|| SimulatorError::SymbolNotFound(symbol.to_string()))?;
        
        let depth = {
            let depths = self.order_book_depths.read().await;
            depths.get(symbol).copied().unwrap_or(20)
        };
        
        let mut rng = self.rng.write().await;
        let spread = self.generate_spread(&mut *rng);
        
        let mut bids = Vec::new();
        let mut asks = Vec::new();
        
        // 生成买单
        let bid_start = current_price - spread / Decimal::from(2);
        for i in 0..depth {
            let price = bid_start - Decimal::from(i) * current_price * Decimal::from(0.0001);
            let quantity = self.generate_quantity(&mut *rng);
            bids.push(PriceLevel { price, quantity });
        }
        
        // 生成卖单
        let ask_start = current_price + spread / Decimal::from(2);
        for i in 0..depth {
            let price = ask_start + Decimal::from(i) * current_price * Decimal::from(0.0001);
            let quantity = self.generate_quantity(&mut *rng);
            asks.push(PriceLevel { price, quantity });
        }
        
        Ok(OrderBook {
            symbol: symbol.to_string(),
            bids,
            asks,
            timestamp: Utc::now(),
        })
    }
    
    // 🔥 生成交易数据
    pub async fn generate_trades(&self, symbol: &str, count: u32) -> Result<Vec<Trade>, SimulatorError> {
        let current_price = self.get_current_price(symbol).await
            .ok_or_else(|| SimulatorError::SymbolNotFound(symbol.to_string()))?;
        
        let mut trades = Vec::new();
        let mut rng = self.rng.write().await;
        
        for i in 0..count {
            let price_variance = current_price * Decimal::from(0.001); // 0.1% variance
            let price_offset = Decimal::from(rng.gen_range(-1.0..1.0)) * price_variance;
            let trade_price = current_price + price_offset;
            
            let quantity = self.generate_quantity(&mut *rng);
            let side = if rng.gen_bool(0.5) { TradeSide::Buy } else { TradeSide::Sell };
            
            trades.push(Trade {
                id: format!("trade_{}_{}", symbol, i),
                symbol: symbol.to_string(),
                price: trade_price,
                quantity,
                side,
                timestamp: Utc::now() - Duration::milliseconds(rng.gen_range(0..1000)),
            });
        }
        
        // 按时间排序
        trades.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
        
        Ok(trades)
    }
    
    // 🔥 设置价格（测试用）
    pub async fn set_price(&self, symbol: &str, price: Decimal) {
        let mut prices = self.current_prices.write().await;
        prices.insert(symbol.to_string(), price);
    }
    
    // 🔥 获取当前价格
    pub async fn get_current_price(&self, symbol: &str) -> Option<Decimal> {
        let prices = self.current_prices.read().await;
        prices.get(symbol).copied()
    }
    
    // 私有方法实现...
    async fn initialize_prices(&self) {
        let mut prices = self.current_prices.write().await;
        let mut trends = self.price_trends.write().await;
        
        // 初始化常见交易对价格
        let initial_prices = vec![
            ("BTC/USDT".to_string(), Decimal::from(50000)),
            ("ETH/USDT".to_string(), Decimal::from(3000)),
            ("BNB/USDT".to_string(), Decimal::from(300)),
            ("ADA/USDT".to_string(), Decimal::from_str("0.5").unwrap()),
            ("DOT/USDT".to_string(), Decimal::from(10)),
        ];
        
        for (symbol, price) in initial_prices {
            prices.insert(symbol.clone(), price);
            trends.insert(symbol, PriceTrend {
                direction: TrendDirection::Sideways,
                strength: 0.5,
                duration: Duration::hours(1),
                started_at: Utc::now(),
            });
        }
    }
    
    async fn start_price_update_task(&self) {
        let current_prices = self.current_prices.clone();
        let price_trends = self.price_trends.clone();
        let is_running = self.is_running.clone();
        let config = self.config.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(config.tick_interval);
            
            loop {
                interval.tick().await;
                
                if !*is_running.read().await {
                    break;
                }
                
                // 更新所有价格
                Self::update_all_prices(&current_prices, &price_trends, &config).await;
            }
        });
    }
    
    async fn update_all_prices(
        current_prices: &Arc<RwLock<HashMap<String, Decimal>>>,
        price_trends: &Arc<RwLock<HashMap<String, PriceTrend>>>,
        config: &MarketDataConfig
    ) {
        let mut prices = current_prices.write().await;
        let mut trends = price_trends.write().await;
        let mut rng = rand::thread_rng();
        
        for (symbol, price) in prices.iter_mut() {
            if let Some(trend) = trends.get_mut(symbol) {
                // 检查是否需要更新趋势
                if Utc::now() - trend.started_at > trend.duration {
                    *trend = Self::generate_new_trend(&mut rng);
                }
                
                // 根据趋势更新价格
                let price_change = Self::calculate_price_change(price, trend, config, &mut rng);
                *price += price_change;
                
                // 确保价格为正
                if *price <= Decimal::ZERO {
                    *price = Decimal::from_str("0.0001").unwrap();
                }
            }
        }
    }
    
    fn generate_new_trend(rng: &mut rand::rngs::ThreadRng) -> PriceTrend {
        let directions = [TrendDirection::Up, TrendDirection::Down, TrendDirection::Sideways];
        let direction = directions[rng.gen_range(0..3)].clone();
        
        PriceTrend {
            direction,
            strength: rng.gen_range(0.1..1.0),
            duration: Duration::minutes(rng.gen_range(5..60)),
            started_at: Utc::now(),
        }
    }
    
    fn calculate_price_change(
        current_price: &Decimal,
        trend: &PriceTrend,
        config: &MarketDataConfig,
        rng: &mut rand::rngs::ThreadRng
    ) -> Decimal {
        let base_volatility = config.price_volatility;
        let trend_factor = match trend.direction {
            TrendDirection::Up => trend.strength,
            TrendDirection::Down => -trend.strength,
            TrendDirection::Sideways => 0.0,
        };
        
        let random_factor = rng.gen_range(-1.0..1.0);
        let total_change = (trend_factor * 0.7 + random_factor * 0.3) * base_volatility;
        
        *current_price * Decimal::from(total_change)
    }
    
    fn generate_spread(&self, rng: &mut rand::rngs::ThreadRng) -> Decimal {
        let (min_spread, max_spread) = self.config.spread_range;
        let spread_factor = rng.gen_range(0.0..1.0);
        min_spread + (max_spread - min_spread) * Decimal::from(spread_factor)
    }
    
    fn generate_quantity(&self, rng: &mut rand::rngs::ThreadRng) -> Decimal {
        let (min_volume, max_volume) = self.config.volume_range;
        let volume_factor = rng.gen_range(0.0..1.0);
        min_volume + (max_volume - min_volume) * Decimal::from(volume_factor)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum SimulatorError {
    #[error("Symbol not found: {0}")]
    SymbolNotFound(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    #[error("Simulation error: {0}")]
    SimulationError(String),
}
```

### 2.3 延迟和错误模拟器

```rust
// src/testing/simulators.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use rand::Rng;
use crate::testing::mock_connector::{LatencyConfig, ErrorConfig};

// 🔥 延迟模拟器
pub struct LatencySimulator {
    config: Arc<RwLock<LatencyConfig>>,
    rng: Arc<RwLock<rand::rngs::ThreadRng>>,
}

impl LatencySimulator {
    pub fn new(config: LatencyConfig) -> Self {
        Self {
            config: Arc::new(RwLock::new(config)),
            rng: Arc::new(RwLock::new(rand::thread_rng())),
        }
    }
    
    // 🔥 模拟连接延迟
    pub async fn simulate_connection_latency(&self) {
        let config = self.config.read().await;
        if config.enable_realistic_latency {
            let latency = self.calculate_latency(&config).await;
            tokio::time::sleep(latency).await;
        }
    }
    
    // 🔥 模拟API调用延迟
    pub async fn simulate_api_latency(&self) {
        let config = self.config.read().await;
        if config.enable_realistic_latency {
            let latency = self.calculate_latency(&config).await;
            tokio::time::sleep(latency).await;
        }
    }
    
    // 🔥 模拟订单执行延迟
    pub async fn simulate_execution_latency(&self) {
        let config = self.config.read().await;
        if config.enable_realistic_latency {
            let latency = self.calculate_latency(&config).await;
            tokio::time::sleep(latency).await;
        }
    }
    
    // 🔥 设置基础延迟（测试用）
    pub async fn set_base_latency(&self, latency: Duration) {
        let mut config = self.config.write().await;
        config.base_latency = latency;
    }
    
    // 私有方法：计算延迟
    async fn calculate_latency(&self, config: &LatencyConfig) -> Duration {
        let mut rng = self.rng.write().await;
        
        // 基础延迟 + 随机方差 + 网络抖动
        let variance = Duration::from_nanos(rng.gen_range(0..config.latency_variance.as_nanos() as u64));
        let jitter = Duration::from_nanos(rng.gen_range(0..config.network_jitter.as_nanos() as u64));
        
        config.base_latency + variance + jitter
    }
}

// 🔥 错误模拟器
pub struct ErrorSimulator {
    config: Arc<RwLock<ErrorConfig>>,
    rng: Arc<RwLock<rand::rngs::ThreadRng>>,
    
    // 错误状态
    connection_error_triggered: Arc<RwLock<bool>>,
}

impl ErrorSimulator {
    pub fn new(config: ErrorConfig) -> Self {
        Self {
            config: Arc::new(RwLock::new(config)),
            rng: Arc::new(RwLock::new(rand::thread_rng())),
            connection_error_triggered: Arc::new(RwLock::new(false)),
        }
    }
    
    // 🔥 检查是否应该模拟连接错误
    pub async fn should_simulate_connection_error(&self) -> bool {
        // 检查手动触发的错误
        {
            let mut triggered = self.connection_error_triggered.write().await;
            if *triggered {
                *triggered = false;
                return true;
            }
        }
        
        // 检查随机错误
        let config = self.config.read().await;
        if config.enable_random_errors {
            let mut rng = self.rng.write().await;
            rng.gen_bool(config.connection_error_rate)
        } else {
            false
        }
    }
    
    // 🔥 检查是否应该模拟订单错误
    pub async fn should_simulate_order_error(&self) -> bool {
        let config = self.config.read().await;
        if config.enable_random_errors {
            let mut rng = self.rng.write().await;
            rng.gen_bool(config.order_error_rate)
        } else {
            false
        }
    }
    
    // 🔥 检查是否应该模拟市场数据错误
    pub async fn should_simulate_market_data_error(&self) -> bool {
        let config = self.config.read().await;
        if config.enable_random_errors {
            let mut rng = self.rng.write().await;
            rng.gen_bool(config.market_data_error_rate)
        } else {
            false
        }
    }
    
    // 🔥 手动触发连接错误（测试用）
    pub async fn trigger_connection_error(&self) {
        let mut triggered = self.connection_error_triggered.write().await;
        *triggered = true;
    }
}
```

## 3. 单元测试框架

### 3.1 连接器测试

```rust
// tests/unit/connectors/test_mock_connector.rs
use tokio_test;
use std::time::Duration;
use crossfury::testing::mock_connector::*;
use crossfury::connectors::traits::*;
use crossfury::types::*;

#[tokio::test]
async fn test_mock_connector_connection() {
    // 🔥 测试连接器连接功能
    let config = MockConnectorConfig {
        exchange_type: ExchangeType::Binance,
        market_type: MarketType::Spot,
        supported_symbols: vec!["BTC/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(10),
            latency_variance: Duration::from_millis(5),
            network_jitter: Duration::from_millis(2),
            enable_realistic_latency: true,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig::default(),
        account_config: AccountConfig::default(),
        execution_config: ExecutionConfig::default(),
    };
    
    let connector = MockConnector::new(config);
    
    // 测试初始状态
    assert_eq!(connector.get_connection_state().await, ConnectionState::Disconnected);
    
    // 测试连接
    let result = connector.connect().await;
    assert!(result.is_ok());
    assert_eq!(connector.get_connection_state().await, ConnectionState::Connected);
    
    // 测试断开连接
    let result = connector.disconnect().await;
    assert!(result.is_ok());
    assert_eq!(connector.get_connection_state().await, ConnectionState::Disconnected);
}

#[tokio::test]
async fn test_mock_connector_market_data_stream() {
    // 🔥 测试市场数据流
    let config = create_test_config();
    let connector = MockConnector::new(config);
    
    // 连接
    connector.connect().await.unwrap();
    
    // 获取市场数据流
    let mut receiver = connector.get_market_data_stream().await.unwrap();
    
    // 等待数据
    let timeout = tokio::time::timeout(Duration::from_secs(2), receiver.recv()).await;
    assert!(timeout.is_ok());
    
    let data = timeout.unwrap().unwrap();
    match data {
        HighFrequencyData::OrderBook { symbol, .. } => {
            assert_eq!(symbol, "BTC/USDT");
        }
        _ => panic!("Expected OrderBook data"),
    }
}

#[tokio::test]
async fn test_mock_connector_order_operations() {
    // 🔥 测试订单操作
    let config = create_test_config();
    let connector = MockConnector::new(config);
    
    connector.connect().await.unwrap();
    
    // 测试下单
    let order_request = OrderRequest {
        client_order_id: "test_order_1".to_string(),
        symbol: "BTC/USDT".to_string(),
        side: OrderSide::Buy,
        order_type: OrderType::Limit,
        quantity: Decimal::from(1),
        price: Some(Decimal::from(50000)),
        time_in_force: Some(TimeInForce::GTC),
    };
    
    let response = connector.place_order(order_request).await.unwrap();
    assert!(!response.order_id.is_empty());
    assert_eq!(response.status, OrderStatus::New);
    
    // 测试查询订单状态
    let status = connector.get_order_status(&response.order_id).await.unwrap();
    assert!(matches!(status, OrderStatus::New | OrderStatus::PartiallyFilled | OrderStatus::Filled));
    
    // 测试取消订单
    let cancel_response = connector.cancel_order(&response.order_id).await.unwrap();
    assert_eq!(cancel_response.status, OrderStatus::Cancelled);
}

#[tokio::test]
async fn test_mock_connector_error_simulation() {
    // 🔥 测试错误模拟
    let mut config = create_test_config();
    config.error_config.enable_random_errors = true;
    config.error_config.connection_error_rate = 1.0; // 100% 错误率
    
    let connector = MockConnector::new(config);
    
    // 测试连接错误
    let result = connector.connect().await;
    assert!(result.is_err());
}

#[tokio::test]
async fn test_mock_connector_latency_simulation() {
    // 🔥 测试延迟模拟
    let mut config = create_test_config();
    config.latency_config.base_latency = Duration::from_millis(100);
    config.latency_config.enable_realistic_latency = true;
    
    let connector = MockConnector::new(config);
    connector.connect().await.unwrap();
    
    // 测量API调用延迟
    let start = std::time::Instant::now();
    let _ = connector.get_account_balance().await.unwrap();
    let elapsed = start.elapsed();
    
    // 应该有明显的延迟
    assert!(elapsed >= Duration::from_millis(90));
}

// 辅助函数
fn create_test_config() -> MockConnectorConfig {
    MockConnectorConfig {
        exchange_type: ExchangeType::Binance,
        market_type: MarketType::Spot,
        supported_symbols: vec!["BTC/USDT".to_string(), "ETH/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(10),
            latency_variance: Duration::from_millis(5),
            network_jitter: Duration::from_millis(2),
            enable_realistic_latency: false,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig {
            tick_interval: Duration::from_millis(100),
            price_volatility: 0.001,
            volume_range: (Decimal::from(1), Decimal::from(1000)),
            spread_range: (Decimal::from_str("0.0001").unwrap(), Decimal::from_str("0.001").unwrap()),
            enable_realistic_movement: true,
        },
        account_config: AccountConfig {
            initial_balances: {
                let mut balances = HashMap::new();
                balances.insert("USDT".to_string(), Decimal::from(100000));
                balances.insert("BTC".to_string(), Decimal::from(1));
                balances
            },
            trading_fees: {
                let mut fees = HashMap::new();
                fees.insert("default".to_string(), Decimal::from_str("0.001").unwrap());
                fees
            },
            margin_requirements: HashMap::new(),
            max_leverage: Some(Decimal::from(10)),
        },
        execution_config: ExecutionConfig {
            partial_fill_probability: 0.1,
            slippage_range: (0.0, 0.001),
            execution_delay: Duration::from_millis(50),
            enable_realistic_execution: true,
        },
     }
 }
```

## 5. 性能测试框架

### 5.1 压力测试

```rust
// tests/performance/test_high_frequency_trading.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use tokio::runtime::Runtime;
use std::time::Duration;
use crossfury::testing::mock_connector::*;
use crossfury::testing::performance_tester::*;

// 🔥 高频交易性能测试
fn benchmark_order_execution(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    let mut group = c.benchmark_group("order_execution");
    
    for order_count in [100, 500, 1000, 5000].iter() {
        group.bench_with_input(
            BenchmarkId::new("concurrent_orders", order_count),
            order_count,
            |b, &order_count| {
                b.to_async(&rt).iter(|| async {
                    let performance_tester = PerformanceTester::new().await;
                    performance_tester.test_concurrent_orders(order_count).await
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_market_data_processing(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    let mut group = c.benchmark_group("market_data_processing");
    
    for data_rate in [1000, 5000, 10000, 50000].iter() {
        group.bench_with_input(
            BenchmarkId::new("messages_per_second", data_rate),
            data_rate,
            |b, &data_rate| {
                b.to_async(&rt).iter(|| async {
                    let performance_tester = PerformanceTester::new().await;
                    performance_tester.test_market_data_throughput(data_rate).await
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_arbitrage_detection(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    c.bench_function("arbitrage_detection", |b| {
        b.to_async(&rt).iter(|| async {
            let performance_tester = PerformanceTester::new().await;
            performance_tester.test_arbitrage_detection_speed().await
        });
    });
}

criterion_group!(
    benches,
    benchmark_order_execution,
    benchmark_market_data_processing,
    benchmark_arbitrage_detection
);
criterion_main!(benches);
```

### 5.2 性能测试工具

```rust
// src/testing/performance_tester.rs
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{RwLock, Semaphore};
use futures::future::join_all;
use crate::testing::mock_connector::*;
use crate::execution::order_executor::*;
use crate::arbitrage::arbitrage_engine::*;

// 🔥 性能测试器
pub struct PerformanceTester {
    mock_connector: Arc<MockConnector>,
    order_executor: Arc<OrderExecutorImpl>,
    arbitrage_engine: Arc<ArbitrageEngine>,
    metrics_collector: Arc<PerformanceMetricsCollector>,
}

#[derive(Debug, Clone)]
pub struct PerformanceMetrics {
    pub total_orders: u64,
    pub successful_orders: u64,
    pub failed_orders: u64,
    pub average_latency: Duration,
    pub p95_latency: Duration,
    pub p99_latency: Duration,
    pub throughput: f64, // orders per second
    pub memory_usage: u64, // bytes
    pub cpu_usage: f64, // percentage
}

#[derive(Debug)]
pub struct PerformanceMetricsCollector {
    latencies: Arc<RwLock<Vec<Duration>>>,
    start_time: Arc<RwLock<Option<Instant>>>,
    order_count: Arc<RwLock<u64>>,
    success_count: Arc<RwLock<u64>>,
    error_count: Arc<RwLock<u64>>,
}

impl PerformanceTester {
    pub async fn new() -> Self {
        let config = create_performance_test_config();
        let mock_connector = Arc::new(MockConnector::new(config));
        
        mock_connector.connect().await.unwrap();
        
        let order_executor = Arc::new(OrderExecutorImpl::new(
            mock_connector.clone(),
            create_test_risk_manager(),
        ));
        
        let arbitrage_engine = Arc::new(ArbitrageEngine::new());
        arbitrage_engine.add_connector("test", mock_connector.clone()).await;
        
        Self {
            mock_connector,
            order_executor,
            arbitrage_engine,
            metrics_collector: Arc::new(PerformanceMetricsCollector::new()),
        }
    }
    
    // 🔥 测试并发订单执行
    pub async fn test_concurrent_orders(&self, order_count: u32) -> PerformanceMetrics {
        self.metrics_collector.start_test().await;
        
        // 创建信号量限制并发数
        let semaphore = Arc::new(Semaphore::new(100));
        
        // 生成订单任务
        let mut tasks = Vec::new();
        for i in 0..order_count {
            let executor = self.order_executor.clone();
            let metrics = self.metrics_collector.clone();
            let sem = semaphore.clone();
            
            let task = tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                
                let order = OrderRequest {
                    client_order_id: format!("perf_test_{}", i),
                    symbol: "BTC/USDT".to_string(),
                    side: if i % 2 == 0 { OrderSide::Buy } else { OrderSide::Sell },
                    order_type: OrderType::Market,
                    quantity: Decimal::from_str("0.001").unwrap(),
                    price: None,
                    time_in_force: Some(TimeInForce::IOC),
                };
                
                let start = Instant::now();
                let result = executor.execute_order(order).await;
                let latency = start.elapsed();
                
                metrics.record_order_result(result.is_ok(), latency).await;
            });
            
            tasks.push(task);
        }
        
        // 等待所有任务完成
        join_all(tasks).await;
        
        self.metrics_collector.calculate_metrics().await
    }
    
    // 🔥 测试市场数据吞吐量
    pub async fn test_market_data_throughput(&self, messages_per_second: u32) -> PerformanceMetrics {
        self.metrics_collector.start_test().await;
        
        let mut receiver = self.mock_connector.get_market_data_stream().await.unwrap();
        let test_duration = Duration::from_secs(10);
        let start_time = Instant::now();
        let mut message_count = 0u64;
        
        while start_time.elapsed() < test_duration {
            if let Ok(data) = tokio::time::timeout(Duration::from_millis(100), receiver.recv()).await {
                if data.is_some() {
                    message_count += 1;
                }
            }
        }
        
        let actual_throughput = message_count as f64 / test_duration.as_secs_f64();
        
        PerformanceMetrics {
            total_orders: message_count,
            successful_orders: message_count,
            failed_orders: 0,
            average_latency: Duration::from_millis(1),
            p95_latency: Duration::from_millis(2),
            p99_latency: Duration::from_millis(5),
            throughput: actual_throughput,
            memory_usage: self.get_memory_usage().await,
            cpu_usage: self.get_cpu_usage().await,
        }
    }
    
    // 🔥 测试套利检测速度
    pub async fn test_arbitrage_detection_speed(&self) -> PerformanceMetrics {
        self.metrics_collector.start_test().await;
        
        let test_iterations = 1000;
        let mut total_latency = Duration::ZERO;
        
        for _ in 0..test_iterations {
            let start = Instant::now();
            let _ = self.arbitrage_engine.scan_opportunities("BTC/USDT").await;
            total_latency += start.elapsed();
        }
        
        let average_latency = total_latency / test_iterations;
        
        PerformanceMetrics {
            total_orders: test_iterations as u64,
            successful_orders: test_iterations as u64,
            failed_orders: 0,
            average_latency,
            p95_latency: average_latency * 2,
            p99_latency: average_latency * 3,
            throughput: test_iterations as f64 / total_latency.as_secs_f64(),
            memory_usage: self.get_memory_usage().await,
            cpu_usage: self.get_cpu_usage().await,
        }
    }
    
    // 🔥 内存使用情况
    async fn get_memory_usage(&self) -> u64 {
        // 实际实现中可以使用系统调用获取内存使用情况
        // 这里返回模拟值
        1024 * 1024 * 100 // 100MB
    }
    
    // 🔥 CPU使用情况
    async fn get_cpu_usage(&self) -> f64 {
        // 实际实现中可以使用系统调用获取CPU使用情况
        // 这里返回模拟值
        25.5 // 25.5%
    }
}

impl PerformanceMetricsCollector {
    pub fn new() -> Self {
        Self {
            latencies: Arc::new(RwLock::new(Vec::new())),
            start_time: Arc::new(RwLock::new(None)),
            order_count: Arc::new(RwLock::new(0)),
            success_count: Arc::new(RwLock::new(0)),
            error_count: Arc::new(RwLock::new(0)),
        }
    }
    
    pub async fn start_test(&self) {
        let mut start_time = self.start_time.write().await;
        *start_time = Some(Instant::now());
        
        // 重置计数器
        *self.order_count.write().await = 0;
        *self.success_count.write().await = 0;
        *self.error_count.write().await = 0;
        self.latencies.write().await.clear();
    }
    
    pub async fn record_order_result(&self, success: bool, latency: Duration) {
        {
            let mut order_count = self.order_count.write().await;
            *order_count += 1;
        }
        
        if success {
            let mut success_count = self.success_count.write().await;
            *success_count += 1;
        } else {
            let mut error_count = self.error_count.write().await;
            *error_count += 1;
        }
        
        {
            let mut latencies = self.latencies.write().await;
            latencies.push(latency);
        }
    }
    
    pub async fn calculate_metrics(&self) -> PerformanceMetrics {
        let start_time = self.start_time.read().await.unwrap();
        let total_duration = start_time.elapsed();
        
        let total_orders = *self.order_count.read().await;
        let successful_orders = *self.success_count.read().await;
        let failed_orders = *self.error_count.read().await;
        
        let mut latencies = self.latencies.read().await.clone();
        latencies.sort();
        
        let average_latency = if !latencies.is_empty() {
            latencies.iter().sum::<Duration>() / latencies.len() as u32
        } else {
            Duration::ZERO
        };
        
        let p95_latency = if !latencies.is_empty() {
            let index = (latencies.len() as f64 * 0.95) as usize;
            latencies.get(index).copied().unwrap_or(Duration::ZERO)
        } else {
            Duration::ZERO
        };
        
        let p99_latency = if !latencies.is_empty() {
            let index = (latencies.len() as f64 * 0.99) as usize;
            latencies.get(index).copied().unwrap_or(Duration::ZERO)
        } else {
            Duration::ZERO
        };
        
        let throughput = total_orders as f64 / total_duration.as_secs_f64();
        
        PerformanceMetrics {
            total_orders,
            successful_orders,
            failed_orders,
            average_latency,
            p95_latency,
            p99_latency,
            throughput,
            memory_usage: 0, // 需要实际实现
            cpu_usage: 0.0,  // 需要实际实现
        }
    }
}

// 辅助函数
fn create_performance_test_config() -> MockConnectorConfig {
    MockConnectorConfig {
        exchange_type: ExchangeType::Binance,
        market_type: MarketType::Spot,
        supported_symbols: vec!["BTC/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(1), // 极低延迟用于性能测试
            latency_variance: Duration::from_millis(1),
            network_jitter: Duration::from_millis(0),
            enable_realistic_latency: false,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig {
            tick_interval: Duration::from_millis(1), // 高频数据
            price_volatility: 0.0001,
            volume_range: (Decimal::from(1), Decimal::from(100)),
            spread_range: (Decimal::from_str("0.0001").unwrap(), Decimal::from_str("0.0002").unwrap()),
            enable_realistic_movement: false,
        },
        account_config: AccountConfig {
            initial_balances: {
                let mut balances = HashMap::new();
                balances.insert("USDT".to_string(), Decimal::from(1000000)); // 大额余额
                balances.insert("BTC".to_string(), Decimal::from(100));
                balances
            },
            trading_fees: {
                let mut fees = HashMap::new();
                fees.insert("default".to_string(), Decimal::ZERO); // 无手续费
                fees
            },
            margin_requirements: HashMap::new(),
            max_leverage: Some(Decimal::from(100)),
        },
        execution_config: ExecutionConfig {
            partial_fill_probability: 0.0, // 总是完全成交
            slippage_range: (0.0, 0.0),    // 无滑点
            execution_delay: Duration::from_millis(1), // 极低执行延迟
            enable_realistic_execution: false,
        },
    }
}

fn create_test_risk_manager() -> Arc<dyn RiskManager> {
    // 创建一个宽松的风险管理器用于性能测试
    Arc::new(MockRiskManager::new_permissive())
}
```

## 6. 回测框架

### 6.1 历史数据回测

```rust
// src/testing/backtest_engine.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{DateTime, Utc, Duration};
use crate::types::*;
use crate::strategies::traits::Strategy;
use crate::testing::historical_data_provider::*;

// 🔥 回测引擎
pub struct BacktestEngine {
    // 历史数据提供者
    data_provider: Arc<HistoricalDataProvider>,
    
    // 策略实例
    strategies: Arc<RwLock<HashMap<String, Box<dyn Strategy + Send + Sync>>>>,
    
    // 回测配置
    config: BacktestConfig,
    
    // 回测状态
    current_time: Arc<RwLock<DateTime<Utc>>>,
    portfolio: Arc<RwLock<Portfolio>>,
    trade_history: Arc<RwLock<Vec<BacktestTrade>>>,
    
    // 性能指标
    metrics_calculator: Arc<BacktestMetricsCalculator>,
}

#[derive(Debug, Clone)]
pub struct BacktestConfig {
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub initial_capital: Decimal,
    pub symbols: Vec<String>,
    pub data_frequency: Duration, // 数据频率（如1分钟、5分钟等）
    pub commission_rate: Decimal,
    pub slippage_rate: Decimal,
    pub enable_realistic_execution: bool,
}

#[derive(Debug, Clone)]
pub struct Portfolio {
    pub cash: Decimal,
    pub positions: HashMap<String, Decimal>, // symbol -> quantity
    pub total_value: Decimal,
    pub unrealized_pnl: Decimal,
    pub realized_pnl: Decimal,
}

#[derive(Debug, Clone)]
pub struct BacktestTrade {
    pub timestamp: DateTime<Utc>,
    pub symbol: String,
    pub side: OrderSide,
    pub quantity: Decimal,
    pub price: Decimal,
    pub commission: Decimal,
    pub slippage: Decimal,
    pub strategy_name: String,
}

#[derive(Debug, Clone)]
pub struct BacktestResult {
    pub config: BacktestConfig,
    pub portfolio: Portfolio,
    pub trades: Vec<BacktestTrade>,
    pub metrics: BacktestMetrics,
    pub equity_curve: Vec<(DateTime<Utc>, Decimal)>,
    pub drawdown_curve: Vec<(DateTime<Utc>, Decimal)>,
}

#[derive(Debug, Clone)]
pub struct BacktestMetrics {
    pub total_return: Decimal,
    pub annualized_return: Decimal,
    pub volatility: Decimal,
    pub sharpe_ratio: Decimal,
    pub max_drawdown: Decimal,
    pub win_rate: Decimal,
    pub profit_factor: Decimal,
    pub total_trades: u64,
    pub winning_trades: u64,
    pub losing_trades: u64,
    pub average_win: Decimal,
    pub average_loss: Decimal,
    pub largest_win: Decimal,
    pub largest_loss: Decimal,
}

impl BacktestEngine {
    pub fn new(config: BacktestConfig, data_provider: Arc<HistoricalDataProvider>) -> Self {
        let initial_portfolio = Portfolio {
            cash: config.initial_capital,
            positions: HashMap::new(),
            total_value: config.initial_capital,
            unrealized_pnl: Decimal::ZERO,
            realized_pnl: Decimal::ZERO,
        };
        
        Self {
            data_provider,
            strategies: Arc::new(RwLock::new(HashMap::new())),
            config,
            current_time: Arc::new(RwLock::new(config.start_time)),
            portfolio: Arc::new(RwLock::new(initial_portfolio)),
            trade_history: Arc::new(RwLock::new(Vec::new())),
            metrics_calculator: Arc::new(BacktestMetricsCalculator::new()),
        }
    }
    
    // 🔥 添加策略
    pub async fn add_strategy(&self, name: String, strategy: Box<dyn Strategy + Send + Sync>) {
        let mut strategies = self.strategies.write().await;
        strategies.insert(name, strategy);
    }
    
    // 🔥 运行回测
    pub async fn run_backtest(&self) -> Result<BacktestResult, BacktestError> {
        log::info!("Starting backtest from {} to {}", self.config.start_time, self.config.end_time);
        
        // 初始化策略
        self.initialize_strategies().await?;
        
        // 获取历史数据
        let historical_data = self.data_provider.get_data(
            &self.config.symbols,
            self.config.start_time,
            self.config.end_time,
            self.config.data_frequency,
        ).await?;
        
        let mut equity_curve = Vec::new();
        let mut drawdown_curve = Vec::new();
        let mut peak_value = self.config.initial_capital;
        
        // 按时间顺序处理数据
        for data_point in historical_data {
            // 更新当前时间
            {
                let mut current_time = self.current_time.write().await;
                *current_time = data_point.timestamp;
            }
            
            // 更新投资组合价值
            self.update_portfolio_value(&data_point).await;
            
            // 处理市场数据
            self.process_market_data(data_point).await?;
            
            // 记录权益曲线
            let portfolio_value = self.portfolio.read().await.total_value;
            equity_curve.push((self.current_time.read().await.clone(), portfolio_value));
            
            // 计算回撤
            if portfolio_value > peak_value {
                peak_value = portfolio_value;
            }
            let drawdown = (peak_value - portfolio_value) / peak_value;
            drawdown_curve.push((self.current_time.read().await.clone(), drawdown));
        }
        
        // 计算最终指标
        let final_portfolio = self.portfolio.read().await.clone();
        let trades = self.trade_history.read().await.clone();
        let metrics = self.metrics_calculator.calculate_metrics(
            &self.config,
            &final_portfolio,
            &trades,
            &equity_curve,
        ).await;
        
        log::info!("Backtest completed. Total return: {:.2}%", metrics.total_return * Decimal::from(100));
        
        Ok(BacktestResult {
            config: self.config.clone(),
            portfolio: final_portfolio,
            trades,
            metrics,
            equity_curve,
            drawdown_curve,
        })
    }
    
    // 私有方法实现...
    async fn initialize_strategies(&self) -> Result<(), BacktestError> {
        let mut strategies = self.strategies.write().await;
        for (name, strategy) in strategies.iter_mut() {
            let config = StrategyConfig::default(); // 可以从配置文件加载
            strategy.initialize(config).await
                .map_err(|e| BacktestError::StrategyError(name.clone(), e))?;
            strategy.start().await
                .map_err(|e| BacktestError::StrategyError(name.clone(), e))?;
        }
        Ok(())
    }
    
    async fn process_market_data(&self, data: HistoricalDataPoint) -> Result<(), BacktestError> {
        let market_event = MarketDataEvent::OrderBookUpdate {
            symbol: data.symbol.clone(),
            order_book: data.order_book,
        };
        
        let mut strategies = self.strategies.write().await;
        for (name, strategy) in strategies.iter_mut() {
            let signals = strategy.on_market_data(market_event.clone()).await
                .map_err(|e| BacktestError::StrategyError(name.clone(), e))?;
            
            // 处理策略信号
            for signal in signals {
                self.process_strategy_signal(name.clone(), signal).await?;
            }
        }
        
        Ok(())
    }
    
    async fn process_strategy_signal(&self, strategy_name: String, signal: StrategySignal) -> Result<(), BacktestError> {
        match signal {
            StrategySignal::PlaceOrder(order_request) => {
                self.execute_backtest_order(strategy_name, order_request).await?;
            }
            StrategySignal::CancelOrder(_) => {
                // 回测中通常不需要处理取消订单
            }
            StrategySignal::UpdatePosition { .. } => {
                // 处理仓位更新
            }
            StrategySignal::EmergencyStop => {
                // 处理紧急停止
                log::warn!("Strategy {} triggered emergency stop", strategy_name);
            }
        }
        Ok(())
    }
    
    async fn execute_backtest_order(&self, strategy_name: String, order: OrderRequest) -> Result<(), BacktestError> {
        let current_time = self.current_time.read().await.clone();
        
        // 获取当前价格（简化实现，实际应该根据订单类型和市场深度计算）
        let execution_price = self.get_execution_price(&order).await?;
        
        // 计算手续费和滑点
        let commission = order.quantity * execution_price * self.config.commission_rate;
        let slippage = if self.config.enable_realistic_execution {
            execution_price * self.config.slippage_rate
        } else {
            Decimal::ZERO
        };
        
        let final_price = match order.side {
            OrderSide::Buy => execution_price + slippage,
            OrderSide::Sell => execution_price - slippage,
        };
        
        // 检查资金是否足够
        {
            let portfolio = self.portfolio.read().await;
            let required_cash = match order.side {
                OrderSide::Buy => order.quantity * final_price + commission,
                OrderSide::Sell => commission, // 卖出只需要手续费
            };
            
            if order.side == OrderSide::Buy && portfolio.cash < required_cash {
                return Err(BacktestError::InsufficientFunds);
            }
            
            // 检查是否有足够的持仓可以卖出
            if order.side == OrderSide::Sell {
                let current_position = portfolio.positions.get(&order.symbol).copied().unwrap_or(Decimal::ZERO);
                if current_position < order.quantity {
                    return Err(BacktestError::InsufficientPosition);
                }
            }
        }
        
        // 更新投资组合
        {
            let mut portfolio = self.portfolio.write().await;
            
            match order.side {
                OrderSide::Buy => {
                    portfolio.cash -= order.quantity * final_price + commission;
                    let current_position = portfolio.positions.entry(order.symbol.clone()).or_insert(Decimal::ZERO);
                    *current_position += order.quantity;
                }
                OrderSide::Sell => {
                    portfolio.cash += order.quantity * final_price - commission;
                    let current_position = portfolio.positions.get_mut(&order.symbol).unwrap();
                    *current_position -= order.quantity;
                    
                    // 如果持仓为零，移除该条目
                    if *current_position == Decimal::ZERO {
                        portfolio.positions.remove(&order.symbol);
                    }
                }
            }
        }
        
        // 记录交易
        {
            let mut trade_history = self.trade_history.write().await;
            trade_history.push(BacktestTrade {
                timestamp: current_time,
                symbol: order.symbol,
                side: order.side,
                quantity: order.quantity,
                price: final_price,
                commission,
                slippage,
                strategy_name,
            });
        }
        
        Ok(())
    }
    
    async fn get_execution_price(&self, order: &OrderRequest) -> Result<Decimal, BacktestError> {
        // 简化实现：使用当前市场价格
        // 实际实现应该根据订单类型、市场深度等因素计算
        let current_data = self.data_provider.get_current_price(&order.symbol).await
            .ok_or_else(|| BacktestError::PriceNotAvailable(order.symbol.clone()))?;
        
        Ok(current_data)
    }
    
    async fn update_portfolio_value(&self, data: &HistoricalDataPoint) {
        let mut portfolio = self.portfolio.write().await;
        
        // 计算持仓价值
        let mut total_position_value = Decimal::ZERO;
        for (symbol, quantity) in &portfolio.positions {
            if symbol == &data.symbol {
                // 使用当前数据点的价格
                let mid_price = (data.order_book.bids[0].price + data.order_book.asks[0].price) / Decimal::from(2);
                total_position_value += *quantity * mid_price;
            } else {
                // 使用最后已知价格（简化实现）
                if let Some(last_price) = self.data_provider.get_last_known_price(symbol).await {
                    total_position_value += *quantity * last_price;
                }
            }
        }
        
        portfolio.total_value = portfolio.cash + total_position_value;
    }
}

#[derive(Debug, thiserror::Error)]
pub enum BacktestError {
    #[error("Strategy error in {0}: {1}")]
    StrategyError(String, StrategyError),
    
    #[error("Insufficient funds for order execution")]
    InsufficientFunds,
    
    #[error("Insufficient position for sell order")]
    InsufficientPosition,
    
    #[error("Price not available for symbol: {0}")]
    PriceNotAvailable(String),
    
    #[error("Data provider error: {0}")]
    DataProviderError(String),
}
```

## 7. 配置管理

### 7.1 测试配置

```toml
# config/test_config.toml
[system]
name = "crossfury_test_system"
version = "1.0.0"
environment = "test"
log_level = "debug"

# 🔥 模拟连接器配置
[[connectors]]
name = "binance_spot_mock"
connector_type = "mock"
exchange_type = "binance"
market_type = "spot"
enabled = true

[connectors.config]
supported_symbols = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]

[connectors.config.latency_config]
base_latency = 10  # milliseconds
latency_variance = 5
network_jitter = 2
enable_realistic_latency = true

[connectors.config.error_config]
connection_error_rate = 0.01
order_error_rate = 0.005
market_data_error_rate = 0.001
timeout_rate = 0.002
enable_random_errors = true

[connectors.config.market_data_config]
tick_interval = 100  # milliseconds
price_volatility = 0.001
volume_range = [1.0, 1000.0]
spread_range = [0.0001, 0.001]
enable_realistic_movement = true

[connectors.config.account_config]
initial_balances = { "USDT" = 100000.0, "BTC" = 1.0, "ETH" = 10.0 }
trading_fees = { "default" = 0.001 }
max_leverage = 10.0

[connectors.config.execution_config]
partial_fill_probability = 0.1
slippage_range = [0.0, 0.001]
execution_delay = 50  # milliseconds
enable_realistic_execution = true

# 🔥 测试策略配置
[[strategies]]
name = "test_arbitrage_strategy"
strategy_type = "arbitrage"
enabled = true
symbols = ["BTC/USDT"]

[strategies.parameters]
min_profit_threshold = 0.001
max_position_size = 1000.0
risk_limit = 0.02

# 🔥 性能测试配置
[performance_test]
max_concurrent_orders = 1000
test_duration = 60  # seconds
target_throughput = 10000  # orders per second
memory_limit = 1073741824  # 1GB
cpu_limit = 80.0  # 80%

# 🔥 回测配置
[backtest]
start_date = "2023-01-01T00:00:00Z"
end_date = "2023-12-31T23:59:59Z"
initial_capital = 100000.0
data_frequency = "1m"  # 1 minute
commission_rate = 0.001
slippage_rate = 0.0005
enable_realistic_execution = true

[backtest.symbols]
spot = ["BTC/USDT", "ETH/USDT"]
futures = ["BTC/USDT-PERP", "ETH/USDT-PERP"]
```

## 8. 重构优势总结

### 8.1 核心优势

1. **完整的测试基础设施**
   - 提供从单元测试到集成测试的完整覆盖
   - 支持离线测试和真实环境模拟
   - 确保系统质量和可靠性

2. **真实的模拟环境**
   - MockConnector 提供接近真实交易环境的模拟
   - 支持延迟、错误、滑点等真实场景模拟
   - 可配置的市场数据生成和账户状态管理

3. **全面的性能测试**
   - 支持高并发订单执行测试
   - 市场数据吞吐量压力测试
   - 套利检测速度基准测试
   - 详细的性能指标收集和分析

4. **专业的回测框架**
   - 支持历史数据回测和策略验证
   - 完整的投资组合管理和风险控制
   - 详细的性能指标计算（夏普比率、最大回撤等）
   - 可视化的权益曲线和回撤分析

### 8.2 技术特性

1. **模块化设计**
   - 各测试组件独立可复用
   - 支持插件式扩展
   - 易于维护和升级

2. **配置驱动**
   - 通过配置文件灵活控制测试行为
   - 支持不同测试场景的快速切换
   - 便于CI/CD集成

3. **异步高性能**
   - 基于Tokio异步运行时
   - 支持高并发测试场景
   - 优化的内存使用和CPU效率

4. **可观测性**
   - 详细的测试日志和指标
   - 实时性能监控
   - 测试结果可视化

### 8.3 实施建议

1. **分阶段实施**
   - 第一阶段：实现MockConnector和基础单元测试
   - 第二阶段：完善集成测试和性能测试框架
   - 第三阶段：构建回测框架和高级分析工具

2. **持续集成**
   - 将测试框架集成到CI/CD流水线
   - 自动化测试执行和报告生成
   - 性能回归检测和告警

3. **文档和培训**
   - 编写详细的测试框架使用文档
   - 提供测试最佳实践指南
   - 团队培训和知识分享

通过这个全面的测试框架模块，CrossFury系统将具备企业级的质量保证能力，确保在高频交易环境下的稳定性和可靠性。

## 9. 新目录结构设计

```
src/
├── testing/                     # 测试框架模块
│   ├── mod.rs                   # 模块导出
│   ├── traits.rs                # 引用核心trait定义
│   ├── mock_connector.rs        # 模拟连接器实现
│   ├── test_framework.rs        # 测试框架管理器
│   ├── mock_data_provider.rs    # 测试数据提供者
│   ├── market_simulator.rs      # 市场数据模拟器
│   ├── account_simulator.rs     # 账户数据模拟器
│   ├── order_manager.rs         # 订单管理模拟器
│   ├── latency_simulator.rs     # 延迟模拟器
│   ├── error_simulator.rs       # 错误模拟器
│   ├── performance_tester.rs    # 性能测试器
│   ├── backtest_engine.rs       # 回测引擎
│   ├── test_data_generator.rs   # 测试数据生成器
│   ├── legacy_adapter.rs        # 旧代码适配器
│   └── utils.rs                 # 测试工具函数
├── types/                       # 数据类型定义
│   ├── testing.rs               # 测试相关类型
│   ├── mock_data.rs             # 模拟数据类型
│   ├── test_config.rs           # 测试配置类型
│   └── performance.rs           # 性能测试类型
├── legacy_tests/                # 旧代码保留
│   ├── legacy_unit_tests.rs     # 原单元测试
│   ├── legacy_integration_tests.rs # 原集成测试
│   └── legacy_benchmarks.rs     # 原性能测试
├── tests/                       # 新测试目录
│   ├── unit/                    # 单元测试
│   │   ├── connectors/          # 连接器单元测试
│   │   ├── executors/           # 执行器单元测试
│   │   ├── strategies/          # 策略单元测试
│   │   └── testing/             # 测试框架单元测试
│   ├── integration/             # 集成测试
│   │   ├── system_integration.rs # 系统集成测试
│   │   ├── multi_exchange.rs    # 多交易所测试
│   │   └── end_to_end.rs        # 端到端测试
│   ├── performance/             # 性能测试
│   │   ├── latency_tests.rs     # 延迟测试
│   │   ├── throughput_tests.rs  # 吞吐量测试
│   │   └── stress_tests.rs      # 压力测试
│   └── backtest/                # 回测测试
│       ├── strategy_backtest.rs # 策略回测
│       └── portfolio_backtest.rs # 投资组合回测
└── config/
    ├── testing.rs               # 测试配置管理
    └── mock_data.rs             # 模拟数据配置
```

## 10. 分阶段实施步骤

### 阶段1：基础设施搭建（2-3周）

#### 1.1 创建新目录结构
- 创建 `src/testing/` 目录及子模块
- 创建 `src/types/` 目录及测试相关类型定义
- 创建 `src/legacy_tests/` 目录
- 创建新的 `tests/` 目录结构

#### 1.2 保留旧代码
```bash
# 重命名现有测试文件，保持功能不变
mv tests/ src/legacy_tests/  # 保留现有测试目录
cp -r src/**/tests src/legacy_tests/  # 保留模块内测试
# 保留各模块中的 #[cfg(test)] 代码块
```

#### 1.3 创建trait引用文件
```rust
// src/testing/traits.rs
pub use crate::traits::{
    ExchangeConnector, TestConnector, MockDataProvider, TestFramework
};
```

### 阶段2：模拟连接器实现（3-4周）

#### 2.1 实现MockConnector
- 创建 `MockConnector` 核心实现
- 实现 `ExchangeConnector` trait 的完整功能
- 添加市场数据模拟和账户数据模拟
- 实现延迟和错误模拟功能

#### 2.2 测试数据生成器
- 实现 `TestDataGenerator`
- 支持各种市场数据生成（订单簿、交易、K线等）
- 实现真实数据回放功能
- 添加数据验证和质量检查

#### 2.3 旧测试适配器
- 创建 `LegacyTestAdapter`
- 实现旧测试到新框架的转换
- 确保现有测试功能正常工作
- 保持测试覆盖率不降低

### 阶段3：测试框架核心（3-4周）

#### 3.1 测试框架管理器
- 实现 `TestFrameworkManager`
- 添加测试生命周期管理
- 实现测试配置和环境管理
- 集成CI/CD支持

#### 3.2 性能测试框架
- 实现 `PerformanceTester`
- 添加延迟、吞吐量、并发测试
- 实现性能基准和回归检测
- 添加详细的性能指标收集

#### 3.3 单元测试迁移
- 重构现有单元测试
- 使用新的测试框架和模拟器
- 提高测试覆盖率和质量
- 添加边界条件和异常测试

### 阶段4：集成测试和回测（3-4周）

#### 4.1 集成测试框架
- 实现系统级集成测试
- 添加多交易所协作测试
- 实现端到端测试场景
- 添加故障恢复和容错测试

#### 4.2 回测引擎
- 实现 `BacktestEngine`
- 支持历史数据回放
- 实现策略性能评估
- 添加风险指标计算

#### 4.3 测试报告系统
- 实现自动化测试报告生成
- 添加测试覆盖率分析
- 实现性能趋势分析
- 集成可视化图表

### 阶段5：优化和集成（2-3周）

#### 5.1 性能优化
- 优化测试执行速度
- 减少测试资源消耗
- 实现并行测试执行
- 添加测试缓存机制

#### 5.2 CI/CD集成
- 集成到持续集成流水线
- 实现自动化测试触发
- 添加测试结果通知
- 实现测试失败自动回滚

#### 5.3 文档和工具
- 编写测试框架使用文档
- 创建测试最佳实践指南
- 开发测试辅助工具
- 提供测试模板和示例

### 阶段6：清理和文档（1-2周）

#### 6.1 代码清理
- 移除未使用的旧测试代码
- 优化测试代码结构
- 统一测试代码风格
- 添加详细的测试文档

#### 6.2 培训和推广
- 团队培训和知识分享
- 编写测试开发指南
- 建立测试质量标准
- 推广测试最佳实践

### 总时间预估：14-20周

### 风险控制措施
1. **渐进式迁移**：每个阶段都保持现有测试功能正常
2. **并行开发**：新旧测试框架并存，逐步切换
3. **质量保证**：确保测试覆盖率不降低
4. **回滚机制**：出现问题时可快速回滚到旧版本
5. **持续监控**：实时监控测试执行状态和质量指标
6. **文档同步**：开发过程中同步更新文档和培训材料
```

### 3.2 策略测试

```rust
// tests/unit/strategies/test_strategy_framework.rs
use tokio_test;
use std::collections::HashMap;
use crossfury::strategies::traits::*;
use crossfury::strategies::base_strategy::*;
use crossfury::types::*;

// 🔥 测试策略实现
struct TestStrategy {
    base: BaseStrategy,
    signal_count: Arc<RwLock<u32>>,
}

#[async_trait]
impl Strategy for TestStrategy {
    fn get_strategy_name(&self) -> &str {
        "test_strategy"
    }
    
    fn get_strategy_version(&self) -> &str {
        "1.0.0"
    }
    
    fn get_description(&self) -> &str {
        "Test strategy for unit testing"
    }
    
    fn get_supported_markets(&self) -> Vec<MarketType> {
        vec![MarketType::Spot]
    }
    
    fn get_required_symbols(&self) -> Vec<String> {
        vec!["BTC/USDT".to_string()]
    }
    
    async fn initialize(&mut self, config: StrategyConfig) -> Result<(), StrategyError> {
        self.base.set_state(StrategyState::Ready).await;
        Ok(())
    }
    
    async fn start(&mut self) -> Result<(), StrategyError> {
        self.base.set_state(StrategyState::Running).await;
        Ok(())
    }
    
    async fn stop(&mut self) -> Result<(), StrategyError> {
        self.base.set_state(StrategyState::Stopped).await;
        Ok(())
    }
    
    async fn cleanup(&mut self) -> Result<(), StrategyError> {
        Ok(())
    }
    
    async fn on_market_data(&mut self, data: MarketDataEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        // 增加信号计数
        {
            let mut count = self.signal_count.write().await;
            *count += 1;
        }
        
        // 简单的测试逻辑：价格上涨时买入
        match data {
            MarketDataEvent::OrderBookUpdate { symbol, order_book } => {
                if let (Some(best_bid), Some(best_ask)) = (order_book.bids.first(), order_book.asks.first()) {
                    let mid_price = (best_bid.price + best_ask.price) / Decimal::from(2);
                    
                    // 如果价格高于某个阈值，生成买入信号
                    if mid_price > Decimal::from(50000) {
                        let order_request = OrderRequest {
                            client_order_id: format!("test_order_{}", Utc::now().timestamp()),
                            symbol: symbol.clone(),
                            side: OrderSide::Buy,
                            order_type: OrderType::Market,
                            quantity: Decimal::from_str("0.001").unwrap(),
                            price: None,
                            time_in_force: Some(TimeInForce::IOC),
                        };
                        
                        return Ok(vec![StrategySignal::PlaceOrder(order_request)]);
                    }
                }
            }
            _ => {}
        }
        
        Ok(vec![])
    }
    
    async fn on_user_data(&mut self, data: UserDataEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn on_system_event(&mut self, event: SystemEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn on_execution_result(&mut self, result: ExecutionResult) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn on_execution_error(&mut self, error: ExecutionError) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn get_strategy_state(&self) -> StrategyState {
        self.base.get_state().await
    }
    
    async fn set_strategy_parameters(&mut self, params: HashMap<String, StrategyParameter>) -> Result<(), StrategyError> {
        for (key, value) in params {
            self.base.set_parameter(key, value).await;
        }
        Ok(())
    }
    
    async fn get_strategy_metrics(&self) -> StrategyMetrics {
        StrategyMetrics::default()
    }
    
    async fn get_risk_limits(&self) -> RiskLimits {
        RiskLimits::default()
    }
    
    async fn handle_risk_event(&mut self, event: RiskEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
}

impl TestStrategy {
    fn new() -> Self {
        Self {
            base: BaseStrategy::new(
                "test_strategy".to_string(),
                "1.0.0".to_string(),
                "Test strategy".to_string(),
            ),
            signal_count: Arc::new(RwLock::new(0)),
        }
    }
    
    async fn get_signal_count(&self) -> u32 {
        *self.signal_count.read().await
    }
}

#[tokio::test]
async fn test_strategy_lifecycle() {
    // 🔥 测试策略生命周期
    let mut strategy = TestStrategy::new();
    
    // 测试初始化
    let config = StrategyConfig::default();
    let result = strategy.initialize(config).await;
    assert!(result.is_ok());
    assert_eq!(strategy.get_strategy_state().await, StrategyState::Ready);
    
    // 测试启动
    let result = strategy.start().await;
    assert!(result.is_ok());
    assert_eq!(strategy.get_strategy_state().await, StrategyState::Running);
    
    // 测试停止
    let result = strategy.stop().await;
    assert!(result.is_ok());
    assert_eq!(strategy.get_strategy_state().await, StrategyState::Stopped);
}

#[tokio::test]
async fn test_strategy_market_data_processing() {
    // 🔥 测试策略市场数据处理
    let mut strategy = TestStrategy::new();
    strategy.initialize(StrategyConfig::default()).await.unwrap();
    strategy.start().await.unwrap();
    
    // 创建测试订单簿数据
    let order_book = OrderBook {
        symbol: "BTC/USDT".to_string(),
        bids: vec![PriceLevel { price: Decimal::from(49999), quantity: Decimal::from(1) }],
        asks: vec![PriceLevel { price: Decimal::from(50001), quantity: Decimal::from(1) }],
        timestamp: Utc::now(),
    };
    
    let market_data = MarketDataEvent::OrderBookUpdate {
        symbol: "BTC/USDT".to_string(),
        order_book,
    };
    
    // 处理市场数据
    let signals = strategy.on_market_data(market_data).await.unwrap();
    
    // 验证信号生成
    assert_eq!(signals.len(), 1);
    match &signals[0] {
        StrategySignal::PlaceOrder(order) => {
            assert_eq!(order.symbol, "BTC/USDT");
            assert_eq!(order.side, OrderSide::Buy);
        }
        _ => panic!("Expected PlaceOrder signal"),
    }
    
    // 验证信号计数
    assert_eq!(strategy.get_signal_count().await, 1);
}

#[tokio::test]
async fn test_strategy_parameter_management() {
    // 🔥 测试策略参数管理
    let mut strategy = TestStrategy::new();
    
    // 设置参数
    let mut params = HashMap::new();
    params.insert("profit_threshold".to_string(), StrategyParameter::Float(0.01));
    params.insert("max_position".to_string(), StrategyParameter::Decimal(Decimal::from(1000)));
    params.insert("enabled".to_string(), StrategyParameter::Boolean(true));
    
    let result = strategy.set_strategy_parameters(params).await;
    assert!(result.is_ok());
    
    // 验证参数设置
    let profit_threshold: Option<f64> = strategy.base.get_parameter("profit_threshold").await;
    assert_eq!(profit_threshold, Some(0.01));
    
    let enabled: Option<bool> = strategy.base.get_parameter("enabled").await;
    assert_eq!(enabled, Some(true));
}
```

## 4. 集成测试框架

### 4.1 端到端测试

```rust
// tests/integration/test_end_to_end.rs
use tokio_test;
use std::time::Duration;
use crossfury::config::SystemAssembler;
use crossfury::testing::mock_connector::*;
use crossfury::testing::test_data_generator::*;

#[tokio::test]
async fn test_complete_trading_flow() {
    // 🔥 端到端交易流程测试
    
    // 1. 创建测试配置
    let test_config = create_integration_test_config().await;
    
    // 2. 组装系统
    let assembler = SystemAssembler::new();
    let mut system = assembler.assemble_from_config(test_config).await.unwrap();
    
    // 3. 启动系统
    system.start().await.unwrap();
    
    // 4. 等待系统稳定
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // 5. 验证连接器状态
    let connector_manager = system.get_connector_manager();
    let connectors = connector_manager.get_all_connectors().await;
    assert!(!connectors.is_empty());
    
    // 6. 验证市场数据流
    let data_flow_manager = system.get_data_flow_manager();
    let mut market_data_stream = data_flow_manager.get_market_data_stream().await.unwrap();
    
    // 等待市场数据
    let timeout = tokio::time::timeout(Duration::from_secs(5), market_data_stream.recv()).await;
    assert!(timeout.is_ok());
    
    // 7. 测试策略执行
    let strategy_manager = system.get_strategy_manager();
    let strategies = strategy_manager.get_all_strategies().await;
    assert!(!strategies.is_empty());
    
    // 8. 测试订单执行
    let order_executor = system.get_order_executor();
    let order_request = OrderRequest {
        client_order_id: "integration_test_order".to_string(),
        symbol: "BTC/USDT".to_string(),
        side: OrderSide::Buy,
        order_type: OrderType::Market,
        quantity: Decimal::from_str("0.001").unwrap(),
        price: None,
        time_in_force: Some(TimeInForce::IOC),
    };
    
    let execution_result = order_executor.execute_order(order_request).await;
    assert!(execution_result.is_ok());
    
    // 9. 停止系统
    system.stop().await.unwrap();
}

#[tokio::test]
async fn test_multi_exchange_arbitrage() {
    // 🔥 多交易所套利测试
    
    // 创建多个模拟连接器
    let binance_config = create_mock_connector_config(ExchangeType::Binance, MarketType::Spot);
    let okx_config = create_mock_connector_config(ExchangeType::OKX, MarketType::Spot);
    
    let binance_connector = MockConnector::new(binance_config);
    let okx_connector = MockConnector::new(okx_config);
    
    // 设置不同的价格以创建套利机会
    binance_connector.set_market_price("BTC/USDT", Decimal::from(50000)).await;
    okx_connector.set_market_price("BTC/USDT", Decimal::from(50100)).await;
    
    // 连接所有连接器
    binance_connector.connect().await.unwrap();
    okx_connector.connect().await.unwrap();
    
    // 创建套利引擎
    let arbitrage_engine = ArbitrageEngine::new();
    arbitrage_engine.add_connector("binance", Arc::new(binance_connector)).await;
    arbitrage_engine.add_connector("okx", Arc::new(okx_connector)).await;
    
    // 扫描套利机会
    let opportunities = arbitrage_engine.scan_opportunities("BTC/USDT").await.unwrap();
    assert!(!opportunities.is_empty());
    
    // 执行套利
    let opportunity = &opportunities[0];
    let result = arbitrage_engine.execute_arbitrage(opportunity.clone()).await;
    assert!(result.is_ok());
}

#[tokio::test]
async fn test_risk_management_integration() {
    // 🔥 风险管理集成测试
    
    let test_config = create_integration_test_config().await;
    let assembler = SystemAssembler::new();
    let mut system = assembler.assemble_from_config(test_config).await.unwrap();
    
    system.start().await.unwrap();
    
    let risk_manager = system.get_risk_manager();
    let order_executor = system.get_order_executor();
    
    // 测试超出风险限制的订单
    let large_order = OrderRequest {
        client_order_id: "large_order_test".to_string(),
        symbol: "BTC/USDT".to_string(),
        side: OrderSide::Buy,
        order_type: OrderType::Market,
        quantity: Decimal::from(1000), // 超大订单
        price: None,
        time_in_force: Some(TimeInForce::IOC),
    };
    
    // 风险检查应该拒绝这个订单
    let risk_check = risk_manager.check_order_risk(&large_order).await;
    assert!(risk_check.is_err());
    
    // 执行器应该拒绝执行
    let execution_result = order_executor.execute_order(large_order).await;
    assert!(execution_result.is_err());
    
    system.stop().await.unwrap();
}

// 辅助函数
async fn create_integration_test_config() -> SystemConfig {
    SystemConfig {
        system: SystemSettings {
            name: "integration_test_system".to_string(),
            version: "1.0.0".to_string(),
            environment: "test".to_string(),
            log_level: "debug".to_string(),
        },
        connectors: vec![
            ConnectorConfig {
                name: "binance_spot".to_string(),
                connector_type: "mock".to_string(),
                exchange_type: ExchangeType::Binance,
                market_type: MarketType::Spot,
                enabled: true,
                config: serde_json::json!({
                    "supported_symbols": ["BTC/USDT", "ETH/USDT"],
                    "latency_config": {
                        "base_latency": 10,
                        "enable_realistic_latency": false
                    },
                    "error_config": {
                        "enable_random_errors": false
                    }
                }),
            },
        ],
        executor: ExecutorConfig {
            max_concurrent_orders: 100,
            order_timeout: Duration::from_secs(30),
            retry_attempts: 3,
            batch_size: 10,
        },
        strategies: vec![
            StrategyConfig {
                name: "test_strategy".to_string(),
                strategy_type: "test".to_string(),
                enabled: true,
                symbols: vec!["BTC/USDT".to_string()],
                parameters: HashMap::new(),
            },
        ],
        event_bus: EventBusConfig {
            high_frequency_buffer_size: 10000,
            system_event_buffer_size: 1000,
            enable_persistence: false,
        },
        monitoring: MonitoringConfig {
            enabled: true,
            metrics_interval: Duration::from_secs(1),
            health_check_interval: Duration::from_secs(5),
        },
        logging: LoggingConfig {
            level: "debug".to_string(),
            output: "console".to_string(),
            format: "json".to_string(),
        },
    }
}

fn create_mock_connector_config(exchange_type: ExchangeType, market_type: MarketType) -> MockConnectorConfig {
    MockConnectorConfig {
        exchange_type,
        market_type,
        supported_symbols: vec!["BTC/USDT".to_string(), "ETH/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(10),
            latency_variance: Duration::from_millis(5),
            network_jitter: Duration::from_millis(2),
            enable_realistic_latency: false,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig {
            tick_interval: Duration::from_millis(100),
            price_volatility: 0.001,
            volume_range: (Decimal::from(1), Decimal::from(1000)),
            spread_range: (Decimal::from_str("0.0001").unwrap(), Decimal::from_str("0.001").unwrap()),
            enable_realistic_movement: true,
        },
        account_config: AccountConfig {
            initial_balances: {
                let mut balances = HashMap::new();
                balances.insert("USDT".to_string(), Decimal::from(100000));
                balances.insert("BTC".to_string(), Decimal::from(1));
                balances
            },
            trading_fees: {
                let mut fees = HashMap::new();
                fees.insert("default".to_string(), Decimal::from_str("0.001").unwrap());
                fees
            },
            margin_requirements: HashMap::new(),
            max_leverage: Some(Decimal::from(10)),
        },
        execution_config: ExecutionConfig {
            partial_fill_probability: 0.1,
            slippage_range: (0.0, 0.001),
            execution_delay: Duration::from_millis(50),
            enable_realistic_execution: true,
        },
    }
}
```