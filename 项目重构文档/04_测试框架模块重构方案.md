# æµ‹è¯•æ¡†æ¶æ¨¡å—é‡æ„æ–¹æ¡ˆ

## 1. æ¨¡å—æ¦‚è¿°

æµ‹è¯•æ¡†æ¶æ¨¡å—æ˜¯ CrossFury ç³»ç»Ÿè´¨é‡ä¿è¯çš„æ ¸å¿ƒï¼Œæä¾›å®Œæ•´çš„æµ‹è¯•åŸºç¡€è®¾æ–½ï¼ŒåŒ…æ‹¬æ¨¡æ‹Ÿè¿æ¥å™¨ã€æµ‹è¯•æ•°æ®ç”Ÿæˆã€è‡ªåŠ¨åŒ–æµ‹è¯•å¥—ä»¶å’Œæ€§èƒ½åŸºå‡†æµ‹è¯•ã€‚æœ¬æ¨¡å—é‡‡ç”¨**åˆ†å±‚æµ‹è¯•æ¶æ„**ï¼Œç¡®ä¿ç³»ç»Ÿå„ä¸ªå±‚æ¬¡çš„åŠŸèƒ½æ­£ç¡®æ€§å’Œæ€§èƒ½è¡¨ç°ã€‚

**æœ¬é‡æ„æ–¹æ¡ˆå°†ä¸¥æ ¼éµå¾ª `CrossFury_æ ¸å¿ƒTraitå®šä¹‰.md` ä¸­å®šä¹‰çš„æ¥å£è§„èŒƒï¼Œç¡®ä¿æµ‹è¯•æ¡†æ¶ä¸ç³»ç»Ÿå…¶ä»–æ¨¡å—çš„å®Œç¾é›†æˆã€‚**

### 1.1 æ ¸å¿ƒèŒè´£
- **æ¨¡æ‹Ÿè¿æ¥å™¨**ï¼šæä¾›å®Œæ•´çš„äº¤æ˜“æ‰€APIæ¨¡æ‹Ÿï¼Œæ”¯æŒç¦»çº¿æµ‹è¯•
- **æµ‹è¯•æ•°æ®ç®¡ç†**ï¼šç”Ÿæˆå’Œç®¡ç†å„ç§æµ‹è¯•åœºæ™¯çš„å¸‚åœºæ•°æ®
- **å•å…ƒæµ‹è¯•æ¡†æ¶**ï¼šé’ˆå¯¹å„ä¸ªæ¨¡å—çš„ç‹¬ç«‹åŠŸèƒ½æµ‹è¯•
- **é›†æˆæµ‹è¯•æ¡†æ¶**ï¼šéªŒè¯æ¨¡å—é—´åä½œå’Œæ•°æ®æµ
- **æ€§èƒ½æµ‹è¯•æ¡†æ¶**ï¼šå‹åŠ›æµ‹è¯•å’Œæ€§èƒ½åŸºå‡†æµ‹è¯•
- **å›æµ‹æ¡†æ¶**ï¼šå†å²æ•°æ®å›æµ‹å’Œç­–ç•¥éªŒè¯
- **æµ‹è¯•æŠ¥å‘Š**ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•æŠ¥å‘Šå’Œè¦†ç›–ç‡åˆ†æ

### 1.2 è®¾è®¡åŸåˆ™
- **çœŸå®æ€§**ï¼šæ¨¡æ‹Ÿç¯å¢ƒå°½å¯èƒ½æ¥è¿‘çœŸå®äº¤æ˜“ç¯å¢ƒ
- **å¯é‡ç°æ€§**ï¼šæµ‹è¯•ç»“æœå¯é‡ç°ï¼Œæ”¯æŒç¡®å®šæ€§æµ‹è¯•
- **å…¨é¢æ€§**ï¼šè¦†ç›–æ­£å¸¸åœºæ™¯ã€è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µ
- **è‡ªåŠ¨åŒ–**ï¼šæ”¯æŒCI/CDé›†æˆï¼Œè‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡Œ
- **å¯æ‰©å±•æ€§**ï¼šæ˜“äºæ·»åŠ æ–°çš„æµ‹è¯•åœºæ™¯å’Œäº¤æ˜“æ‰€æ”¯æŒ
- **æ€§èƒ½å¯¼å‘**ï¼šé‡ç‚¹å…³æ³¨é«˜é¢‘äº¤æ˜“åœºæ™¯çš„æ€§èƒ½æµ‹è¯•
- **Traitç»Ÿä¸€**ï¼šæ‰€æœ‰æµ‹è¯•ç»„ä»¶ä¸¥æ ¼å®ç°æ ¸å¿ƒtraitå®šä¹‰ï¼Œç¡®ä¿æ¥å£ä¸€è‡´æ€§

### 1.3 æ—§ä»£ç æ›¿æ¢è§„åˆ’

#### 1.3.1 ç°æœ‰æµ‹è¯•ä»£ç åˆ†æ
å½“å‰é¡¹ç›®ä¸­çš„æµ‹è¯•ç›¸å…³ä»£ç ä¸»è¦åˆ†å¸ƒåœ¨ï¼š
- `tests/` ç›®å½•ï¼šç°æœ‰çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- `src/` ç›®å½•ä¸­çš„æµ‹è¯•æ¨¡å—ï¼šå†…åµŒçš„æµ‹è¯•ä»£ç 
- å„æ¨¡å—ä¸­çš„ `#[cfg(test)]` ä»£ç å—
- å¯èƒ½å­˜åœ¨çš„æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•ä»£ç 

#### 1.3.2 è¿ç§»ç­–ç•¥
1. **ä¿ç•™æ—§ä»£ç **ï¼šå°†ç°æœ‰æµ‹è¯•ä»£ç ç§»åŠ¨åˆ° `src/legacy_tests/` ç›®å½•
2. **åˆ›å»ºæ–°ç»“æ„**ï¼šå»ºç«‹æ–°çš„ `src/testing/` æ¨¡å—ç»“æ„
3. **é€æ­¥è¿ç§»**ï¼šæŒ‰æ¨¡å—é€æ­¥å°†æµ‹è¯•è¿ç§»åˆ°æ–°æ¡†æ¶
4. **é€‚é…å™¨æ¨¡å¼**ï¼šåˆ›å»ºé€‚é…å™¨è¿æ¥æ–°æ—§æµ‹è¯•ç³»ç»Ÿ
5. **æ¸è¿›æ›¿æ¢**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡ä¸é™ä½çš„å‰æä¸‹é€æ­¥æ›¿æ¢

## 2. æ¨¡æ‹Ÿè¿æ¥å™¨è®¾è®¡

### 2.1 æ ¸å¿ƒTraitå®šä¹‰å¼•ç”¨

**æ¨¡æ‹Ÿè¿æ¥å™¨ä¸¥æ ¼éµå¾ª `CrossFury_æ ¸å¿ƒTraitå®šä¹‰.md` ä¸­å®šä¹‰çš„æ¥å£è§„èŒƒï¼š**

#### 2.1.1 æ ¸å¿ƒTraitå®ç°è¦æ±‚
- **ExchangeConnector**: æ¨¡æ‹Ÿè¿æ¥å™¨å¿…é¡»å®Œæ•´å®ç°æ­¤trait
- **TestConnector**: ä¸“é—¨ä¸ºæµ‹è¯•è®¾è®¡çš„æ‰©å±•trait
- **MockDataProvider**: æµ‹è¯•æ•°æ®æä¾›è€…trait
- **TestFramework**: æµ‹è¯•æ¡†æ¶ç®¡ç†trait

#### 2.1.2 æ”¯æŒçš„æµ‹è¯•åœºæ™¯
- **å•å…ƒæµ‹è¯•**: æ¨¡æ‹Ÿå•ä¸ªç»„ä»¶çš„è¡Œä¸º
- **é›†æˆæµ‹è¯•**: æ¨¡æ‹Ÿå¤šç»„ä»¶åä½œåœºæ™¯
- **æ€§èƒ½æµ‹è¯•**: é«˜å¹¶å‘å’Œå‹åŠ›æµ‹è¯•
- **å›æµ‹æµ‹è¯•**: å†å²æ•°æ®å›æ”¾æµ‹è¯•
- **é”™è¯¯æµ‹è¯•**: å¼‚å¸¸æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•

#### 2.1.3 æ—§ä»£ç é€‚é…å™¨å®ç°
```rust
// src/testing/legacy_adapter.rs
use crate::traits::{ExchangeConnector, TestConnector};
use crate::legacy_tests::*;

/// æ—§æµ‹è¯•ä»£ç é€‚é…å™¨
pub struct LegacyTestAdapter {
    legacy_test_runner: LegacyTestRunner,
    connector: Box<dyn ExchangeConnector>,
}

impl LegacyTestAdapter {
    pub fn new(legacy_runner: LegacyTestRunner) -> Self {
        Self {
            legacy_test_runner: legacy_runner,
            connector: Box::new(MockConnector::new(MockConnectorConfig::default())),
        }
    }
    
    /// å°†æ—§æµ‹è¯•è½¬æ¢ä¸ºæ–°æ ¼å¼
    pub async fn convert_legacy_test(&self, test_name: &str) -> Result<TestCase, TestError> {
        // å®ç°æ—§æµ‹è¯•åˆ°æ–°æµ‹è¯•çš„è½¬æ¢é€»è¾‘
        todo!()
    }
}
```

### 2.2 MockConnector å®ç°

```rust
// src/testing/mock_connector.rs
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex, mpsc, broadcast};
use crate::traits::*;  // å¼•ç”¨æ ¸å¿ƒtraitå®šä¹‰
use crate::types::*;
use crate::testing::market_simulator::*;

// ğŸ”¥ æ¨¡æ‹Ÿè¿æ¥å™¨ï¼ˆæ ¸å¿ƒæµ‹è¯•åŸºç¡€è®¾æ–½ï¼‰
pub struct MockConnector {
    // åŸºæœ¬ä¿¡æ¯
    exchange_type: ExchangeType,
    market_type: MarketType,
    
    // æ¨¡æ‹ŸçŠ¶æ€
    connection_state: Arc<RwLock<ConnectionState>>,
    
    // å¸‚åœºæ•°æ®æ¨¡æ‹Ÿ
    market_simulator: Arc<MarketSimulator>,
    order_book_cache: Arc<RwLock<HashMap<String, OrderBook>>>,
    trade_cache: Arc<RwLock<HashMap<String, Vec<Trade>>>>,
    
    // ç”¨æˆ·æ•°æ®æ¨¡æ‹Ÿ
    account_simulator: Arc<AccountSimulator>,
    order_manager: Arc<MockOrderManager>,
    position_tracker: Arc<MockPositionTracker>,
    
    // æ•°æ®æµ
    market_data_sender: Arc<Mutex<Option<mpsc::UnboundedSender<HighFrequencyData>>>>,
    user_data_sender: Arc<Mutex<Option<mpsc::UnboundedSender<UserDataEvent>>>>,
    system_event_sender: Arc<Mutex<Option<broadcast::Sender<SystemEvent>>>>,
    
    // é…ç½®å’Œæ§åˆ¶
    config: MockConnectorConfig,
    latency_simulator: Arc<LatencySimulator>,
    error_simulator: Arc<ErrorSimulator>,
}

#[derive(Debug, Clone)]
pub struct MockConnectorConfig {
    pub exchange_type: ExchangeType,
    pub market_type: MarketType,
    pub supported_symbols: Vec<String>,
    
    // ğŸ”¥ å»¶è¿Ÿæ¨¡æ‹Ÿé…ç½®
    pub latency_config: LatencyConfig,
    
    // ğŸ”¥ é”™è¯¯æ¨¡æ‹Ÿé…ç½®
    pub error_config: ErrorConfig,
    
    // ğŸ”¥ å¸‚åœºæ•°æ®é…ç½®
    pub market_data_config: MarketDataConfig,
    
    // ğŸ”¥ è´¦æˆ·é…ç½®
    pub account_config: AccountConfig,
    
    // ğŸ”¥ è®¢å•æ‰§è¡Œé…ç½®
    pub execution_config: ExecutionConfig,
}

#[derive(Debug, Clone)]
pub struct LatencyConfig {
    pub base_latency: Duration,           // åŸºç¡€å»¶è¿Ÿ
    pub latency_variance: Duration,      // å»¶è¿Ÿæ–¹å·®
    pub network_jitter: Duration,        // ç½‘ç»œæŠ–åŠ¨
    pub enable_realistic_latency: bool,  // å¯ç”¨çœŸå®å»¶è¿Ÿæ¨¡æ‹Ÿ
}

#[derive(Debug, Clone)]
pub struct ErrorConfig {
    pub connection_error_rate: f64,      // è¿æ¥é”™è¯¯ç‡
    pub order_error_rate: f64,           // è®¢å•é”™è¯¯ç‡
    pub market_data_error_rate: f64,     // å¸‚åœºæ•°æ®é”™è¯¯ç‡
    pub timeout_rate: f64,               // è¶…æ—¶ç‡
    pub enable_random_errors: bool,      // å¯ç”¨éšæœºé”™è¯¯
}

#[derive(Debug, Clone)]
pub struct MarketDataConfig {
    pub tick_interval: Duration,         // è¡Œæƒ…æ›´æ–°é—´éš”
    pub price_volatility: f64,           // ä»·æ ¼æ³¢åŠ¨ç‡
    pub volume_range: (Decimal, Decimal), // æˆäº¤é‡èŒƒå›´
    pub spread_range: (Decimal, Decimal), // ä»·å·®èŒƒå›´
    pub enable_realistic_movement: bool,  // å¯ç”¨çœŸå®ä»·æ ¼èµ°åŠ¿
}

#[derive(Debug, Clone)]
pub struct AccountConfig {
    pub initial_balances: HashMap<String, Decimal>, // åˆå§‹ä½™é¢
    pub trading_fees: HashMap<String, Decimal>,     // äº¤æ˜“æ‰‹ç»­è´¹
    pub margin_requirements: HashMap<String, Decimal>, // ä¿è¯é‡‘è¦æ±‚
    pub max_leverage: Option<Decimal>,               // æœ€å¤§æ æ†
}

#[derive(Debug, Clone)]
pub struct ExecutionConfig {
    pub partial_fill_probability: f64,   // éƒ¨åˆ†æˆäº¤æ¦‚ç‡
    pub slippage_range: (f64, f64),      // æ»‘ç‚¹èŒƒå›´
    pub execution_delay: Duration,       // æ‰§è¡Œå»¶è¿Ÿ
    pub enable_realistic_execution: bool, // å¯ç”¨çœŸå®æ‰§è¡Œæ¨¡æ‹Ÿ
}

#[async_trait]
impl ExchangeConnector for MockConnector {
    // ğŸ”¥ åŸºæœ¬ä¿¡æ¯
    fn get_exchange_type(&self) -> ExchangeType {
        self.exchange_type
    }
    
    fn get_market_type(&self) -> MarketType {
        self.market_type
    }
    
    fn get_supported_symbols(&self) -> Vec<String> {
        self.config.supported_symbols.clone()
    }
    
    // ğŸ”¥ è¿æ¥ç®¡ç†
    async fn connect(&self) -> Result<(), ConnectorError> {
        // æ¨¡æ‹Ÿè¿æ¥å»¶è¿Ÿ
        self.latency_simulator.simulate_connection_latency().await;
        
        // æ¨¡æ‹Ÿè¿æ¥é”™è¯¯
        if self.error_simulator.should_simulate_connection_error().await {
            return Err(ConnectorError::ConnectionFailed("Mock connection error".to_string()));
        }
        
        // æ›´æ–°è¿æ¥çŠ¶æ€
        {
            let mut state = self.connection_state.write().await;
            *state = ConnectionState::Connected;
        }
        
        // å¯åŠ¨å¸‚åœºæ•°æ®æ¨¡æ‹Ÿ
        self.market_simulator.start().await;
        
        // å¯åŠ¨è´¦æˆ·æ•°æ®æ¨¡æ‹Ÿ
        self.account_simulator.start().await;
        
        log::info!("MockConnector connected: {:?} {:?}", self.exchange_type, self.market_type);
        Ok(())
    }
    
    async fn disconnect(&self) -> Result<(), ConnectorError> {
        // åœæ­¢æ¨¡æ‹Ÿå™¨
        self.market_simulator.stop().await;
        self.account_simulator.stop().await;
        
        // æ›´æ–°è¿æ¥çŠ¶æ€
        {
            let mut state = self.connection_state.write().await;
            *state = ConnectionState::Disconnected;
        }
        
        log::info!("MockConnector disconnected: {:?} {:?}", self.exchange_type, self.market_type);
        Ok(())
    }
    
    async fn get_connection_state(&self) -> ConnectionState {
        self.connection_state.read().await.clone()
    }
    
    // ğŸ”¥ æ¨é€å¼æ•°æ®æµï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
    async fn get_market_data_stream(&self) -> Result<mpsc::UnboundedReceiver<HighFrequencyData>, ConnectorError> {
        let (sender, receiver) = mpsc::unbounded_channel();
        
        // ä¿å­˜å‘é€å™¨
        {
            let mut market_sender = self.market_data_sender.lock().await;
            *market_sender = Some(sender.clone());
        }
        
        // å¯åŠ¨å¸‚åœºæ•°æ®æ¨é€
        self.start_market_data_push(sender).await;
        
        Ok(receiver)
    }
    
    async fn get_user_data_stream(&self) -> Result<mpsc::UnboundedReceiver<UserDataEvent>, ConnectorError> {
        let (sender, receiver) = mpsc::unbounded_channel();
        
        // ä¿å­˜å‘é€å™¨
        {
            let mut user_sender = self.user_data_sender.lock().await;
            *user_sender = Some(sender.clone());
        }
        
        // å¯åŠ¨ç”¨æˆ·æ•°æ®æ¨é€
        self.start_user_data_push(sender).await;
        
        Ok(receiver)
    }
    
    // ğŸ”¥ æœ¬åœ°ç¼“å­˜å¿«ç…§è¯»å–
    async fn get_order_book_snapshot(&self, symbol: &str) -> Result<OrderBook, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        let order_books = self.order_book_cache.read().await;
        order_books.get(symbol)
            .cloned()
            .ok_or_else(|| ConnectorError::SymbolNotFound(symbol.to_string()))
    }
    
    async fn get_recent_trades(&self, symbol: &str, limit: Option<u32>) -> Result<Vec<Trade>, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        let trades = self.trade_cache.read().await;
        if let Some(symbol_trades) = trades.get(symbol) {
            let limit = limit.unwrap_or(100) as usize;
            Ok(symbol_trades.iter().rev().take(limit).cloned().collect())
        } else {
            Err(ConnectorError::SymbolNotFound(symbol.to_string()))
        }
    }
    
    async fn get_account_balance(&self) -> Result<HashMap<String, Balance>, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        self.account_simulator.get_balances().await
    }
    
    async fn get_positions(&self) -> Result<HashMap<String, Position>, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        self.position_tracker.get_positions().await
    }
    
    // ğŸ”¥ è®¢å•æ“ä½œï¼ˆæ ¸å¿ƒäº¤æ˜“åŠŸèƒ½ï¼‰
    async fn place_order(&self, order: OrderRequest) -> Result<OrderResponse, ConnectorError> {
        // æ¨¡æ‹Ÿæ‰§è¡Œå»¶è¿Ÿ
        self.latency_simulator.simulate_execution_latency().await;
        
        // æ¨¡æ‹Ÿè®¢å•é”™è¯¯
        if self.error_simulator.should_simulate_order_error().await {
            return Err(ConnectorError::OrderRejected("Mock order rejection".to_string()));
        }
        
        // æ‰§è¡Œè®¢å•
        let response = self.order_manager.place_order(order).await?;
        
        // å‘é€ç”¨æˆ·æ•°æ®æ›´æ–°
        self.send_order_update(&response).await;
        
        Ok(response)
    }
    
    async fn cancel_order(&self, order_id: &str) -> Result<OrderResponse, ConnectorError> {
        // æ¨¡æ‹Ÿæ‰§è¡Œå»¶è¿Ÿ
        self.latency_simulator.simulate_execution_latency().await;
        
        // æ‰§è¡Œå–æ¶ˆ
        let response = self.order_manager.cancel_order(order_id).await?;
        
        // å‘é€ç”¨æˆ·æ•°æ®æ›´æ–°
        self.send_order_update(&response).await;
        
        Ok(response)
    }
    
    async fn get_order_status(&self, order_id: &str) -> Result<OrderStatus, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        self.order_manager.get_order_status(order_id).await
    }
    
    async fn get_open_orders(&self, symbol: Option<&str>) -> Result<Vec<Order>, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        self.order_manager.get_open_orders(symbol).await
    }
    
    async fn get_order_history(&self, symbol: Option<&str>, limit: Option<u32>) -> Result<Vec<Order>, ConnectorError> {
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        self.latency_simulator.simulate_api_latency().await;
        
        self.order_manager.get_order_history(symbol, limit).await
    }
}

impl MockConnector {
    // ğŸ”¥ æ„é€ å‡½æ•°
    pub fn new(config: MockConnectorConfig) -> Self {
        let market_simulator = Arc::new(MarketSimulator::new(config.market_data_config.clone()));
        let account_simulator = Arc::new(AccountSimulator::new(config.account_config.clone()));
        let order_manager = Arc::new(MockOrderManager::new(config.execution_config.clone()));
        let position_tracker = Arc::new(MockPositionTracker::new());
        let latency_simulator = Arc::new(LatencySimulator::new(config.latency_config.clone()));
        let error_simulator = Arc::new(ErrorSimulator::new(config.error_config.clone()));
        
        Self {
            exchange_type: config.exchange_type,
            market_type: config.market_type,
            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),
            market_simulator,
            order_book_cache: Arc::new(RwLock::new(HashMap::new())),
            trade_cache: Arc::new(RwLock::new(HashMap::new())),
            account_simulator,
            order_manager,
            position_tracker,
            market_data_sender: Arc::new(Mutex::new(None)),
            user_data_sender: Arc::new(Mutex::new(None)),
            system_event_sender: Arc::new(Mutex::new(None)),
            config,
            latency_simulator,
            error_simulator,
        }
    }
    
    // ğŸ”¥ å¯åŠ¨å¸‚åœºæ•°æ®æ¨é€
    async fn start_market_data_push(&self, sender: mpsc::UnboundedSender<HighFrequencyData>) {
        let market_simulator = self.market_simulator.clone();
        let order_book_cache = self.order_book_cache.clone();
        let trade_cache = self.trade_cache.clone();
        let symbols = self.config.supported_symbols.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_millis(100));
            
            loop {
                interval.tick().await;
                
                for symbol in &symbols {
                    // ç”Ÿæˆè®¢å•ç°¿æ›´æ–°
                    if let Ok(order_book) = market_simulator.generate_order_book(symbol).await {
                        // æ›´æ–°ç¼“å­˜
                        {
                            let mut cache = order_book_cache.write().await;
                            cache.insert(symbol.clone(), order_book.clone());
                        }
                        
                        // å‘é€æ•°æ®
                        let data = HighFrequencyData::OrderBook {
                            symbol: symbol.clone(),
                            order_book,
                            timestamp: Utc::now(),
                        };
                        
                        if sender.send(data).is_err() {
                            break;
                        }
                    }
                    
                    // ç”Ÿæˆäº¤æ˜“æ•°æ®
                    if let Ok(trades) = market_simulator.generate_trades(symbol, 5).await {
                        // æ›´æ–°ç¼“å­˜
                        {
                            let mut cache = trade_cache.write().await;
                            cache.entry(symbol.clone()).or_insert_with(Vec::new).extend(trades.clone());
                            
                            // ä¿æŒç¼“å­˜å¤§å°
                            let symbol_trades = cache.get_mut(symbol).unwrap();
                            if symbol_trades.len() > 1000 {
                                symbol_trades.drain(0..symbol_trades.len() - 1000);
                            }
                        }
                        
                        // å‘é€æ•°æ®
                        for trade in trades {
                            let data = HighFrequencyData::Trade {
                                symbol: symbol.clone(),
                                trade,
                                timestamp: Utc::now(),
                            };
                            
                            if sender.send(data).is_err() {
                                return;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // ğŸ”¥ å¯åŠ¨ç”¨æˆ·æ•°æ®æ¨é€
    async fn start_user_data_push(&self, sender: mpsc::UnboundedSender<UserDataEvent>) {
        let order_manager = self.order_manager.clone();
        let account_simulator = self.account_simulator.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(1));
            
            loop {
                interval.tick().await;
                
                // å‘é€è´¦æˆ·ä½™é¢æ›´æ–°
                if let Ok(balances) = account_simulator.get_balances().await {
                    let event = UserDataEvent::BalanceUpdate { balances };
                    if sender.send(event).is_err() {
                        break;
                    }
                }
                
                // å‘é€è®¢å•çŠ¶æ€æ›´æ–°
                if let Ok(order_updates) = order_manager.get_pending_updates().await {
                    for update in order_updates {
                        let event = UserDataEvent::OrderUpdate { order: update };
                        if sender.send(event).is_err() {
                            return;
                        }
                    }
                }
            }
        });
    }
    
    // ğŸ”¥ å‘é€è®¢å•æ›´æ–°
    async fn send_order_update(&self, response: &OrderResponse) {
        if let Some(sender) = self.user_data_sender.lock().await.as_ref() {
            let event = UserDataEvent::OrderUpdate {
                order: Order {
                    id: response.order_id.clone(),
                    client_order_id: response.client_order_id.clone(),
                    symbol: response.symbol.clone(),
                    side: response.side,
                    order_type: response.order_type,
                    quantity: response.quantity,
                    price: response.price,
                    status: response.status,
                    filled_quantity: response.filled_quantity,
                    average_price: response.average_price,
                    created_at: response.created_at,
                    updated_at: response.updated_at,
                    fees: response.fees.clone(),
                },
            };
            
            let _ = sender.send(event);
        }
    }
    
    // ğŸ”¥ æµ‹è¯•è¾…åŠ©æ–¹æ³•
    pub async fn set_market_price(&self, symbol: &str, price: Decimal) {
        self.market_simulator.set_price(symbol, price).await;
    }
    
    pub async fn trigger_connection_error(&self) {
        self.error_simulator.trigger_connection_error().await;
    }
    
    pub async fn set_latency(&self, latency: Duration) {
        self.latency_simulator.set_base_latency(latency).await;
    }
    
    pub async fn get_order_book_cache(&self) -> HashMap<String, OrderBook> {
        self.order_book_cache.read().await.clone()
    }
    
    pub async fn get_trade_cache(&self) -> HashMap<String, Vec<Trade>> {
        self.trade_cache.read().await.clone()
    }
}
```

### 2.2 å¸‚åœºæ•°æ®æ¨¡æ‹Ÿå™¨

```rust
// src/testing/market_simulator.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use rand::Rng;
use crate::types::*;
use crate::testing::mock_connector::MarketDataConfig;

// ğŸ”¥ å¸‚åœºæ•°æ®æ¨¡æ‹Ÿå™¨
pub struct MarketSimulator {
    config: MarketDataConfig,
    
    // ä»·æ ¼çŠ¶æ€
    current_prices: Arc<RwLock<HashMap<String, Decimal>>>,
    price_trends: Arc<RwLock<HashMap<String, PriceTrend>>>,
    
    // è®¢å•ç°¿çŠ¶æ€
    order_book_depths: Arc<RwLock<HashMap<String, u32>>>,
    
    // éšæœºæ•°ç”Ÿæˆå™¨
    rng: Arc<RwLock<rand::rngs::ThreadRng>>,
    
    // è¿è¡ŒçŠ¶æ€
    is_running: Arc<RwLock<bool>>,
}

#[derive(Debug, Clone)]
pub struct PriceTrend {
    pub direction: TrendDirection,
    pub strength: f64,        // 0.0 - 1.0
    pub duration: Duration,   // è¶‹åŠ¿æŒç»­æ—¶é—´
    pub started_at: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum TrendDirection {
    Up,
    Down,
    Sideways,
}

impl MarketSimulator {
    pub fn new(config: MarketDataConfig) -> Self {
        Self {
            config,
            current_prices: Arc::new(RwLock::new(HashMap::new())),
            price_trends: Arc::new(RwLock::new(HashMap::new())),
            order_book_depths: Arc::new(RwLock::new(HashMap::new())),
            rng: Arc::new(RwLock::new(rand::thread_rng())),
            is_running: Arc::new(RwLock::new(false)),
        }
    }
    
    // ğŸ”¥ å¯åŠ¨æ¨¡æ‹Ÿå™¨
    pub async fn start(&self) {
        {
            let mut running = self.is_running.write().await;
            *running = true;
        }
        
        // åˆå§‹åŒ–ä»·æ ¼
        self.initialize_prices().await;
        
        // å¯åŠ¨ä»·æ ¼æ›´æ–°ä»»åŠ¡
        self.start_price_update_task().await;
    }
    
    // ğŸ”¥ åœæ­¢æ¨¡æ‹Ÿå™¨
    pub async fn stop(&self) {
        let mut running = self.is_running.write().await;
        *running = false;
    }
    
    // ğŸ”¥ ç”Ÿæˆè®¢å•ç°¿
    pub async fn generate_order_book(&self, symbol: &str) -> Result<OrderBook, SimulatorError> {
        let current_price = self.get_current_price(symbol).await
            .ok_or_else(|| SimulatorError::SymbolNotFound(symbol.to_string()))?;
        
        let depth = {
            let depths = self.order_book_depths.read().await;
            depths.get(symbol).copied().unwrap_or(20)
        };
        
        let mut rng = self.rng.write().await;
        let spread = self.generate_spread(&mut *rng);
        
        let mut bids = Vec::new();
        let mut asks = Vec::new();
        
        // ç”Ÿæˆä¹°å•
        let bid_start = current_price - spread / Decimal::from(2);
        for i in 0..depth {
            let price = bid_start - Decimal::from(i) * current_price * Decimal::from(0.0001);
            let quantity = self.generate_quantity(&mut *rng);
            bids.push(PriceLevel { price, quantity });
        }
        
        // ç”Ÿæˆå–å•
        let ask_start = current_price + spread / Decimal::from(2);
        for i in 0..depth {
            let price = ask_start + Decimal::from(i) * current_price * Decimal::from(0.0001);
            let quantity = self.generate_quantity(&mut *rng);
            asks.push(PriceLevel { price, quantity });
        }
        
        Ok(OrderBook {
            symbol: symbol.to_string(),
            bids,
            asks,
            timestamp: Utc::now(),
        })
    }
    
    // ğŸ”¥ ç”Ÿæˆäº¤æ˜“æ•°æ®
    pub async fn generate_trades(&self, symbol: &str, count: u32) -> Result<Vec<Trade>, SimulatorError> {
        let current_price = self.get_current_price(symbol).await
            .ok_or_else(|| SimulatorError::SymbolNotFound(symbol.to_string()))?;
        
        let mut trades = Vec::new();
        let mut rng = self.rng.write().await;
        
        for i in 0..count {
            let price_variance = current_price * Decimal::from(0.001); // 0.1% variance
            let price_offset = Decimal::from(rng.gen_range(-1.0..1.0)) * price_variance;
            let trade_price = current_price + price_offset;
            
            let quantity = self.generate_quantity(&mut *rng);
            let side = if rng.gen_bool(0.5) { TradeSide::Buy } else { TradeSide::Sell };
            
            trades.push(Trade {
                id: format!("trade_{}_{}", symbol, i),
                symbol: symbol.to_string(),
                price: trade_price,
                quantity,
                side,
                timestamp: Utc::now() - Duration::milliseconds(rng.gen_range(0..1000)),
            });
        }
        
        // æŒ‰æ—¶é—´æ’åº
        trades.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
        
        Ok(trades)
    }
    
    // ğŸ”¥ è®¾ç½®ä»·æ ¼ï¼ˆæµ‹è¯•ç”¨ï¼‰
    pub async fn set_price(&self, symbol: &str, price: Decimal) {
        let mut prices = self.current_prices.write().await;
        prices.insert(symbol.to_string(), price);
    }
    
    // ğŸ”¥ è·å–å½“å‰ä»·æ ¼
    pub async fn get_current_price(&self, symbol: &str) -> Option<Decimal> {
        let prices = self.current_prices.read().await;
        prices.get(symbol).copied()
    }
    
    // ç§æœ‰æ–¹æ³•å®ç°...
    async fn initialize_prices(&self) {
        let mut prices = self.current_prices.write().await;
        let mut trends = self.price_trends.write().await;
        
        // åˆå§‹åŒ–å¸¸è§äº¤æ˜“å¯¹ä»·æ ¼
        let initial_prices = vec![
            ("BTC/USDT".to_string(), Decimal::from(50000)),
            ("ETH/USDT".to_string(), Decimal::from(3000)),
            ("BNB/USDT".to_string(), Decimal::from(300)),
            ("ADA/USDT".to_string(), Decimal::from_str("0.5").unwrap()),
            ("DOT/USDT".to_string(), Decimal::from(10)),
        ];
        
        for (symbol, price) in initial_prices {
            prices.insert(symbol.clone(), price);
            trends.insert(symbol, PriceTrend {
                direction: TrendDirection::Sideways,
                strength: 0.5,
                duration: Duration::hours(1),
                started_at: Utc::now(),
            });
        }
    }
    
    async fn start_price_update_task(&self) {
        let current_prices = self.current_prices.clone();
        let price_trends = self.price_trends.clone();
        let is_running = self.is_running.clone();
        let config = self.config.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(config.tick_interval);
            
            loop {
                interval.tick().await;
                
                if !*is_running.read().await {
                    break;
                }
                
                // æ›´æ–°æ‰€æœ‰ä»·æ ¼
                Self::update_all_prices(&current_prices, &price_trends, &config).await;
            }
        });
    }
    
    async fn update_all_prices(
        current_prices: &Arc<RwLock<HashMap<String, Decimal>>>,
        price_trends: &Arc<RwLock<HashMap<String, PriceTrend>>>,
        config: &MarketDataConfig
    ) {
        let mut prices = current_prices.write().await;
        let mut trends = price_trends.write().await;
        let mut rng = rand::thread_rng();
        
        for (symbol, price) in prices.iter_mut() {
            if let Some(trend) = trends.get_mut(symbol) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°è¶‹åŠ¿
                if Utc::now() - trend.started_at > trend.duration {
                    *trend = Self::generate_new_trend(&mut rng);
                }
                
                // æ ¹æ®è¶‹åŠ¿æ›´æ–°ä»·æ ¼
                let price_change = Self::calculate_price_change(price, trend, config, &mut rng);
                *price += price_change;
                
                // ç¡®ä¿ä»·æ ¼ä¸ºæ­£
                if *price <= Decimal::ZERO {
                    *price = Decimal::from_str("0.0001").unwrap();
                }
            }
        }
    }
    
    fn generate_new_trend(rng: &mut rand::rngs::ThreadRng) -> PriceTrend {
        let directions = [TrendDirection::Up, TrendDirection::Down, TrendDirection::Sideways];
        let direction = directions[rng.gen_range(0..3)].clone();
        
        PriceTrend {
            direction,
            strength: rng.gen_range(0.1..1.0),
            duration: Duration::minutes(rng.gen_range(5..60)),
            started_at: Utc::now(),
        }
    }
    
    fn calculate_price_change(
        current_price: &Decimal,
        trend: &PriceTrend,
        config: &MarketDataConfig,
        rng: &mut rand::rngs::ThreadRng
    ) -> Decimal {
        let base_volatility = config.price_volatility;
        let trend_factor = match trend.direction {
            TrendDirection::Up => trend.strength,
            TrendDirection::Down => -trend.strength,
            TrendDirection::Sideways => 0.0,
        };
        
        let random_factor = rng.gen_range(-1.0..1.0);
        let total_change = (trend_factor * 0.7 + random_factor * 0.3) * base_volatility;
        
        *current_price * Decimal::from(total_change)
    }
    
    fn generate_spread(&self, rng: &mut rand::rngs::ThreadRng) -> Decimal {
        let (min_spread, max_spread) = self.config.spread_range;
        let spread_factor = rng.gen_range(0.0..1.0);
        min_spread + (max_spread - min_spread) * Decimal::from(spread_factor)
    }
    
    fn generate_quantity(&self, rng: &mut rand::rngs::ThreadRng) -> Decimal {
        let (min_volume, max_volume) = self.config.volume_range;
        let volume_factor = rng.gen_range(0.0..1.0);
        min_volume + (max_volume - min_volume) * Decimal::from(volume_factor)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum SimulatorError {
    #[error("Symbol not found: {0}")]
    SymbolNotFound(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    #[error("Simulation error: {0}")]
    SimulationError(String),
}
```

### 2.3 å»¶è¿Ÿå’Œé”™è¯¯æ¨¡æ‹Ÿå™¨

```rust
// src/testing/simulators.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use rand::Rng;
use crate::testing::mock_connector::{LatencyConfig, ErrorConfig};

// ğŸ”¥ å»¶è¿Ÿæ¨¡æ‹Ÿå™¨
pub struct LatencySimulator {
    config: Arc<RwLock<LatencyConfig>>,
    rng: Arc<RwLock<rand::rngs::ThreadRng>>,
}

impl LatencySimulator {
    pub fn new(config: LatencyConfig) -> Self {
        Self {
            config: Arc::new(RwLock::new(config)),
            rng: Arc::new(RwLock::new(rand::thread_rng())),
        }
    }
    
    // ğŸ”¥ æ¨¡æ‹Ÿè¿æ¥å»¶è¿Ÿ
    pub async fn simulate_connection_latency(&self) {
        let config = self.config.read().await;
        if config.enable_realistic_latency {
            let latency = self.calculate_latency(&config).await;
            tokio::time::sleep(latency).await;
        }
    }
    
    // ğŸ”¥ æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    pub async fn simulate_api_latency(&self) {
        let config = self.config.read().await;
        if config.enable_realistic_latency {
            let latency = self.calculate_latency(&config).await;
            tokio::time::sleep(latency).await;
        }
    }
    
    // ğŸ”¥ æ¨¡æ‹Ÿè®¢å•æ‰§è¡Œå»¶è¿Ÿ
    pub async fn simulate_execution_latency(&self) {
        let config = self.config.read().await;
        if config.enable_realistic_latency {
            let latency = self.calculate_latency(&config).await;
            tokio::time::sleep(latency).await;
        }
    }
    
    // ğŸ”¥ è®¾ç½®åŸºç¡€å»¶è¿Ÿï¼ˆæµ‹è¯•ç”¨ï¼‰
    pub async fn set_base_latency(&self, latency: Duration) {
        let mut config = self.config.write().await;
        config.base_latency = latency;
    }
    
    // ç§æœ‰æ–¹æ³•ï¼šè®¡ç®—å»¶è¿Ÿ
    async fn calculate_latency(&self, config: &LatencyConfig) -> Duration {
        let mut rng = self.rng.write().await;
        
        // åŸºç¡€å»¶è¿Ÿ + éšæœºæ–¹å·® + ç½‘ç»œæŠ–åŠ¨
        let variance = Duration::from_nanos(rng.gen_range(0..config.latency_variance.as_nanos() as u64));
        let jitter = Duration::from_nanos(rng.gen_range(0..config.network_jitter.as_nanos() as u64));
        
        config.base_latency + variance + jitter
    }
}

// ğŸ”¥ é”™è¯¯æ¨¡æ‹Ÿå™¨
pub struct ErrorSimulator {
    config: Arc<RwLock<ErrorConfig>>,
    rng: Arc<RwLock<rand::rngs::ThreadRng>>,
    
    // é”™è¯¯çŠ¶æ€
    connection_error_triggered: Arc<RwLock<bool>>,
}

impl ErrorSimulator {
    pub fn new(config: ErrorConfig) -> Self {
        Self {
            config: Arc::new(RwLock::new(config)),
            rng: Arc::new(RwLock::new(rand::thread_rng())),
            connection_error_triggered: Arc::new(RwLock::new(false)),
        }
    }
    
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¨¡æ‹Ÿè¿æ¥é”™è¯¯
    pub async fn should_simulate_connection_error(&self) -> bool {
        // æ£€æŸ¥æ‰‹åŠ¨è§¦å‘çš„é”™è¯¯
        {
            let mut triggered = self.connection_error_triggered.write().await;
            if *triggered {
                *triggered = false;
                return true;
            }
        }
        
        // æ£€æŸ¥éšæœºé”™è¯¯
        let config = self.config.read().await;
        if config.enable_random_errors {
            let mut rng = self.rng.write().await;
            rng.gen_bool(config.connection_error_rate)
        } else {
            false
        }
    }
    
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¨¡æ‹Ÿè®¢å•é”™è¯¯
    pub async fn should_simulate_order_error(&self) -> bool {
        let config = self.config.read().await;
        if config.enable_random_errors {
            let mut rng = self.rng.write().await;
            rng.gen_bool(config.order_error_rate)
        } else {
            false
        }
    }
    
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¨¡æ‹Ÿå¸‚åœºæ•°æ®é”™è¯¯
    pub async fn should_simulate_market_data_error(&self) -> bool {
        let config = self.config.read().await;
        if config.enable_random_errors {
            let mut rng = self.rng.write().await;
            rng.gen_bool(config.market_data_error_rate)
        } else {
            false
        }
    }
    
    // ğŸ”¥ æ‰‹åŠ¨è§¦å‘è¿æ¥é”™è¯¯ï¼ˆæµ‹è¯•ç”¨ï¼‰
    pub async fn trigger_connection_error(&self) {
        let mut triggered = self.connection_error_triggered.write().await;
        *triggered = true;
    }
}
```

## 3. å•å…ƒæµ‹è¯•æ¡†æ¶

### 3.1 è¿æ¥å™¨æµ‹è¯•

```rust
// tests/unit/connectors/test_mock_connector.rs
use tokio_test;
use std::time::Duration;
use crossfury::testing::mock_connector::*;
use crossfury::connectors::traits::*;
use crossfury::types::*;

#[tokio::test]
async fn test_mock_connector_connection() {
    // ğŸ”¥ æµ‹è¯•è¿æ¥å™¨è¿æ¥åŠŸèƒ½
    let config = MockConnectorConfig {
        exchange_type: ExchangeType::Binance,
        market_type: MarketType::Spot,
        supported_symbols: vec!["BTC/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(10),
            latency_variance: Duration::from_millis(5),
            network_jitter: Duration::from_millis(2),
            enable_realistic_latency: true,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig::default(),
        account_config: AccountConfig::default(),
        execution_config: ExecutionConfig::default(),
    };
    
    let connector = MockConnector::new(config);
    
    // æµ‹è¯•åˆå§‹çŠ¶æ€
    assert_eq!(connector.get_connection_state().await, ConnectionState::Disconnected);
    
    // æµ‹è¯•è¿æ¥
    let result = connector.connect().await;
    assert!(result.is_ok());
    assert_eq!(connector.get_connection_state().await, ConnectionState::Connected);
    
    // æµ‹è¯•æ–­å¼€è¿æ¥
    let result = connector.disconnect().await;
    assert!(result.is_ok());
    assert_eq!(connector.get_connection_state().await, ConnectionState::Disconnected);
}

#[tokio::test]
async fn test_mock_connector_market_data_stream() {
    // ğŸ”¥ æµ‹è¯•å¸‚åœºæ•°æ®æµ
    let config = create_test_config();
    let connector = MockConnector::new(config);
    
    // è¿æ¥
    connector.connect().await.unwrap();
    
    // è·å–å¸‚åœºæ•°æ®æµ
    let mut receiver = connector.get_market_data_stream().await.unwrap();
    
    // ç­‰å¾…æ•°æ®
    let timeout = tokio::time::timeout(Duration::from_secs(2), receiver.recv()).await;
    assert!(timeout.is_ok());
    
    let data = timeout.unwrap().unwrap();
    match data {
        HighFrequencyData::OrderBook { symbol, .. } => {
            assert_eq!(symbol, "BTC/USDT");
        }
        _ => panic!("Expected OrderBook data"),
    }
}

#[tokio::test]
async fn test_mock_connector_order_operations() {
    // ğŸ”¥ æµ‹è¯•è®¢å•æ“ä½œ
    let config = create_test_config();
    let connector = MockConnector::new(config);
    
    connector.connect().await.unwrap();
    
    // æµ‹è¯•ä¸‹å•
    let order_request = OrderRequest {
        client_order_id: "test_order_1".to_string(),
        symbol: "BTC/USDT".to_string(),
        side: OrderSide::Buy,
        order_type: OrderType::Limit,
        quantity: Decimal::from(1),
        price: Some(Decimal::from(50000)),
        time_in_force: Some(TimeInForce::GTC),
    };
    
    let response = connector.place_order(order_request).await.unwrap();
    assert!(!response.order_id.is_empty());
    assert_eq!(response.status, OrderStatus::New);
    
    // æµ‹è¯•æŸ¥è¯¢è®¢å•çŠ¶æ€
    let status = connector.get_order_status(&response.order_id).await.unwrap();
    assert!(matches!(status, OrderStatus::New | OrderStatus::PartiallyFilled | OrderStatus::Filled));
    
    // æµ‹è¯•å–æ¶ˆè®¢å•
    let cancel_response = connector.cancel_order(&response.order_id).await.unwrap();
    assert_eq!(cancel_response.status, OrderStatus::Cancelled);
}

#[tokio::test]
async fn test_mock_connector_error_simulation() {
    // ğŸ”¥ æµ‹è¯•é”™è¯¯æ¨¡æ‹Ÿ
    let mut config = create_test_config();
    config.error_config.enable_random_errors = true;
    config.error_config.connection_error_rate = 1.0; // 100% é”™è¯¯ç‡
    
    let connector = MockConnector::new(config);
    
    // æµ‹è¯•è¿æ¥é”™è¯¯
    let result = connector.connect().await;
    assert!(result.is_err());
}

#[tokio::test]
async fn test_mock_connector_latency_simulation() {
    // ğŸ”¥ æµ‹è¯•å»¶è¿Ÿæ¨¡æ‹Ÿ
    let mut config = create_test_config();
    config.latency_config.base_latency = Duration::from_millis(100);
    config.latency_config.enable_realistic_latency = true;
    
    let connector = MockConnector::new(config);
    connector.connect().await.unwrap();
    
    // æµ‹é‡APIè°ƒç”¨å»¶è¿Ÿ
    let start = std::time::Instant::now();
    let _ = connector.get_account_balance().await.unwrap();
    let elapsed = start.elapsed();
    
    // åº”è¯¥æœ‰æ˜æ˜¾çš„å»¶è¿Ÿ
    assert!(elapsed >= Duration::from_millis(90));
}

// è¾…åŠ©å‡½æ•°
fn create_test_config() -> MockConnectorConfig {
    MockConnectorConfig {
        exchange_type: ExchangeType::Binance,
        market_type: MarketType::Spot,
        supported_symbols: vec!["BTC/USDT".to_string(), "ETH/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(10),
            latency_variance: Duration::from_millis(5),
            network_jitter: Duration::from_millis(2),
            enable_realistic_latency: false,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig {
            tick_interval: Duration::from_millis(100),
            price_volatility: 0.001,
            volume_range: (Decimal::from(1), Decimal::from(1000)),
            spread_range: (Decimal::from_str("0.0001").unwrap(), Decimal::from_str("0.001").unwrap()),
            enable_realistic_movement: true,
        },
        account_config: AccountConfig {
            initial_balances: {
                let mut balances = HashMap::new();
                balances.insert("USDT".to_string(), Decimal::from(100000));
                balances.insert("BTC".to_string(), Decimal::from(1));
                balances
            },
            trading_fees: {
                let mut fees = HashMap::new();
                fees.insert("default".to_string(), Decimal::from_str("0.001").unwrap());
                fees
            },
            margin_requirements: HashMap::new(),
            max_leverage: Some(Decimal::from(10)),
        },
        execution_config: ExecutionConfig {
            partial_fill_probability: 0.1,
            slippage_range: (0.0, 0.001),
            execution_delay: Duration::from_millis(50),
            enable_realistic_execution: true,
        },
     }
 }
```

## 5. æ€§èƒ½æµ‹è¯•æ¡†æ¶

### 5.1 å‹åŠ›æµ‹è¯•

```rust
// tests/performance/test_high_frequency_trading.rs
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use tokio::runtime::Runtime;
use std::time::Duration;
use crossfury::testing::mock_connector::*;
use crossfury::testing::performance_tester::*;

// ğŸ”¥ é«˜é¢‘äº¤æ˜“æ€§èƒ½æµ‹è¯•
fn benchmark_order_execution(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    let mut group = c.benchmark_group("order_execution");
    
    for order_count in [100, 500, 1000, 5000].iter() {
        group.bench_with_input(
            BenchmarkId::new("concurrent_orders", order_count),
            order_count,
            |b, &order_count| {
                b.to_async(&rt).iter(|| async {
                    let performance_tester = PerformanceTester::new().await;
                    performance_tester.test_concurrent_orders(order_count).await
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_market_data_processing(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    let mut group = c.benchmark_group("market_data_processing");
    
    for data_rate in [1000, 5000, 10000, 50000].iter() {
        group.bench_with_input(
            BenchmarkId::new("messages_per_second", data_rate),
            data_rate,
            |b, &data_rate| {
                b.to_async(&rt).iter(|| async {
                    let performance_tester = PerformanceTester::new().await;
                    performance_tester.test_market_data_throughput(data_rate).await
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_arbitrage_detection(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();
    
    c.bench_function("arbitrage_detection", |b| {
        b.to_async(&rt).iter(|| async {
            let performance_tester = PerformanceTester::new().await;
            performance_tester.test_arbitrage_detection_speed().await
        });
    });
}

criterion_group!(
    benches,
    benchmark_order_execution,
    benchmark_market_data_processing,
    benchmark_arbitrage_detection
);
criterion_main!(benches);
```

### 5.2 æ€§èƒ½æµ‹è¯•å·¥å…·

```rust
// src/testing/performance_tester.rs
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{RwLock, Semaphore};
use futures::future::join_all;
use crate::testing::mock_connector::*;
use crate::execution::order_executor::*;
use crate::arbitrage::arbitrage_engine::*;

// ğŸ”¥ æ€§èƒ½æµ‹è¯•å™¨
pub struct PerformanceTester {
    mock_connector: Arc<MockConnector>,
    order_executor: Arc<OrderExecutorImpl>,
    arbitrage_engine: Arc<ArbitrageEngine>,
    metrics_collector: Arc<PerformanceMetricsCollector>,
}

#[derive(Debug, Clone)]
pub struct PerformanceMetrics {
    pub total_orders: u64,
    pub successful_orders: u64,
    pub failed_orders: u64,
    pub average_latency: Duration,
    pub p95_latency: Duration,
    pub p99_latency: Duration,
    pub throughput: f64, // orders per second
    pub memory_usage: u64, // bytes
    pub cpu_usage: f64, // percentage
}

#[derive(Debug)]
pub struct PerformanceMetricsCollector {
    latencies: Arc<RwLock<Vec<Duration>>>,
    start_time: Arc<RwLock<Option<Instant>>>,
    order_count: Arc<RwLock<u64>>,
    success_count: Arc<RwLock<u64>>,
    error_count: Arc<RwLock<u64>>,
}

impl PerformanceTester {
    pub async fn new() -> Self {
        let config = create_performance_test_config();
        let mock_connector = Arc::new(MockConnector::new(config));
        
        mock_connector.connect().await.unwrap();
        
        let order_executor = Arc::new(OrderExecutorImpl::new(
            mock_connector.clone(),
            create_test_risk_manager(),
        ));
        
        let arbitrage_engine = Arc::new(ArbitrageEngine::new());
        arbitrage_engine.add_connector("test", mock_connector.clone()).await;
        
        Self {
            mock_connector,
            order_executor,
            arbitrage_engine,
            metrics_collector: Arc::new(PerformanceMetricsCollector::new()),
        }
    }
    
    // ğŸ”¥ æµ‹è¯•å¹¶å‘è®¢å•æ‰§è¡Œ
    pub async fn test_concurrent_orders(&self, order_count: u32) -> PerformanceMetrics {
        self.metrics_collector.start_test().await;
        
        // åˆ›å»ºä¿¡å·é‡é™åˆ¶å¹¶å‘æ•°
        let semaphore = Arc::new(Semaphore::new(100));
        
        // ç”Ÿæˆè®¢å•ä»»åŠ¡
        let mut tasks = Vec::new();
        for i in 0..order_count {
            let executor = self.order_executor.clone();
            let metrics = self.metrics_collector.clone();
            let sem = semaphore.clone();
            
            let task = tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                
                let order = OrderRequest {
                    client_order_id: format!("perf_test_{}", i),
                    symbol: "BTC/USDT".to_string(),
                    side: if i % 2 == 0 { OrderSide::Buy } else { OrderSide::Sell },
                    order_type: OrderType::Market,
                    quantity: Decimal::from_str("0.001").unwrap(),
                    price: None,
                    time_in_force: Some(TimeInForce::IOC),
                };
                
                let start = Instant::now();
                let result = executor.execute_order(order).await;
                let latency = start.elapsed();
                
                metrics.record_order_result(result.is_ok(), latency).await;
            });
            
            tasks.push(task);
        }
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        join_all(tasks).await;
        
        self.metrics_collector.calculate_metrics().await
    }
    
    // ğŸ”¥ æµ‹è¯•å¸‚åœºæ•°æ®ååé‡
    pub async fn test_market_data_throughput(&self, messages_per_second: u32) -> PerformanceMetrics {
        self.metrics_collector.start_test().await;
        
        let mut receiver = self.mock_connector.get_market_data_stream().await.unwrap();
        let test_duration = Duration::from_secs(10);
        let start_time = Instant::now();
        let mut message_count = 0u64;
        
        while start_time.elapsed() < test_duration {
            if let Ok(data) = tokio::time::timeout(Duration::from_millis(100), receiver.recv()).await {
                if data.is_some() {
                    message_count += 1;
                }
            }
        }
        
        let actual_throughput = message_count as f64 / test_duration.as_secs_f64();
        
        PerformanceMetrics {
            total_orders: message_count,
            successful_orders: message_count,
            failed_orders: 0,
            average_latency: Duration::from_millis(1),
            p95_latency: Duration::from_millis(2),
            p99_latency: Duration::from_millis(5),
            throughput: actual_throughput,
            memory_usage: self.get_memory_usage().await,
            cpu_usage: self.get_cpu_usage().await,
        }
    }
    
    // ğŸ”¥ æµ‹è¯•å¥—åˆ©æ£€æµ‹é€Ÿåº¦
    pub async fn test_arbitrage_detection_speed(&self) -> PerformanceMetrics {
        self.metrics_collector.start_test().await;
        
        let test_iterations = 1000;
        let mut total_latency = Duration::ZERO;
        
        for _ in 0..test_iterations {
            let start = Instant::now();
            let _ = self.arbitrage_engine.scan_opportunities("BTC/USDT").await;
            total_latency += start.elapsed();
        }
        
        let average_latency = total_latency / test_iterations;
        
        PerformanceMetrics {
            total_orders: test_iterations as u64,
            successful_orders: test_iterations as u64,
            failed_orders: 0,
            average_latency,
            p95_latency: average_latency * 2,
            p99_latency: average_latency * 3,
            throughput: test_iterations as f64 / total_latency.as_secs_f64(),
            memory_usage: self.get_memory_usage().await,
            cpu_usage: self.get_cpu_usage().await,
        }
    }
    
    // ğŸ”¥ å†…å­˜ä½¿ç”¨æƒ…å†µ
    async fn get_memory_usage(&self) -> u64 {
        // å®é™…å®ç°ä¸­å¯ä»¥ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
        // è¿™é‡Œè¿”å›æ¨¡æ‹Ÿå€¼
        1024 * 1024 * 100 // 100MB
    }
    
    // ğŸ”¥ CPUä½¿ç”¨æƒ…å†µ
    async fn get_cpu_usage(&self) -> f64 {
        // å®é™…å®ç°ä¸­å¯ä»¥ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨è·å–CPUä½¿ç”¨æƒ…å†µ
        // è¿™é‡Œè¿”å›æ¨¡æ‹Ÿå€¼
        25.5 // 25.5%
    }
}

impl PerformanceMetricsCollector {
    pub fn new() -> Self {
        Self {
            latencies: Arc::new(RwLock::new(Vec::new())),
            start_time: Arc::new(RwLock::new(None)),
            order_count: Arc::new(RwLock::new(0)),
            success_count: Arc::new(RwLock::new(0)),
            error_count: Arc::new(RwLock::new(0)),
        }
    }
    
    pub async fn start_test(&self) {
        let mut start_time = self.start_time.write().await;
        *start_time = Some(Instant::now());
        
        // é‡ç½®è®¡æ•°å™¨
        *self.order_count.write().await = 0;
        *self.success_count.write().await = 0;
        *self.error_count.write().await = 0;
        self.latencies.write().await.clear();
    }
    
    pub async fn record_order_result(&self, success: bool, latency: Duration) {
        {
            let mut order_count = self.order_count.write().await;
            *order_count += 1;
        }
        
        if success {
            let mut success_count = self.success_count.write().await;
            *success_count += 1;
        } else {
            let mut error_count = self.error_count.write().await;
            *error_count += 1;
        }
        
        {
            let mut latencies = self.latencies.write().await;
            latencies.push(latency);
        }
    }
    
    pub async fn calculate_metrics(&self) -> PerformanceMetrics {
        let start_time = self.start_time.read().await.unwrap();
        let total_duration = start_time.elapsed();
        
        let total_orders = *self.order_count.read().await;
        let successful_orders = *self.success_count.read().await;
        let failed_orders = *self.error_count.read().await;
        
        let mut latencies = self.latencies.read().await.clone();
        latencies.sort();
        
        let average_latency = if !latencies.is_empty() {
            latencies.iter().sum::<Duration>() / latencies.len() as u32
        } else {
            Duration::ZERO
        };
        
        let p95_latency = if !latencies.is_empty() {
            let index = (latencies.len() as f64 * 0.95) as usize;
            latencies.get(index).copied().unwrap_or(Duration::ZERO)
        } else {
            Duration::ZERO
        };
        
        let p99_latency = if !latencies.is_empty() {
            let index = (latencies.len() as f64 * 0.99) as usize;
            latencies.get(index).copied().unwrap_or(Duration::ZERO)
        } else {
            Duration::ZERO
        };
        
        let throughput = total_orders as f64 / total_duration.as_secs_f64();
        
        PerformanceMetrics {
            total_orders,
            successful_orders,
            failed_orders,
            average_latency,
            p95_latency,
            p99_latency,
            throughput,
            memory_usage: 0, // éœ€è¦å®é™…å®ç°
            cpu_usage: 0.0,  // éœ€è¦å®é™…å®ç°
        }
    }
}

// è¾…åŠ©å‡½æ•°
fn create_performance_test_config() -> MockConnectorConfig {
    MockConnectorConfig {
        exchange_type: ExchangeType::Binance,
        market_type: MarketType::Spot,
        supported_symbols: vec!["BTC/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(1), // æä½å»¶è¿Ÿç”¨äºæ€§èƒ½æµ‹è¯•
            latency_variance: Duration::from_millis(1),
            network_jitter: Duration::from_millis(0),
            enable_realistic_latency: false,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig {
            tick_interval: Duration::from_millis(1), // é«˜é¢‘æ•°æ®
            price_volatility: 0.0001,
            volume_range: (Decimal::from(1), Decimal::from(100)),
            spread_range: (Decimal::from_str("0.0001").unwrap(), Decimal::from_str("0.0002").unwrap()),
            enable_realistic_movement: false,
        },
        account_config: AccountConfig {
            initial_balances: {
                let mut balances = HashMap::new();
                balances.insert("USDT".to_string(), Decimal::from(1000000)); // å¤§é¢ä½™é¢
                balances.insert("BTC".to_string(), Decimal::from(100));
                balances
            },
            trading_fees: {
                let mut fees = HashMap::new();
                fees.insert("default".to_string(), Decimal::ZERO); // æ— æ‰‹ç»­è´¹
                fees
            },
            margin_requirements: HashMap::new(),
            max_leverage: Some(Decimal::from(100)),
        },
        execution_config: ExecutionConfig {
            partial_fill_probability: 0.0, // æ€»æ˜¯å®Œå…¨æˆäº¤
            slippage_range: (0.0, 0.0),    // æ— æ»‘ç‚¹
            execution_delay: Duration::from_millis(1), // æä½æ‰§è¡Œå»¶è¿Ÿ
            enable_realistic_execution: false,
        },
    }
}

fn create_test_risk_manager() -> Arc<dyn RiskManager> {
    // åˆ›å»ºä¸€ä¸ªå®½æ¾çš„é£é™©ç®¡ç†å™¨ç”¨äºæ€§èƒ½æµ‹è¯•
    Arc::new(MockRiskManager::new_permissive())
}
```

## 6. å›æµ‹æ¡†æ¶

### 6.1 å†å²æ•°æ®å›æµ‹

```rust
// src/testing/backtest_engine.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{DateTime, Utc, Duration};
use crate::types::*;
use crate::strategies::traits::Strategy;
use crate::testing::historical_data_provider::*;

// ğŸ”¥ å›æµ‹å¼•æ“
pub struct BacktestEngine {
    // å†å²æ•°æ®æä¾›è€…
    data_provider: Arc<HistoricalDataProvider>,
    
    // ç­–ç•¥å®ä¾‹
    strategies: Arc<RwLock<HashMap<String, Box<dyn Strategy + Send + Sync>>>>,
    
    // å›æµ‹é…ç½®
    config: BacktestConfig,
    
    // å›æµ‹çŠ¶æ€
    current_time: Arc<RwLock<DateTime<Utc>>>,
    portfolio: Arc<RwLock<Portfolio>>,
    trade_history: Arc<RwLock<Vec<BacktestTrade>>>,
    
    // æ€§èƒ½æŒ‡æ ‡
    metrics_calculator: Arc<BacktestMetricsCalculator>,
}

#[derive(Debug, Clone)]
pub struct BacktestConfig {
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub initial_capital: Decimal,
    pub symbols: Vec<String>,
    pub data_frequency: Duration, // æ•°æ®é¢‘ç‡ï¼ˆå¦‚1åˆ†é’Ÿã€5åˆ†é’Ÿç­‰ï¼‰
    pub commission_rate: Decimal,
    pub slippage_rate: Decimal,
    pub enable_realistic_execution: bool,
}

#[derive(Debug, Clone)]
pub struct Portfolio {
    pub cash: Decimal,
    pub positions: HashMap<String, Decimal>, // symbol -> quantity
    pub total_value: Decimal,
    pub unrealized_pnl: Decimal,
    pub realized_pnl: Decimal,
}

#[derive(Debug, Clone)]
pub struct BacktestTrade {
    pub timestamp: DateTime<Utc>,
    pub symbol: String,
    pub side: OrderSide,
    pub quantity: Decimal,
    pub price: Decimal,
    pub commission: Decimal,
    pub slippage: Decimal,
    pub strategy_name: String,
}

#[derive(Debug, Clone)]
pub struct BacktestResult {
    pub config: BacktestConfig,
    pub portfolio: Portfolio,
    pub trades: Vec<BacktestTrade>,
    pub metrics: BacktestMetrics,
    pub equity_curve: Vec<(DateTime<Utc>, Decimal)>,
    pub drawdown_curve: Vec<(DateTime<Utc>, Decimal)>,
}

#[derive(Debug, Clone)]
pub struct BacktestMetrics {
    pub total_return: Decimal,
    pub annualized_return: Decimal,
    pub volatility: Decimal,
    pub sharpe_ratio: Decimal,
    pub max_drawdown: Decimal,
    pub win_rate: Decimal,
    pub profit_factor: Decimal,
    pub total_trades: u64,
    pub winning_trades: u64,
    pub losing_trades: u64,
    pub average_win: Decimal,
    pub average_loss: Decimal,
    pub largest_win: Decimal,
    pub largest_loss: Decimal,
}

impl BacktestEngine {
    pub fn new(config: BacktestConfig, data_provider: Arc<HistoricalDataProvider>) -> Self {
        let initial_portfolio = Portfolio {
            cash: config.initial_capital,
            positions: HashMap::new(),
            total_value: config.initial_capital,
            unrealized_pnl: Decimal::ZERO,
            realized_pnl: Decimal::ZERO,
        };
        
        Self {
            data_provider,
            strategies: Arc::new(RwLock::new(HashMap::new())),
            config,
            current_time: Arc::new(RwLock::new(config.start_time)),
            portfolio: Arc::new(RwLock::new(initial_portfolio)),
            trade_history: Arc::new(RwLock::new(Vec::new())),
            metrics_calculator: Arc::new(BacktestMetricsCalculator::new()),
        }
    }
    
    // ğŸ”¥ æ·»åŠ ç­–ç•¥
    pub async fn add_strategy(&self, name: String, strategy: Box<dyn Strategy + Send + Sync>) {
        let mut strategies = self.strategies.write().await;
        strategies.insert(name, strategy);
    }
    
    // ğŸ”¥ è¿è¡Œå›æµ‹
    pub async fn run_backtest(&self) -> Result<BacktestResult, BacktestError> {
        log::info!("Starting backtest from {} to {}", self.config.start_time, self.config.end_time);
        
        // åˆå§‹åŒ–ç­–ç•¥
        self.initialize_strategies().await?;
        
        // è·å–å†å²æ•°æ®
        let historical_data = self.data_provider.get_data(
            &self.config.symbols,
            self.config.start_time,
            self.config.end_time,
            self.config.data_frequency,
        ).await?;
        
        let mut equity_curve = Vec::new();
        let mut drawdown_curve = Vec::new();
        let mut peak_value = self.config.initial_capital;
        
        // æŒ‰æ—¶é—´é¡ºåºå¤„ç†æ•°æ®
        for data_point in historical_data {
            // æ›´æ–°å½“å‰æ—¶é—´
            {
                let mut current_time = self.current_time.write().await;
                *current_time = data_point.timestamp;
            }
            
            // æ›´æ–°æŠ•èµ„ç»„åˆä»·å€¼
            self.update_portfolio_value(&data_point).await;
            
            // å¤„ç†å¸‚åœºæ•°æ®
            self.process_market_data(data_point).await?;
            
            // è®°å½•æƒç›Šæ›²çº¿
            let portfolio_value = self.portfolio.read().await.total_value;
            equity_curve.push((self.current_time.read().await.clone(), portfolio_value));
            
            // è®¡ç®—å›æ’¤
            if portfolio_value > peak_value {
                peak_value = portfolio_value;
            }
            let drawdown = (peak_value - portfolio_value) / peak_value;
            drawdown_curve.push((self.current_time.read().await.clone(), drawdown));
        }
        
        // è®¡ç®—æœ€ç»ˆæŒ‡æ ‡
        let final_portfolio = self.portfolio.read().await.clone();
        let trades = self.trade_history.read().await.clone();
        let metrics = self.metrics_calculator.calculate_metrics(
            &self.config,
            &final_portfolio,
            &trades,
            &equity_curve,
        ).await;
        
        log::info!("Backtest completed. Total return: {:.2}%", metrics.total_return * Decimal::from(100));
        
        Ok(BacktestResult {
            config: self.config.clone(),
            portfolio: final_portfolio,
            trades,
            metrics,
            equity_curve,
            drawdown_curve,
        })
    }
    
    // ç§æœ‰æ–¹æ³•å®ç°...
    async fn initialize_strategies(&self) -> Result<(), BacktestError> {
        let mut strategies = self.strategies.write().await;
        for (name, strategy) in strategies.iter_mut() {
            let config = StrategyConfig::default(); // å¯ä»¥ä»é…ç½®æ–‡ä»¶åŠ è½½
            strategy.initialize(config).await
                .map_err(|e| BacktestError::StrategyError(name.clone(), e))?;
            strategy.start().await
                .map_err(|e| BacktestError::StrategyError(name.clone(), e))?;
        }
        Ok(())
    }
    
    async fn process_market_data(&self, data: HistoricalDataPoint) -> Result<(), BacktestError> {
        let market_event = MarketDataEvent::OrderBookUpdate {
            symbol: data.symbol.clone(),
            order_book: data.order_book,
        };
        
        let mut strategies = self.strategies.write().await;
        for (name, strategy) in strategies.iter_mut() {
            let signals = strategy.on_market_data(market_event.clone()).await
                .map_err(|e| BacktestError::StrategyError(name.clone(), e))?;
            
            // å¤„ç†ç­–ç•¥ä¿¡å·
            for signal in signals {
                self.process_strategy_signal(name.clone(), signal).await?;
            }
        }
        
        Ok(())
    }
    
    async fn process_strategy_signal(&self, strategy_name: String, signal: StrategySignal) -> Result<(), BacktestError> {
        match signal {
            StrategySignal::PlaceOrder(order_request) => {
                self.execute_backtest_order(strategy_name, order_request).await?;
            }
            StrategySignal::CancelOrder(_) => {
                // å›æµ‹ä¸­é€šå¸¸ä¸éœ€è¦å¤„ç†å–æ¶ˆè®¢å•
            }
            StrategySignal::UpdatePosition { .. } => {
                // å¤„ç†ä»“ä½æ›´æ–°
            }
            StrategySignal::EmergencyStop => {
                // å¤„ç†ç´§æ€¥åœæ­¢
                log::warn!("Strategy {} triggered emergency stop", strategy_name);
            }
        }
        Ok(())
    }
    
    async fn execute_backtest_order(&self, strategy_name: String, order: OrderRequest) -> Result<(), BacktestError> {
        let current_time = self.current_time.read().await.clone();
        
        // è·å–å½“å‰ä»·æ ¼ï¼ˆç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ ¹æ®è®¢å•ç±»å‹å’Œå¸‚åœºæ·±åº¦è®¡ç®—ï¼‰
        let execution_price = self.get_execution_price(&order).await?;
        
        // è®¡ç®—æ‰‹ç»­è´¹å’Œæ»‘ç‚¹
        let commission = order.quantity * execution_price * self.config.commission_rate;
        let slippage = if self.config.enable_realistic_execution {
            execution_price * self.config.slippage_rate
        } else {
            Decimal::ZERO
        };
        
        let final_price = match order.side {
            OrderSide::Buy => execution_price + slippage,
            OrderSide::Sell => execution_price - slippage,
        };
        
        // æ£€æŸ¥èµ„é‡‘æ˜¯å¦è¶³å¤Ÿ
        {
            let portfolio = self.portfolio.read().await;
            let required_cash = match order.side {
                OrderSide::Buy => order.quantity * final_price + commission,
                OrderSide::Sell => commission, // å–å‡ºåªéœ€è¦æ‰‹ç»­è´¹
            };
            
            if order.side == OrderSide::Buy && portfolio.cash < required_cash {
                return Err(BacktestError::InsufficientFunds);
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æŒä»“å¯ä»¥å–å‡º
            if order.side == OrderSide::Sell {
                let current_position = portfolio.positions.get(&order.symbol).copied().unwrap_or(Decimal::ZERO);
                if current_position < order.quantity {
                    return Err(BacktestError::InsufficientPosition);
                }
            }
        }
        
        // æ›´æ–°æŠ•èµ„ç»„åˆ
        {
            let mut portfolio = self.portfolio.write().await;
            
            match order.side {
                OrderSide::Buy => {
                    portfolio.cash -= order.quantity * final_price + commission;
                    let current_position = portfolio.positions.entry(order.symbol.clone()).or_insert(Decimal::ZERO);
                    *current_position += order.quantity;
                }
                OrderSide::Sell => {
                    portfolio.cash += order.quantity * final_price - commission;
                    let current_position = portfolio.positions.get_mut(&order.symbol).unwrap();
                    *current_position -= order.quantity;
                    
                    // å¦‚æœæŒä»“ä¸ºé›¶ï¼Œç§»é™¤è¯¥æ¡ç›®
                    if *current_position == Decimal::ZERO {
                        portfolio.positions.remove(&order.symbol);
                    }
                }
            }
        }
        
        // è®°å½•äº¤æ˜“
        {
            let mut trade_history = self.trade_history.write().await;
            trade_history.push(BacktestTrade {
                timestamp: current_time,
                symbol: order.symbol,
                side: order.side,
                quantity: order.quantity,
                price: final_price,
                commission,
                slippage,
                strategy_name,
            });
        }
        
        Ok(())
    }
    
    async fn get_execution_price(&self, order: &OrderRequest) -> Result<Decimal, BacktestError> {
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨å½“å‰å¸‚åœºä»·æ ¼
        // å®é™…å®ç°åº”è¯¥æ ¹æ®è®¢å•ç±»å‹ã€å¸‚åœºæ·±åº¦ç­‰å› ç´ è®¡ç®—
        let current_data = self.data_provider.get_current_price(&order.symbol).await
            .ok_or_else(|| BacktestError::PriceNotAvailable(order.symbol.clone()))?;
        
        Ok(current_data)
    }
    
    async fn update_portfolio_value(&self, data: &HistoricalDataPoint) {
        let mut portfolio = self.portfolio.write().await;
        
        // è®¡ç®—æŒä»“ä»·å€¼
        let mut total_position_value = Decimal::ZERO;
        for (symbol, quantity) in &portfolio.positions {
            if symbol == &data.symbol {
                // ä½¿ç”¨å½“å‰æ•°æ®ç‚¹çš„ä»·æ ¼
                let mid_price = (data.order_book.bids[0].price + data.order_book.asks[0].price) / Decimal::from(2);
                total_position_value += *quantity * mid_price;
            } else {
                // ä½¿ç”¨æœ€åå·²çŸ¥ä»·æ ¼ï¼ˆç®€åŒ–å®ç°ï¼‰
                if let Some(last_price) = self.data_provider.get_last_known_price(symbol).await {
                    total_position_value += *quantity * last_price;
                }
            }
        }
        
        portfolio.total_value = portfolio.cash + total_position_value;
    }
}

#[derive(Debug, thiserror::Error)]
pub enum BacktestError {
    #[error("Strategy error in {0}: {1}")]
    StrategyError(String, StrategyError),
    
    #[error("Insufficient funds for order execution")]
    InsufficientFunds,
    
    #[error("Insufficient position for sell order")]
    InsufficientPosition,
    
    #[error("Price not available for symbol: {0}")]
    PriceNotAvailable(String),
    
    #[error("Data provider error: {0}")]
    DataProviderError(String),
}
```

## 7. é…ç½®ç®¡ç†

### 7.1 æµ‹è¯•é…ç½®

```toml
# config/test_config.toml
[system]
name = "crossfury_test_system"
version = "1.0.0"
environment = "test"
log_level = "debug"

# ğŸ”¥ æ¨¡æ‹Ÿè¿æ¥å™¨é…ç½®
[[connectors]]
name = "binance_spot_mock"
connector_type = "mock"
exchange_type = "binance"
market_type = "spot"
enabled = true

[connectors.config]
supported_symbols = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]

[connectors.config.latency_config]
base_latency = 10  # milliseconds
latency_variance = 5
network_jitter = 2
enable_realistic_latency = true

[connectors.config.error_config]
connection_error_rate = 0.01
order_error_rate = 0.005
market_data_error_rate = 0.001
timeout_rate = 0.002
enable_random_errors = true

[connectors.config.market_data_config]
tick_interval = 100  # milliseconds
price_volatility = 0.001
volume_range = [1.0, 1000.0]
spread_range = [0.0001, 0.001]
enable_realistic_movement = true

[connectors.config.account_config]
initial_balances = { "USDT" = 100000.0, "BTC" = 1.0, "ETH" = 10.0 }
trading_fees = { "default" = 0.001 }
max_leverage = 10.0

[connectors.config.execution_config]
partial_fill_probability = 0.1
slippage_range = [0.0, 0.001]
execution_delay = 50  # milliseconds
enable_realistic_execution = true

# ğŸ”¥ æµ‹è¯•ç­–ç•¥é…ç½®
[[strategies]]
name = "test_arbitrage_strategy"
strategy_type = "arbitrage"
enabled = true
symbols = ["BTC/USDT"]

[strategies.parameters]
min_profit_threshold = 0.001
max_position_size = 1000.0
risk_limit = 0.02

# ğŸ”¥ æ€§èƒ½æµ‹è¯•é…ç½®
[performance_test]
max_concurrent_orders = 1000
test_duration = 60  # seconds
target_throughput = 10000  # orders per second
memory_limit = 1073741824  # 1GB
cpu_limit = 80.0  # 80%

# ğŸ”¥ å›æµ‹é…ç½®
[backtest]
start_date = "2023-01-01T00:00:00Z"
end_date = "2023-12-31T23:59:59Z"
initial_capital = 100000.0
data_frequency = "1m"  # 1 minute
commission_rate = 0.001
slippage_rate = 0.0005
enable_realistic_execution = true

[backtest.symbols]
spot = ["BTC/USDT", "ETH/USDT"]
futures = ["BTC/USDT-PERP", "ETH/USDT-PERP"]
```

## 8. é‡æ„ä¼˜åŠ¿æ€»ç»“

### 8.1 æ ¸å¿ƒä¼˜åŠ¿

1. **å®Œæ•´çš„æµ‹è¯•åŸºç¡€è®¾æ–½**
   - æä¾›ä»å•å…ƒæµ‹è¯•åˆ°é›†æˆæµ‹è¯•çš„å®Œæ•´è¦†ç›–
   - æ”¯æŒç¦»çº¿æµ‹è¯•å’ŒçœŸå®ç¯å¢ƒæ¨¡æ‹Ÿ
   - ç¡®ä¿ç³»ç»Ÿè´¨é‡å’Œå¯é æ€§

2. **çœŸå®çš„æ¨¡æ‹Ÿç¯å¢ƒ**
   - MockConnector æä¾›æ¥è¿‘çœŸå®äº¤æ˜“ç¯å¢ƒçš„æ¨¡æ‹Ÿ
   - æ”¯æŒå»¶è¿Ÿã€é”™è¯¯ã€æ»‘ç‚¹ç­‰çœŸå®åœºæ™¯æ¨¡æ‹Ÿ
   - å¯é…ç½®çš„å¸‚åœºæ•°æ®ç”Ÿæˆå’Œè´¦æˆ·çŠ¶æ€ç®¡ç†

3. **å…¨é¢çš„æ€§èƒ½æµ‹è¯•**
   - æ”¯æŒé«˜å¹¶å‘è®¢å•æ‰§è¡Œæµ‹è¯•
   - å¸‚åœºæ•°æ®ååé‡å‹åŠ›æµ‹è¯•
   - å¥—åˆ©æ£€æµ‹é€Ÿåº¦åŸºå‡†æµ‹è¯•
   - è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡æ”¶é›†å’Œåˆ†æ

4. **ä¸“ä¸šçš„å›æµ‹æ¡†æ¶**
   - æ”¯æŒå†å²æ•°æ®å›æµ‹å’Œç­–ç•¥éªŒè¯
   - å®Œæ•´çš„æŠ•èµ„ç»„åˆç®¡ç†å’Œé£é™©æ§åˆ¶
   - è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡è®¡ç®—ï¼ˆå¤æ™®æ¯”ç‡ã€æœ€å¤§å›æ’¤ç­‰ï¼‰
   - å¯è§†åŒ–çš„æƒç›Šæ›²çº¿å’Œå›æ’¤åˆ†æ

### 8.2 æŠ€æœ¯ç‰¹æ€§

1. **æ¨¡å—åŒ–è®¾è®¡**
   - å„æµ‹è¯•ç»„ä»¶ç‹¬ç«‹å¯å¤ç”¨
   - æ”¯æŒæ’ä»¶å¼æ‰©å±•
   - æ˜“äºç»´æŠ¤å’Œå‡çº§

2. **é…ç½®é©±åŠ¨**
   - é€šè¿‡é…ç½®æ–‡ä»¶çµæ´»æ§åˆ¶æµ‹è¯•è¡Œä¸º
   - æ”¯æŒä¸åŒæµ‹è¯•åœºæ™¯çš„å¿«é€Ÿåˆ‡æ¢
   - ä¾¿äºCI/CDé›†æˆ

3. **å¼‚æ­¥é«˜æ€§èƒ½**
   - åŸºäºTokioå¼‚æ­¥è¿è¡Œæ—¶
   - æ”¯æŒé«˜å¹¶å‘æµ‹è¯•åœºæ™¯
   - ä¼˜åŒ–çš„å†…å­˜ä½¿ç”¨å’ŒCPUæ•ˆç‡

4. **å¯è§‚æµ‹æ€§**
   - è¯¦ç»†çš„æµ‹è¯•æ—¥å¿—å’ŒæŒ‡æ ‡
   - å®æ—¶æ€§èƒ½ç›‘æ§
   - æµ‹è¯•ç»“æœå¯è§†åŒ–

### 8.3 å®æ–½å»ºè®®

1. **åˆ†é˜¶æ®µå®æ–½**
   - ç¬¬ä¸€é˜¶æ®µï¼šå®ç°MockConnectorå’ŒåŸºç¡€å•å…ƒæµ‹è¯•
   - ç¬¬äºŒé˜¶æ®µï¼šå®Œå–„é›†æˆæµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•æ¡†æ¶
   - ç¬¬ä¸‰é˜¶æ®µï¼šæ„å»ºå›æµ‹æ¡†æ¶å’Œé«˜çº§åˆ†æå·¥å…·

2. **æŒç»­é›†æˆ**
   - å°†æµ‹è¯•æ¡†æ¶é›†æˆåˆ°CI/CDæµæ°´çº¿
   - è‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡Œå’ŒæŠ¥å‘Šç”Ÿæˆ
   - æ€§èƒ½å›å½’æ£€æµ‹å’Œå‘Šè­¦

3. **æ–‡æ¡£å’ŒåŸ¹è®­**
   - ç¼–å†™è¯¦ç»†çš„æµ‹è¯•æ¡†æ¶ä½¿ç”¨æ–‡æ¡£
   - æä¾›æµ‹è¯•æœ€ä½³å®è·µæŒ‡å—
   - å›¢é˜ŸåŸ¹è®­å’ŒçŸ¥è¯†åˆ†äº«

é€šè¿‡è¿™ä¸ªå…¨é¢çš„æµ‹è¯•æ¡†æ¶æ¨¡å—ï¼ŒCrossFuryç³»ç»Ÿå°†å…·å¤‡ä¼ä¸šçº§çš„è´¨é‡ä¿è¯èƒ½åŠ›ï¼Œç¡®ä¿åœ¨é«˜é¢‘äº¤æ˜“ç¯å¢ƒä¸‹çš„ç¨³å®šæ€§å’Œå¯é æ€§ã€‚

## 9. æ–°ç›®å½•ç»“æ„è®¾è®¡

```
src/
â”œâ”€â”€ testing/                     # æµ‹è¯•æ¡†æ¶æ¨¡å—
â”‚   â”œâ”€â”€ mod.rs                   # æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ traits.rs                # å¼•ç”¨æ ¸å¿ƒtraitå®šä¹‰
â”‚   â”œâ”€â”€ mock_connector.rs        # æ¨¡æ‹Ÿè¿æ¥å™¨å®ç°
â”‚   â”œâ”€â”€ test_framework.rs        # æµ‹è¯•æ¡†æ¶ç®¡ç†å™¨
â”‚   â”œâ”€â”€ mock_data_provider.rs    # æµ‹è¯•æ•°æ®æä¾›è€…
â”‚   â”œâ”€â”€ market_simulator.rs      # å¸‚åœºæ•°æ®æ¨¡æ‹Ÿå™¨
â”‚   â”œâ”€â”€ account_simulator.rs     # è´¦æˆ·æ•°æ®æ¨¡æ‹Ÿå™¨
â”‚   â”œâ”€â”€ order_manager.rs         # è®¢å•ç®¡ç†æ¨¡æ‹Ÿå™¨
â”‚   â”œâ”€â”€ latency_simulator.rs     # å»¶è¿Ÿæ¨¡æ‹Ÿå™¨
â”‚   â”œâ”€â”€ error_simulator.rs       # é”™è¯¯æ¨¡æ‹Ÿå™¨
â”‚   â”œâ”€â”€ performance_tester.rs    # æ€§èƒ½æµ‹è¯•å™¨
â”‚   â”œâ”€â”€ backtest_engine.rs       # å›æµ‹å¼•æ“
â”‚   â”œâ”€â”€ test_data_generator.rs   # æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ legacy_adapter.rs        # æ—§ä»£ç é€‚é…å™¨
â”‚   â””â”€â”€ utils.rs                 # æµ‹è¯•å·¥å…·å‡½æ•°
â”œâ”€â”€ types/                       # æ•°æ®ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ testing.rs               # æµ‹è¯•ç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ mock_data.rs             # æ¨¡æ‹Ÿæ•°æ®ç±»å‹
â”‚   â”œâ”€â”€ test_config.rs           # æµ‹è¯•é…ç½®ç±»å‹
â”‚   â””â”€â”€ performance.rs           # æ€§èƒ½æµ‹è¯•ç±»å‹
â”œâ”€â”€ legacy_tests/                # æ—§ä»£ç ä¿ç•™
â”‚   â”œâ”€â”€ legacy_unit_tests.rs     # åŸå•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ legacy_integration_tests.rs # åŸé›†æˆæµ‹è¯•
â”‚   â””â”€â”€ legacy_benchmarks.rs     # åŸæ€§èƒ½æµ‹è¯•
â”œâ”€â”€ tests/                       # æ–°æµ‹è¯•ç›®å½•
â”‚   â”œâ”€â”€ unit/                    # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ connectors/          # è¿æ¥å™¨å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ executors/           # æ‰§è¡Œå™¨å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ strategies/          # ç­–ç•¥å•å…ƒæµ‹è¯•
â”‚   â”‚   â””â”€â”€ testing/             # æµ‹è¯•æ¡†æ¶å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration/             # é›†æˆæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ system_integration.rs # ç³»ç»Ÿé›†æˆæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ multi_exchange.rs    # å¤šäº¤æ˜“æ‰€æµ‹è¯•
â”‚   â”‚   â””â”€â”€ end_to_end.rs        # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ performance/             # æ€§èƒ½æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ latency_tests.rs     # å»¶è¿Ÿæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ throughput_tests.rs  # ååé‡æµ‹è¯•
â”‚   â”‚   â””â”€â”€ stress_tests.rs      # å‹åŠ›æµ‹è¯•
â”‚   â””â”€â”€ backtest/                # å›æµ‹æµ‹è¯•
â”‚       â”œâ”€â”€ strategy_backtest.rs # ç­–ç•¥å›æµ‹
â”‚       â””â”€â”€ portfolio_backtest.rs # æŠ•èµ„ç»„åˆå›æµ‹
â””â”€â”€ config/
    â”œâ”€â”€ testing.rs               # æµ‹è¯•é…ç½®ç®¡ç†
    â””â”€â”€ mock_data.rs             # æ¨¡æ‹Ÿæ•°æ®é…ç½®
```

## 10. åˆ†é˜¶æ®µå®æ–½æ­¥éª¤

### é˜¶æ®µ1ï¼šåŸºç¡€è®¾æ–½æ­å»ºï¼ˆ2-3å‘¨ï¼‰

#### 1.1 åˆ›å»ºæ–°ç›®å½•ç»“æ„
- åˆ›å»º `src/testing/` ç›®å½•åŠå­æ¨¡å—
- åˆ›å»º `src/types/` ç›®å½•åŠæµ‹è¯•ç›¸å…³ç±»å‹å®šä¹‰
- åˆ›å»º `src/legacy_tests/` ç›®å½•
- åˆ›å»ºæ–°çš„ `tests/` ç›®å½•ç»“æ„

#### 1.2 ä¿ç•™æ—§ä»£ç 
```bash
# é‡å‘½åç°æœ‰æµ‹è¯•æ–‡ä»¶ï¼Œä¿æŒåŠŸèƒ½ä¸å˜
mv tests/ src/legacy_tests/  # ä¿ç•™ç°æœ‰æµ‹è¯•ç›®å½•
cp -r src/**/tests src/legacy_tests/  # ä¿ç•™æ¨¡å—å†…æµ‹è¯•
# ä¿ç•™å„æ¨¡å—ä¸­çš„ #[cfg(test)] ä»£ç å—
```

#### 1.3 åˆ›å»ºtraitå¼•ç”¨æ–‡ä»¶
```rust
// src/testing/traits.rs
pub use crate::traits::{
    ExchangeConnector, TestConnector, MockDataProvider, TestFramework
};
```

### é˜¶æ®µ2ï¼šæ¨¡æ‹Ÿè¿æ¥å™¨å®ç°ï¼ˆ3-4å‘¨ï¼‰

#### 2.1 å®ç°MockConnector
- åˆ›å»º `MockConnector` æ ¸å¿ƒå®ç°
- å®ç° `ExchangeConnector` trait çš„å®Œæ•´åŠŸèƒ½
- æ·»åŠ å¸‚åœºæ•°æ®æ¨¡æ‹Ÿå’Œè´¦æˆ·æ•°æ®æ¨¡æ‹Ÿ
- å®ç°å»¶è¿Ÿå’Œé”™è¯¯æ¨¡æ‹ŸåŠŸèƒ½

#### 2.2 æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
- å®ç° `TestDataGenerator`
- æ”¯æŒå„ç§å¸‚åœºæ•°æ®ç”Ÿæˆï¼ˆè®¢å•ç°¿ã€äº¤æ˜“ã€Kçº¿ç­‰ï¼‰
- å®ç°çœŸå®æ•°æ®å›æ”¾åŠŸèƒ½
- æ·»åŠ æ•°æ®éªŒè¯å’Œè´¨é‡æ£€æŸ¥

#### 2.3 æ—§æµ‹è¯•é€‚é…å™¨
- åˆ›å»º `LegacyTestAdapter`
- å®ç°æ—§æµ‹è¯•åˆ°æ–°æ¡†æ¶çš„è½¬æ¢
- ç¡®ä¿ç°æœ‰æµ‹è¯•åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- ä¿æŒæµ‹è¯•è¦†ç›–ç‡ä¸é™ä½

### é˜¶æ®µ3ï¼šæµ‹è¯•æ¡†æ¶æ ¸å¿ƒï¼ˆ3-4å‘¨ï¼‰

#### 3.1 æµ‹è¯•æ¡†æ¶ç®¡ç†å™¨
- å®ç° `TestFrameworkManager`
- æ·»åŠ æµ‹è¯•ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å®ç°æµ‹è¯•é…ç½®å’Œç¯å¢ƒç®¡ç†
- é›†æˆCI/CDæ”¯æŒ

#### 3.2 æ€§èƒ½æµ‹è¯•æ¡†æ¶
- å®ç° `PerformanceTester`
- æ·»åŠ å»¶è¿Ÿã€ååé‡ã€å¹¶å‘æµ‹è¯•
- å®ç°æ€§èƒ½åŸºå‡†å’Œå›å½’æ£€æµ‹
- æ·»åŠ è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡æ”¶é›†

#### 3.3 å•å…ƒæµ‹è¯•è¿ç§»
- é‡æ„ç°æœ‰å•å…ƒæµ‹è¯•
- ä½¿ç”¨æ–°çš„æµ‹è¯•æ¡†æ¶å’Œæ¨¡æ‹Ÿå™¨
- æé«˜æµ‹è¯•è¦†ç›–ç‡å’Œè´¨é‡
- æ·»åŠ è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æµ‹è¯•

### é˜¶æ®µ4ï¼šé›†æˆæµ‹è¯•å’Œå›æµ‹ï¼ˆ3-4å‘¨ï¼‰

#### 4.1 é›†æˆæµ‹è¯•æ¡†æ¶
- å®ç°ç³»ç»Ÿçº§é›†æˆæµ‹è¯•
- æ·»åŠ å¤šäº¤æ˜“æ‰€åä½œæµ‹è¯•
- å®ç°ç«¯åˆ°ç«¯æµ‹è¯•åœºæ™¯
- æ·»åŠ æ•…éšœæ¢å¤å’Œå®¹é”™æµ‹è¯•

#### 4.2 å›æµ‹å¼•æ“
- å®ç° `BacktestEngine`
- æ”¯æŒå†å²æ•°æ®å›æ”¾
- å®ç°ç­–ç•¥æ€§èƒ½è¯„ä¼°
- æ·»åŠ é£é™©æŒ‡æ ‡è®¡ç®—

#### 4.3 æµ‹è¯•æŠ¥å‘Šç³»ç»Ÿ
- å®ç°è‡ªåŠ¨åŒ–æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ
- æ·»åŠ æµ‹è¯•è¦†ç›–ç‡åˆ†æ
- å®ç°æ€§èƒ½è¶‹åŠ¿åˆ†æ
- é›†æˆå¯è§†åŒ–å›¾è¡¨

### é˜¶æ®µ5ï¼šä¼˜åŒ–å’Œé›†æˆï¼ˆ2-3å‘¨ï¼‰

#### 5.1 æ€§èƒ½ä¼˜åŒ–
- ä¼˜åŒ–æµ‹è¯•æ‰§è¡Œé€Ÿåº¦
- å‡å°‘æµ‹è¯•èµ„æºæ¶ˆè€—
- å®ç°å¹¶è¡Œæµ‹è¯•æ‰§è¡Œ
- æ·»åŠ æµ‹è¯•ç¼“å­˜æœºåˆ¶

#### 5.2 CI/CDé›†æˆ
- é›†æˆåˆ°æŒç»­é›†æˆæµæ°´çº¿
- å®ç°è‡ªåŠ¨åŒ–æµ‹è¯•è§¦å‘
- æ·»åŠ æµ‹è¯•ç»“æœé€šçŸ¥
- å®ç°æµ‹è¯•å¤±è´¥è‡ªåŠ¨å›æ»š

#### 5.3 æ–‡æ¡£å’Œå·¥å…·
- ç¼–å†™æµ‹è¯•æ¡†æ¶ä½¿ç”¨æ–‡æ¡£
- åˆ›å»ºæµ‹è¯•æœ€ä½³å®è·µæŒ‡å—
- å¼€å‘æµ‹è¯•è¾…åŠ©å·¥å…·
- æä¾›æµ‹è¯•æ¨¡æ¿å’Œç¤ºä¾‹

### é˜¶æ®µ6ï¼šæ¸…ç†å’Œæ–‡æ¡£ï¼ˆ1-2å‘¨ï¼‰

#### 6.1 ä»£ç æ¸…ç†
- ç§»é™¤æœªä½¿ç”¨çš„æ—§æµ‹è¯•ä»£ç 
- ä¼˜åŒ–æµ‹è¯•ä»£ç ç»“æ„
- ç»Ÿä¸€æµ‹è¯•ä»£ç é£æ ¼
- æ·»åŠ è¯¦ç»†çš„æµ‹è¯•æ–‡æ¡£

#### 6.2 åŸ¹è®­å’Œæ¨å¹¿
- å›¢é˜ŸåŸ¹è®­å’ŒçŸ¥è¯†åˆ†äº«
- ç¼–å†™æµ‹è¯•å¼€å‘æŒ‡å—
- å»ºç«‹æµ‹è¯•è´¨é‡æ ‡å‡†
- æ¨å¹¿æµ‹è¯•æœ€ä½³å®è·µ

### æ€»æ—¶é—´é¢„ä¼°ï¼š14-20å‘¨

### é£é™©æ§åˆ¶æªæ–½
1. **æ¸è¿›å¼è¿ç§»**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½ä¿æŒç°æœ‰æµ‹è¯•åŠŸèƒ½æ­£å¸¸
2. **å¹¶è¡Œå¼€å‘**ï¼šæ–°æ—§æµ‹è¯•æ¡†æ¶å¹¶å­˜ï¼Œé€æ­¥åˆ‡æ¢
3. **è´¨é‡ä¿è¯**ï¼šç¡®ä¿æµ‹è¯•è¦†ç›–ç‡ä¸é™ä½
4. **å›æ»šæœºåˆ¶**ï¼šå‡ºç°é—®é¢˜æ—¶å¯å¿«é€Ÿå›æ»šåˆ°æ—§ç‰ˆæœ¬
5. **æŒç»­ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æµ‹è¯•æ‰§è¡ŒçŠ¶æ€å’Œè´¨é‡æŒ‡æ ‡
6. **æ–‡æ¡£åŒæ­¥**ï¼šå¼€å‘è¿‡ç¨‹ä¸­åŒæ­¥æ›´æ–°æ–‡æ¡£å’ŒåŸ¹è®­ææ–™
```

### 3.2 ç­–ç•¥æµ‹è¯•

```rust
// tests/unit/strategies/test_strategy_framework.rs
use tokio_test;
use std::collections::HashMap;
use crossfury::strategies::traits::*;
use crossfury::strategies::base_strategy::*;
use crossfury::types::*;

// ğŸ”¥ æµ‹è¯•ç­–ç•¥å®ç°
struct TestStrategy {
    base: BaseStrategy,
    signal_count: Arc<RwLock<u32>>,
}

#[async_trait]
impl Strategy for TestStrategy {
    fn get_strategy_name(&self) -> &str {
        "test_strategy"
    }
    
    fn get_strategy_version(&self) -> &str {
        "1.0.0"
    }
    
    fn get_description(&self) -> &str {
        "Test strategy for unit testing"
    }
    
    fn get_supported_markets(&self) -> Vec<MarketType> {
        vec![MarketType::Spot]
    }
    
    fn get_required_symbols(&self) -> Vec<String> {
        vec!["BTC/USDT".to_string()]
    }
    
    async fn initialize(&mut self, config: StrategyConfig) -> Result<(), StrategyError> {
        self.base.set_state(StrategyState::Ready).await;
        Ok(())
    }
    
    async fn start(&mut self) -> Result<(), StrategyError> {
        self.base.set_state(StrategyState::Running).await;
        Ok(())
    }
    
    async fn stop(&mut self) -> Result<(), StrategyError> {
        self.base.set_state(StrategyState::Stopped).await;
        Ok(())
    }
    
    async fn cleanup(&mut self) -> Result<(), StrategyError> {
        Ok(())
    }
    
    async fn on_market_data(&mut self, data: MarketDataEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        // å¢åŠ ä¿¡å·è®¡æ•°
        {
            let mut count = self.signal_count.write().await;
            *count += 1;
        }
        
        // ç®€å•çš„æµ‹è¯•é€»è¾‘ï¼šä»·æ ¼ä¸Šæ¶¨æ—¶ä¹°å…¥
        match data {
            MarketDataEvent::OrderBookUpdate { symbol, order_book } => {
                if let (Some(best_bid), Some(best_ask)) = (order_book.bids.first(), order_book.asks.first()) {
                    let mid_price = (best_bid.price + best_ask.price) / Decimal::from(2);
                    
                    // å¦‚æœä»·æ ¼é«˜äºæŸä¸ªé˜ˆå€¼ï¼Œç”Ÿæˆä¹°å…¥ä¿¡å·
                    if mid_price > Decimal::from(50000) {
                        let order_request = OrderRequest {
                            client_order_id: format!("test_order_{}", Utc::now().timestamp()),
                            symbol: symbol.clone(),
                            side: OrderSide::Buy,
                            order_type: OrderType::Market,
                            quantity: Decimal::from_str("0.001").unwrap(),
                            price: None,
                            time_in_force: Some(TimeInForce::IOC),
                        };
                        
                        return Ok(vec![StrategySignal::PlaceOrder(order_request)]);
                    }
                }
            }
            _ => {}
        }
        
        Ok(vec![])
    }
    
    async fn on_user_data(&mut self, data: UserDataEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn on_system_event(&mut self, event: SystemEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn on_execution_result(&mut self, result: ExecutionResult) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn on_execution_error(&mut self, error: ExecutionError) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
    
    async fn get_strategy_state(&self) -> StrategyState {
        self.base.get_state().await
    }
    
    async fn set_strategy_parameters(&mut self, params: HashMap<String, StrategyParameter>) -> Result<(), StrategyError> {
        for (key, value) in params {
            self.base.set_parameter(key, value).await;
        }
        Ok(())
    }
    
    async fn get_strategy_metrics(&self) -> StrategyMetrics {
        StrategyMetrics::default()
    }
    
    async fn get_risk_limits(&self) -> RiskLimits {
        RiskLimits::default()
    }
    
    async fn handle_risk_event(&mut self, event: RiskEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        Ok(vec![])
    }
}

impl TestStrategy {
    fn new() -> Self {
        Self {
            base: BaseStrategy::new(
                "test_strategy".to_string(),
                "1.0.0".to_string(),
                "Test strategy".to_string(),
            ),
            signal_count: Arc::new(RwLock::new(0)),
        }
    }
    
    async fn get_signal_count(&self) -> u32 {
        *self.signal_count.read().await
    }
}

#[tokio::test]
async fn test_strategy_lifecycle() {
    // ğŸ”¥ æµ‹è¯•ç­–ç•¥ç”Ÿå‘½å‘¨æœŸ
    let mut strategy = TestStrategy::new();
    
    // æµ‹è¯•åˆå§‹åŒ–
    let config = StrategyConfig::default();
    let result = strategy.initialize(config).await;
    assert!(result.is_ok());
    assert_eq!(strategy.get_strategy_state().await, StrategyState::Ready);
    
    // æµ‹è¯•å¯åŠ¨
    let result = strategy.start().await;
    assert!(result.is_ok());
    assert_eq!(strategy.get_strategy_state().await, StrategyState::Running);
    
    // æµ‹è¯•åœæ­¢
    let result = strategy.stop().await;
    assert!(result.is_ok());
    assert_eq!(strategy.get_strategy_state().await, StrategyState::Stopped);
}

#[tokio::test]
async fn test_strategy_market_data_processing() {
    // ğŸ”¥ æµ‹è¯•ç­–ç•¥å¸‚åœºæ•°æ®å¤„ç†
    let mut strategy = TestStrategy::new();
    strategy.initialize(StrategyConfig::default()).await.unwrap();
    strategy.start().await.unwrap();
    
    // åˆ›å»ºæµ‹è¯•è®¢å•ç°¿æ•°æ®
    let order_book = OrderBook {
        symbol: "BTC/USDT".to_string(),
        bids: vec![PriceLevel { price: Decimal::from(49999), quantity: Decimal::from(1) }],
        asks: vec![PriceLevel { price: Decimal::from(50001), quantity: Decimal::from(1) }],
        timestamp: Utc::now(),
    };
    
    let market_data = MarketDataEvent::OrderBookUpdate {
        symbol: "BTC/USDT".to_string(),
        order_book,
    };
    
    // å¤„ç†å¸‚åœºæ•°æ®
    let signals = strategy.on_market_data(market_data).await.unwrap();
    
    // éªŒè¯ä¿¡å·ç”Ÿæˆ
    assert_eq!(signals.len(), 1);
    match &signals[0] {
        StrategySignal::PlaceOrder(order) => {
            assert_eq!(order.symbol, "BTC/USDT");
            assert_eq!(order.side, OrderSide::Buy);
        }
        _ => panic!("Expected PlaceOrder signal"),
    }
    
    // éªŒè¯ä¿¡å·è®¡æ•°
    assert_eq!(strategy.get_signal_count().await, 1);
}

#[tokio::test]
async fn test_strategy_parameter_management() {
    // ğŸ”¥ æµ‹è¯•ç­–ç•¥å‚æ•°ç®¡ç†
    let mut strategy = TestStrategy::new();
    
    // è®¾ç½®å‚æ•°
    let mut params = HashMap::new();
    params.insert("profit_threshold".to_string(), StrategyParameter::Float(0.01));
    params.insert("max_position".to_string(), StrategyParameter::Decimal(Decimal::from(1000)));
    params.insert("enabled".to_string(), StrategyParameter::Boolean(true));
    
    let result = strategy.set_strategy_parameters(params).await;
    assert!(result.is_ok());
    
    // éªŒè¯å‚æ•°è®¾ç½®
    let profit_threshold: Option<f64> = strategy.base.get_parameter("profit_threshold").await;
    assert_eq!(profit_threshold, Some(0.01));
    
    let enabled: Option<bool> = strategy.base.get_parameter("enabled").await;
    assert_eq!(enabled, Some(true));
}
```

## 4. é›†æˆæµ‹è¯•æ¡†æ¶

### 4.1 ç«¯åˆ°ç«¯æµ‹è¯•

```rust
// tests/integration/test_end_to_end.rs
use tokio_test;
use std::time::Duration;
use crossfury::config::SystemAssembler;
use crossfury::testing::mock_connector::*;
use crossfury::testing::test_data_generator::*;

#[tokio::test]
async fn test_complete_trading_flow() {
    // ğŸ”¥ ç«¯åˆ°ç«¯äº¤æ˜“æµç¨‹æµ‹è¯•
    
    // 1. åˆ›å»ºæµ‹è¯•é…ç½®
    let test_config = create_integration_test_config().await;
    
    // 2. ç»„è£…ç³»ç»Ÿ
    let assembler = SystemAssembler::new();
    let mut system = assembler.assemble_from_config(test_config).await.unwrap();
    
    // 3. å¯åŠ¨ç³»ç»Ÿ
    system.start().await.unwrap();
    
    // 4. ç­‰å¾…ç³»ç»Ÿç¨³å®š
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // 5. éªŒè¯è¿æ¥å™¨çŠ¶æ€
    let connector_manager = system.get_connector_manager();
    let connectors = connector_manager.get_all_connectors().await;
    assert!(!connectors.is_empty());
    
    // 6. éªŒè¯å¸‚åœºæ•°æ®æµ
    let data_flow_manager = system.get_data_flow_manager();
    let mut market_data_stream = data_flow_manager.get_market_data_stream().await.unwrap();
    
    // ç­‰å¾…å¸‚åœºæ•°æ®
    let timeout = tokio::time::timeout(Duration::from_secs(5), market_data_stream.recv()).await;
    assert!(timeout.is_ok());
    
    // 7. æµ‹è¯•ç­–ç•¥æ‰§è¡Œ
    let strategy_manager = system.get_strategy_manager();
    let strategies = strategy_manager.get_all_strategies().await;
    assert!(!strategies.is_empty());
    
    // 8. æµ‹è¯•è®¢å•æ‰§è¡Œ
    let order_executor = system.get_order_executor();
    let order_request = OrderRequest {
        client_order_id: "integration_test_order".to_string(),
        symbol: "BTC/USDT".to_string(),
        side: OrderSide::Buy,
        order_type: OrderType::Market,
        quantity: Decimal::from_str("0.001").unwrap(),
        price: None,
        time_in_force: Some(TimeInForce::IOC),
    };
    
    let execution_result = order_executor.execute_order(order_request).await;
    assert!(execution_result.is_ok());
    
    // 9. åœæ­¢ç³»ç»Ÿ
    system.stop().await.unwrap();
}

#[tokio::test]
async fn test_multi_exchange_arbitrage() {
    // ğŸ”¥ å¤šäº¤æ˜“æ‰€å¥—åˆ©æµ‹è¯•
    
    // åˆ›å»ºå¤šä¸ªæ¨¡æ‹Ÿè¿æ¥å™¨
    let binance_config = create_mock_connector_config(ExchangeType::Binance, MarketType::Spot);
    let okx_config = create_mock_connector_config(ExchangeType::OKX, MarketType::Spot);
    
    let binance_connector = MockConnector::new(binance_config);
    let okx_connector = MockConnector::new(okx_config);
    
    // è®¾ç½®ä¸åŒçš„ä»·æ ¼ä»¥åˆ›å»ºå¥—åˆ©æœºä¼š
    binance_connector.set_market_price("BTC/USDT", Decimal::from(50000)).await;
    okx_connector.set_market_price("BTC/USDT", Decimal::from(50100)).await;
    
    // è¿æ¥æ‰€æœ‰è¿æ¥å™¨
    binance_connector.connect().await.unwrap();
    okx_connector.connect().await.unwrap();
    
    // åˆ›å»ºå¥—åˆ©å¼•æ“
    let arbitrage_engine = ArbitrageEngine::new();
    arbitrage_engine.add_connector("binance", Arc::new(binance_connector)).await;
    arbitrage_engine.add_connector("okx", Arc::new(okx_connector)).await;
    
    // æ‰«æå¥—åˆ©æœºä¼š
    let opportunities = arbitrage_engine.scan_opportunities("BTC/USDT").await.unwrap();
    assert!(!opportunities.is_empty());
    
    // æ‰§è¡Œå¥—åˆ©
    let opportunity = &opportunities[0];
    let result = arbitrage_engine.execute_arbitrage(opportunity.clone()).await;
    assert!(result.is_ok());
}

#[tokio::test]
async fn test_risk_management_integration() {
    // ğŸ”¥ é£é™©ç®¡ç†é›†æˆæµ‹è¯•
    
    let test_config = create_integration_test_config().await;
    let assembler = SystemAssembler::new();
    let mut system = assembler.assemble_from_config(test_config).await.unwrap();
    
    system.start().await.unwrap();
    
    let risk_manager = system.get_risk_manager();
    let order_executor = system.get_order_executor();
    
    // æµ‹è¯•è¶…å‡ºé£é™©é™åˆ¶çš„è®¢å•
    let large_order = OrderRequest {
        client_order_id: "large_order_test".to_string(),
        symbol: "BTC/USDT".to_string(),
        side: OrderSide::Buy,
        order_type: OrderType::Market,
        quantity: Decimal::from(1000), // è¶…å¤§è®¢å•
        price: None,
        time_in_force: Some(TimeInForce::IOC),
    };
    
    // é£é™©æ£€æŸ¥åº”è¯¥æ‹’ç»è¿™ä¸ªè®¢å•
    let risk_check = risk_manager.check_order_risk(&large_order).await;
    assert!(risk_check.is_err());
    
    // æ‰§è¡Œå™¨åº”è¯¥æ‹’ç»æ‰§è¡Œ
    let execution_result = order_executor.execute_order(large_order).await;
    assert!(execution_result.is_err());
    
    system.stop().await.unwrap();
}

// è¾…åŠ©å‡½æ•°
async fn create_integration_test_config() -> SystemConfig {
    SystemConfig {
        system: SystemSettings {
            name: "integration_test_system".to_string(),
            version: "1.0.0".to_string(),
            environment: "test".to_string(),
            log_level: "debug".to_string(),
        },
        connectors: vec![
            ConnectorConfig {
                name: "binance_spot".to_string(),
                connector_type: "mock".to_string(),
                exchange_type: ExchangeType::Binance,
                market_type: MarketType::Spot,
                enabled: true,
                config: serde_json::json!({
                    "supported_symbols": ["BTC/USDT", "ETH/USDT"],
                    "latency_config": {
                        "base_latency": 10,
                        "enable_realistic_latency": false
                    },
                    "error_config": {
                        "enable_random_errors": false
                    }
                }),
            },
        ],
        executor: ExecutorConfig {
            max_concurrent_orders: 100,
            order_timeout: Duration::from_secs(30),
            retry_attempts: 3,
            batch_size: 10,
        },
        strategies: vec![
            StrategyConfig {
                name: "test_strategy".to_string(),
                strategy_type: "test".to_string(),
                enabled: true,
                symbols: vec!["BTC/USDT".to_string()],
                parameters: HashMap::new(),
            },
        ],
        event_bus: EventBusConfig {
            high_frequency_buffer_size: 10000,
            system_event_buffer_size: 1000,
            enable_persistence: false,
        },
        monitoring: MonitoringConfig {
            enabled: true,
            metrics_interval: Duration::from_secs(1),
            health_check_interval: Duration::from_secs(5),
        },
        logging: LoggingConfig {
            level: "debug".to_string(),
            output: "console".to_string(),
            format: "json".to_string(),
        },
    }
}

fn create_mock_connector_config(exchange_type: ExchangeType, market_type: MarketType) -> MockConnectorConfig {
    MockConnectorConfig {
        exchange_type,
        market_type,
        supported_symbols: vec!["BTC/USDT".to_string(), "ETH/USDT".to_string()],
        latency_config: LatencyConfig {
            base_latency: Duration::from_millis(10),
            latency_variance: Duration::from_millis(5),
            network_jitter: Duration::from_millis(2),
            enable_realistic_latency: false,
        },
        error_config: ErrorConfig {
            connection_error_rate: 0.0,
            order_error_rate: 0.0,
            market_data_error_rate: 0.0,
            timeout_rate: 0.0,
            enable_random_errors: false,
        },
        market_data_config: MarketDataConfig {
            tick_interval: Duration::from_millis(100),
            price_volatility: 0.001,
            volume_range: (Decimal::from(1), Decimal::from(1000)),
            spread_range: (Decimal::from_str("0.0001").unwrap(), Decimal::from_str("0.001").unwrap()),
            enable_realistic_movement: true,
        },
        account_config: AccountConfig {
            initial_balances: {
                let mut balances = HashMap::new();
                balances.insert("USDT".to_string(), Decimal::from(100000));
                balances.insert("BTC".to_string(), Decimal::from(1));
                balances
            },
            trading_fees: {
                let mut fees = HashMap::new();
                fees.insert("default".to_string(), Decimal::from_str("0.001").unwrap());
                fees
            },
            margin_requirements: HashMap::new(),
            max_leverage: Some(Decimal::from(10)),
        },
        execution_config: ExecutionConfig {
            partial_fill_probability: 0.1,
            slippage_range: (0.0, 0.001),
            execution_delay: Duration::from_millis(50),
            enable_realistic_execution: true,
        },
    }
}
```