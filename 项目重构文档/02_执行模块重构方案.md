# æ‰§è¡Œæ¨¡å—é‡æ„æ–¹æ¡ˆ

## 1. æ¨¡å—æ¦‚è¿°

æ‰§è¡Œæ¨¡å—æ˜¯ CrossFury ç³»ç»Ÿçš„æ ¸å¿ƒäº¤æ˜“æ‰§è¡Œå±‚ï¼Œè´Ÿè´£è®¢å•è·¯ç”±ã€é£é™©æ§åˆ¶ã€ä»“ä½ç®¡ç†å’Œå¥—åˆ©æ‰§è¡Œã€‚æœ¬æ¨¡å—åŸºäº**äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼Œä¸è¿æ¥æ¨¡å—çš„æ¨é€å¼æ•°æ®æµæ— ç¼é›†æˆã€‚

**é‡è¦ï¼šæœ¬æ–¹æ¡ˆä¸¥æ ¼éµå¾ª `CrossFury_æ ¸å¿ƒTraitå®šä¹‰.md` ä¸­å®šä¹‰çš„æ¥å£è§„èŒƒã€‚**

### 1.1 æ ¸å¿ƒèŒè´£
- **æ™ºèƒ½è®¢å•è·¯ç”±**ï¼šæ ¹æ®å¸‚åœºç±»å‹å’ŒæµåŠ¨æ€§é€‰æ‹©æœ€ä¼˜äº¤æ˜“æ‰€
- **å®æ—¶é£é™©æ§åˆ¶**ï¼šç°è´§å’ŒæœŸè´§å·®å¼‚åŒ–é£æ§ç­–ç•¥
- **ä»“ä½ç®¡ç†**ï¼šç»Ÿä¸€çš„å¤šäº¤æ˜“æ‰€ä»“ä½è·Ÿè¸ª
- **å¥—åˆ©æ‰§è¡Œ**ï¼šç°è´§å¥—åˆ©ã€æœŸè´§å¥—åˆ©ã€è·¨å¸‚åœºå¥—åˆ©
- **è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šä»ä¸‹å•åˆ°æˆäº¤çš„å…¨æµç¨‹è·Ÿè¸ª
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡è®¢å•å¤„ç†å’Œå¹¶å‘æ‰§è¡Œ

### 1.2 è®¾è®¡åŸåˆ™
- **äº‹ä»¶é©±åŠ¨**ï¼šå“åº”è¿æ¥æ¨¡å—çš„æ¨é€å¼æ•°æ®æµ
- **é£é™©ä¼˜å…ˆ**ï¼šæ‰€æœ‰äº¤æ˜“æ“ä½œéƒ½ç»è¿‡é£é™©æ£€æŸ¥
- **åŸå­æ“ä½œ**ï¼šç¡®ä¿è®¢å•æ“ä½œçš„ä¸€è‡´æ€§
- **æ•…éšœéš”ç¦»**ï¼šå•ä¸ªäº¤æ˜“æ‰€æ•…éšœä¸å½±å“å…¶ä»–äº¤æ˜“æ‰€
- **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„æ‰§è¡Œé“¾è·¯è¿½è¸ª
- **Traitç»Ÿä¸€**ï¼šæ‰€æœ‰æ‰§è¡Œå™¨å®ç° `OrderExecutor` traitï¼Œé£é™©ç®¡ç†å™¨å®ç° `RiskManager` trait

### 1.3 æ—§ä»£ç æ›¿æ¢è§„åˆ’

#### 1.3.1 ç°æœ‰ä»£ç ç»“æ„åˆ†æ
```
å½“å‰æ‰§è¡Œç›¸å…³ä»£ç åˆ†æ•£åœ¨ï¼š
src/cross_exchange.rs        -> é‡æ„ä¸º src/executors/arbitrage_executor.rs
src/core.rs                  -> éƒ¨åˆ†é€»è¾‘è¿ç§»åˆ° src/executors/order_executor.rs
src/exchange_types.rs        -> è¿ç§»åˆ° src/types/orders.rs å’Œ src/types/exchange.rs
src/utils.rs                 -> éƒ¨åˆ†å·¥å…·å‡½æ•°è¿ç§»åˆ° src/executors/utils.rs
```

#### 1.3.2 è¿ç§»ç­–ç•¥
1. **ä¿ç•™æ—§ä»£ç **ï¼šå°†ç°æœ‰æ‰§è¡Œç›¸å…³ä»£ç é‡å‘½åä¸º `legacy_*` å‰ç¼€
2. **åˆ›å»ºæ–°ç»“æ„**ï¼šæŒ‰ç…§æ–°çš„ç›®å½•ç»“æ„åˆ›å»ºæ‰§è¡Œå™¨æ¨¡å—
3. **é€æ­¥è¿ç§»**ï¼šæ¯ä¸ªæ‰§è¡Œå™¨å•ç‹¬è¿ç§»ï¼Œç¡®ä¿ç¼–è¯‘é€šè¿‡
4. **é€‚é…å™¨æ¨¡å¼**ï¼šä¸ºæ—§ä»£ç åˆ›å»ºé€‚é…å™¨ï¼Œå®ç°æ–°çš„ trait æ¥å£
5. **æ¸è¿›æ›¿æ¢**ï¼šæ–°åŠŸèƒ½ä½¿ç”¨æ–°æ¥å£ï¼Œæ—§åŠŸèƒ½ä¿æŒå…¼å®¹

## 2. æ¶æ„è®¾è®¡

### 2.1 æ ¸å¿ƒ Trait å®šä¹‰

**æ‰€æœ‰æ ¸å¿ƒ trait å®šä¹‰å·²ç»Ÿä¸€åˆ° `CrossFury_æ ¸å¿ƒTraitå®šä¹‰.md`ï¼Œæœ¬æ¨¡å—ä¸¥æ ¼å®ç°ä»¥ä¸‹ traitï¼š**

- **`OrderExecutor`**ï¼šè®¢å•æ‰§è¡Œå™¨æ¥å£ï¼Œè´Ÿè´£è®¢å•è·¯ç”±ã€æ‰§è¡Œã€å–æ¶ˆç­‰æ“ä½œ
- **`RiskManager`**ï¼šé£é™©ç®¡ç†å™¨æ¥å£ï¼Œè´Ÿè´£é£é™©æ£€æŸ¥ã€é™åˆ¶è®¾ç½®ã€ç´§æ€¥æ“ä½œç­‰
- **`PositionManager`**ï¼šä»“ä½ç®¡ç†å™¨æ¥å£ï¼Œè´Ÿè´£å¤šäº¤æ˜“æ‰€ä»“ä½è·Ÿè¸ªå’Œç®¡ç†
- **`OrderRouter`**ï¼šè®¢å•è·¯ç”±å™¨æ¥å£ï¼Œè´Ÿè´£æ™ºèƒ½é€‰æ‹©æœ€ä¼˜æ‰§è¡Œäº¤æ˜“æ‰€

### 2.2 æ ¸å¿ƒ Trait å®ç°è¦æ±‚

#### OrderExecutor å®ç°è¦æ±‚
- æ”¯æŒå•ç¬”å’Œæ‰¹é‡è®¢å•æ‰§è¡Œ
- å®ç°æ™ºèƒ½è®¢å•è·¯ç”±ç®—æ³•
- æä¾›è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†
- é›†æˆé£é™©æ£€æŸ¥æœºåˆ¶
- æ”¯æŒå¼‚æ­¥æ‰§è¡Œå’Œäº‹ä»¶æ¨é€

#### RiskManager å®ç°è¦æ±‚
- å®ç°å¤šå±‚çº§é£é™©æ£€æŸ¥ï¼ˆè®¢å•çº§ã€ä»“ä½çº§ã€ç»„åˆçº§ï¼‰
- æ”¯æŒåŠ¨æ€é£é™©é™åˆ¶è®¾ç½®
- æä¾›å®æ—¶é£é™©ç›‘æ§
- æ”¯æŒç´§æ€¥åœæ­¢å’Œå¼ºåˆ¶å¹³ä»“
- åŒºåˆ†ç°è´§å’ŒæœŸè´§é£é™©ç­–ç•¥

#### PositionManager å®ç°è¦æ±‚
- ç»Ÿä¸€ç®¡ç†å¤šäº¤æ˜“æ‰€ä»“ä½
- å®æ—¶åŒæ­¥ä»“ä½å˜åŒ–
- æ”¯æŒä»“ä½èšåˆå’Œåˆ†æ‹†
- æä¾›ä»“ä½é£é™©è¯„ä¼°

#### OrderRouter å®ç°è¦æ±‚
- åŸºäºæµåŠ¨æ€§ã€æ‰‹ç»­è´¹ã€å»¶è¿Ÿç­‰å› ç´ é€‰æ‹©äº¤æ˜“æ‰€
- æ”¯æŒè´Ÿè½½å‡è¡¡å’Œæ•…éšœè½¬ç§»
- å®ç°åŠ¨æ€è·¯ç”±ç­–ç•¥è°ƒæ•´

### 2.3 æ”¯æŒçš„äº¤æ˜“æ‰€å’Œå¸‚åœºç±»å‹

#### ç°è´§äº¤æ˜“æ‰€
- **ä¸»æµäº¤æ˜“æ‰€**ï¼šBinanceã€OKXã€Bybitã€Gate.ioã€KuCoinã€Huobi
- **æ–°å¢äº¤æ˜“æ‰€**ï¼šLBankã€XTComã€TapBitã€HBitã€BatonExã€CoinCatch
- **ç‰¹æ®Šæ”¯æŒ**ï¼šæ¯ä¸ªäº¤æ˜“æ‰€çš„ç‰¹å®šè®¢å•ç±»å‹å’Œæ‰§è¡Œè§„åˆ™

#### æœŸè´§äº¤æ˜“æ‰€
- **ä¸»æµæœŸè´§**ï¼šBinance Futuresã€OKX Futuresã€Bybit Futures
- **æ‰§è¡Œç‰¹æ€§**ï¼šä¿è¯é‡‘ç®¡ç†ã€å¼ºåˆ¶å¹³ä»“ã€èµ„é‡‘è´¹ç‡å¤„ç†

### 2.4 æ—§ä»£ç é€‚é…å™¨å®ç°

```rust
// src/executors/legacy_adapter.rs
use crate::legacy_cross_exchange::CrossExchangeArbitrage;
use crate::traits::{OrderExecutor, RiskManager};

/// æ—§ä»£ç é€‚é…å™¨ï¼Œå°†ç°æœ‰æ‰§è¡Œé€»è¾‘åŒ…è£…ä¸ºæ–°çš„ trait æ¥å£
pub struct LegacyExecutorAdapter {
    legacy_arbitrage: CrossExchangeArbitrage,
}

#[async_trait]
impl OrderExecutor for LegacyExecutorAdapter {
    async fn execute_order(&self, order: OrderRequest) -> Result<ExecutionResult, ExecutionError> {
        // å°†æ–°çš„ OrderRequest è½¬æ¢ä¸ºæ—§çš„æ ¼å¼
        let legacy_order = self.convert_to_legacy_order(order)?;
        
        // è°ƒç”¨æ—§çš„æ‰§è¡Œé€»è¾‘
        let legacy_result = self.legacy_arbitrage.execute_order(legacy_order).await?;
        
        // å°†æ—§çš„ç»“æœè½¬æ¢ä¸ºæ–°çš„æ ¼å¼
        self.convert_to_new_result(legacy_result)
    }
    
    // å…¶ä»–æ–¹æ³•çš„é€‚é…å®ç°...
}
```

### 2.2 è®¢å•æ‰§è¡Œå™¨å®ç°

```rust
// src/executors/order_executor.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use crate::connectors::{ConnectorManager, ExchangeType, MarketType};
use crate::executors::traits::*;
use crate::executors::risk_manager::RiskManager;
use crate::executors::position_manager::PositionManager;
use crate::executors::routing::OrderRouter;

pub struct OrderExecutorImpl {
    connector_manager: Arc<ConnectorManager>,
    risk_manager: Arc<dyn RiskManager>,
    position_manager: Arc<PositionManager>,
    order_router: Arc<OrderRouter>,
    
    // è®¢å•è·Ÿè¸ª
    active_orders: Arc<RwLock<HashMap<String, TrackedOrder>>>,
    execution_history: Arc<Mutex<Vec<ExecutionRecord>>>,
    
    // æ€§èƒ½ä¼˜åŒ–
    batch_processor: BatchProcessor,
    execution_metrics: Arc<ExecutionMetrics>,
}

#[derive(Debug, Clone)]
pub struct TrackedOrder {
    pub order_id: String,
    pub client_order_id: String,
    pub exchange: ExchangeType,
    pub symbol: String,
    pub order_type: OrderType,
    pub side: OrderSide,
    pub quantity: Decimal,
    pub price: Option<Decimal>,
    pub status: OrderStatus,
    pub filled_quantity: Decimal,
    pub average_price: Option<Decimal>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub execution_records: Vec<ExecutionRecord>,
}

#[derive(Debug, Clone)]
pub struct ExecutionResult {
    pub order_id: String,
    pub client_order_id: String,
    pub exchange: ExchangeType,
    pub status: OrderStatus,
    pub filled_quantity: Decimal,
    pub remaining_quantity: Decimal,
    pub average_price: Option<Decimal>,
    pub commission: Option<Decimal>,
    pub execution_time: DateTime<Utc>,
}

impl OrderExecutorImpl {
    pub fn new(
        connector_manager: Arc<ConnectorManager>,
        risk_manager: Arc<dyn RiskManager>,
        position_manager: Arc<PositionManager>,
    ) -> Self {
        Self {
            connector_manager: connector_manager.clone(),
            risk_manager,
            position_manager,
            order_router: Arc::new(OrderRouter::new(connector_manager)),
            active_orders: Arc::new(RwLock::new(HashMap::new())),
            execution_history: Arc::new(Mutex::new(Vec::new())),
            batch_processor: BatchProcessor::new(),
            execution_metrics: Arc::new(ExecutionMetrics::new()),
        }
    }
    
    // ğŸ”¥ æ™ºèƒ½è®¢å•è·¯ç”±ï¼ˆæ ¸å¿ƒæ”¹è¿›ï¼‰
    async fn route_order(&self, order: &OrderRequest) -> Result<ExchangeType, ExecutionError> {
        // 1. æ ¹æ®å¸‚åœºç±»å‹è¿‡æ»¤å¯ç”¨äº¤æ˜“æ‰€
        let available_exchanges = self.order_router.get_available_exchanges(
            &order.symbol, 
            order.market_type
        ).await?;
        
        if available_exchanges.is_empty() {
            return Err(ExecutionError::NoAvailableExchange(order.symbol.clone()));
        }
        
        // 2. æ ¹æ®è®¢å•ç±»å‹é€‰æ‹©æœ€ä¼˜äº¤æ˜“æ‰€
        match order.order_type {
            OrderType::Market => {
                // å¸‚ä»·å•ï¼šé€‰æ‹©æµåŠ¨æ€§æœ€å¥½çš„äº¤æ˜“æ‰€
                self.order_router.select_best_liquidity_exchange(
                    &available_exchanges,
                    &order.symbol,
                    order.side,
                    order.quantity
                ).await
            }
            OrderType::Limit => {
                // é™ä»·å•ï¼šé€‰æ‹©æ‰‹ç»­è´¹æœ€ä½çš„äº¤æ˜“æ‰€
                self.order_router.select_lowest_fee_exchange(
                    &available_exchanges,
                    &order.symbol,
                    order.market_type
                ).await
            }
            OrderType::StopLoss | OrderType::TakeProfit => {
                // æ­¢æŸ/æ­¢ç›ˆå•ï¼šé€‰æ‹©æ‰§è¡Œæœ€å¯é çš„äº¤æ˜“æ‰€
                self.order_router.select_most_reliable_exchange(
                    &available_exchanges,
                    &order.symbol
                ).await
            }
        }
    }
    
    // ğŸ”¥ é£é™©æ£€æŸ¥é›†æˆ
    async fn perform_risk_checks(&self, order: &OrderRequest) -> Result<(), ExecutionError> {
        // 1. è®¢å•çº§é£é™©æ£€æŸ¥
        let order_risk = self.risk_manager.check_order_risk(order).await
            .map_err(|e| ExecutionError::RiskCheckFailed(e.to_string()))?;
        
        if !order_risk.passed {
            return Err(ExecutionError::RiskViolation(order_risk.violations));
        }
        
        // 2. ä»“ä½çº§é£é™©æ£€æŸ¥
        let target_exchange = self.route_order(order).await?;
        let position_risk = self.risk_manager.check_position_risk(&order.symbol, target_exchange).await
            .map_err(|e| ExecutionError::RiskCheckFailed(e.to_string()))?;
        
        if !position_risk.passed {
            return Err(ExecutionError::PositionRiskViolation(position_risk.violations));
        }
        
        // 3. ç»„åˆçº§é£é™©æ£€æŸ¥
        let portfolio_risk = self.risk_manager.check_portfolio_risk().await
            .map_err(|e| ExecutionError::RiskCheckFailed(e.to_string()))?;
        
        if !portfolio_risk.passed {
            return Err(ExecutionError::PortfolioRiskViolation(portfolio_risk.violations));
        }
        
        Ok(())
    }
}

#[async_trait]
impl OrderExecutor for OrderExecutorImpl {
    async fn execute_order(&self, mut order: OrderRequest) -> Result<ExecutionResult, ExecutionError> {
        let start_time = Instant::now();
        
        // 1. ç”Ÿæˆå®¢æˆ·ç«¯è®¢å•ID
        order.client_order_id = Some(generate_client_order_id());
        
        // 2. é£é™©æ£€æŸ¥
        self.perform_risk_checks(&order).await?;
        
        // 3. æ™ºèƒ½è·¯ç”±
        let target_exchange = self.route_order(&order).await?;
        
        // 4. æ‰§è¡Œè®¢å•
        let order_response = self.connector_manager
            .place_order(&target_exchange.to_string(), &order)
            .await
            .map_err(|e| ExecutionError::OrderPlacementFailed(e.to_string()))?;
        
        // 5. åˆ›å»ºè·Ÿè¸ªè®°å½•
        let tracked_order = TrackedOrder {
            order_id: order_response.order_id.clone(),
            client_order_id: order.client_order_id.unwrap(),
            exchange: target_exchange,
            symbol: order.symbol.clone(),
            order_type: order.order_type,
            side: order.side,
            quantity: order.quantity,
            price: order.price,
            status: order_response.status.clone(),
            filled_quantity: order_response.filled_quantity,
            average_price: order_response.average_price,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            execution_records: Vec::new(),
        };
        
        // 6. æ›´æ–°è®¢å•è·Ÿè¸ª
        {
            let mut active_orders = self.active_orders.write().await;
            active_orders.insert(order_response.order_id.clone(), tracked_order);
        }
        
        // 7. æ›´æ–°ä»“ä½ï¼ˆå¦‚æœæœ‰æˆäº¤ï¼‰
        if order_response.filled_quantity > Decimal::ZERO {
            self.position_manager.update_position(
                &order.symbol,
                target_exchange,
                order.side,
                order_response.filled_quantity,
                order_response.average_price.unwrap_or(order.price.unwrap_or_default())
            ).await?;
        }
        
        // 8. è®°å½•æ‰§è¡ŒæŒ‡æ ‡
        let execution_time = start_time.elapsed();
        self.execution_metrics.record_execution(
            target_exchange,
            order.order_type,
            execution_time,
            order_response.status == OrderStatus::Filled
        ).await;
        
        // 9. æ„é€ æ‰§è¡Œç»“æœ
        Ok(ExecutionResult {
            order_id: order_response.order_id,
            client_order_id: order.client_order_id.unwrap(),
            exchange: target_exchange,
            status: order_response.status,
            filled_quantity: order_response.filled_quantity,
            remaining_quantity: order.quantity - order_response.filled_quantity,
            average_price: order_response.average_price,
            commission: order_response.commission,
            execution_time: Utc::now(),
        })
    }
    
    // ğŸ”¥ æ‰¹é‡è®¢å•å¤„ç†ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
    async fn execute_batch_orders(&self, orders: Vec<OrderRequest>) -> Vec<Result<ExecutionResult, ExecutionError>> {
        // æŒ‰äº¤æ˜“æ‰€åˆ†ç»„
        let mut orders_by_exchange: HashMap<ExchangeType, Vec<OrderRequest>> = HashMap::new();
        
        for order in orders {
            // é¢„å…ˆè¿›è¡Œè·¯ç”±å†³ç­–
            match self.route_order(&order).await {
                Ok(exchange) => {
                    orders_by_exchange.entry(exchange).or_insert_with(Vec::new).push(order);
                }
                Err(e) => {
                    // è®°å½•è·¯ç”±å¤±è´¥çš„è®¢å•
                    continue;
                }
            }
        }
        
        // å¹¶å‘æ‰§è¡Œå„äº¤æ˜“æ‰€çš„è®¢å•
        let mut tasks = Vec::new();
        for (exchange, exchange_orders) in orders_by_exchange {
            let executor = self.clone();
            let task = tokio::spawn(async move {
                let mut results = Vec::new();
                for order in exchange_orders {
                    let result = executor.execute_order(order).await;
                    results.push(result);
                }
                results
            });
            tasks.push(task);
        }
        
        // æ”¶é›†æ‰€æœ‰ç»“æœ
        let mut all_results = Vec::new();
        for task in tasks {
            if let Ok(results) = task.await {
                all_results.extend(results);
            }
        }
        
        all_results
    }
    
    async fn cancel_order(&self, order_id: &str, exchange: ExchangeType) -> Result<bool, ExecutionError> {
        // 1. æŸ¥æ‰¾è®¢å•ä¿¡æ¯
        let tracked_order = {
            let active_orders = self.active_orders.read().await;
            active_orders.get(order_id).cloned()
        };
        
        let tracked_order = tracked_order.ok_or_else(|| 
            ExecutionError::OrderNotFound(order_id.to_string())
        )?;
        
        // 2. æ‰§è¡Œæ’¤å•
        let cancel_result = self.connector_manager
            .cancel_order(&exchange.to_string(), order_id, &tracked_order.symbol)
            .await
            .map_err(|e| ExecutionError::OrderCancellationFailed(e.to_string()))?;
        
        // 3. æ›´æ–°è®¢å•çŠ¶æ€
        if cancel_result {
            let mut active_orders = self.active_orders.write().await;
            if let Some(order) = active_orders.get_mut(order_id) {
                order.status = OrderStatus::Cancelled;
                order.updated_at = Utc::now();
            }
        }
        
        Ok(cancel_result)
    }
    
    // å…¶ä»–æ–¹æ³•å®ç°...
}
```

### 2.3 æ™ºèƒ½è®¢å•è·¯ç”±å™¨

```rust
// src/executors/routing/order_router.rs
use std::collections::HashMap;
use std::sync::Arc;
use crate::connectors::{ConnectorManager, ExchangeType, MarketType};
use crate::types::*;

pub struct OrderRouter {
    connector_manager: Arc<ConnectorManager>,
    exchange_metrics: Arc<ExchangeMetrics>,
    liquidity_analyzer: LiquidityAnalyzer,
    fee_calculator: FeeCalculator,
}

#[derive(Debug, Clone)]
pub struct ExchangeScore {
    pub exchange: ExchangeType,
    pub liquidity_score: f64,
    pub fee_score: f64,
    pub reliability_score: f64,
    pub latency_score: f64,
    pub total_score: f64,
}

impl OrderRouter {
    pub fn new(connector_manager: Arc<ConnectorManager>) -> Self {
        Self {
            connector_manager,
            exchange_metrics: Arc::new(ExchangeMetrics::new()),
            liquidity_analyzer: LiquidityAnalyzer::new(),
            fee_calculator: FeeCalculator::new(),
        }
    }
    
    // ğŸ”¥ è·å–å¯ç”¨äº¤æ˜“æ‰€ï¼ˆæ”¯æŒç°è´§+æœŸè´§ï¼‰
    pub async fn get_available_exchanges(
        &self,
        symbol: &str,
        market_type: MarketType
    ) -> Result<Vec<ExchangeType>, RoutingError> {
        let mut available = Vec::new();
        
        // æ£€æŸ¥å„äº¤æ˜“æ‰€çš„è¿æ¥çŠ¶æ€å’Œäº¤æ˜“å¯¹æ”¯æŒ
        for exchange in [ExchangeType::Binance, ExchangeType::Bybit, ExchangeType::Okx] {
            // æ£€æŸ¥è¿æ¥çŠ¶æ€
            if !self.connector_manager.is_exchange_connected(&exchange.to_string()).await {
                continue;
            }
            
            // æ£€æŸ¥äº¤æ˜“å¯¹æ”¯æŒ
            if self.connector_manager.supports_symbol(&exchange.to_string(), symbol, market_type).await? {
                available.push(exchange);
            }
        }
        
        Ok(available)
    }
    
    // ğŸ”¥ é€‰æ‹©æœ€ä½³æµåŠ¨æ€§äº¤æ˜“æ‰€ï¼ˆå¸‚ä»·å•ä¼˜åŒ–ï¼‰
    pub async fn select_best_liquidity_exchange(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str,
        side: OrderSide,
        quantity: Decimal
    ) -> Result<ExchangeType, RoutingError> {
        let mut best_exchange = None;
        let mut best_liquidity_score = 0.0;
        
        for &exchange in available_exchanges {
            // è·å–è®¢å•ç°¿å¿«ç…§
            let orderbook = self.connector_manager
                .get_orderbook_snapshot(&exchange.to_string(), symbol)
                .await?;
            
            // è®¡ç®—æµåŠ¨æ€§å¾—åˆ†
            let liquidity_score = self.liquidity_analyzer.calculate_liquidity_score(
                &orderbook,
                side,
                quantity
            );
            
            if liquidity_score > best_liquidity_score {
                best_liquidity_score = liquidity_score;
                best_exchange = Some(exchange);
            }
        }
        
        best_exchange.ok_or(RoutingError::NoSuitableExchange)
    }
    
    // ğŸ”¥ é€‰æ‹©æœ€ä½æ‰‹ç»­è´¹äº¤æ˜“æ‰€ï¼ˆé™ä»·å•ä¼˜åŒ–ï¼‰
    pub async fn select_lowest_fee_exchange(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str,
        market_type: MarketType
    ) -> Result<ExchangeType, RoutingError> {
        let mut best_exchange = None;
        let mut lowest_fee = Decimal::MAX;
        
        for &exchange in available_exchanges {
            let fee = self.fee_calculator.get_trading_fee(exchange, symbol, market_type).await?;
            
            if fee < lowest_fee {
                lowest_fee = fee;
                best_exchange = Some(exchange);
            }
        }
        
        best_exchange.ok_or(RoutingError::NoSuitableExchange)
    }
    
    // ğŸ”¥ é€‰æ‹©æœ€å¯é äº¤æ˜“æ‰€ï¼ˆæ­¢æŸå•ä¼˜åŒ–ï¼‰
    pub async fn select_most_reliable_exchange(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str
    ) -> Result<ExchangeType, RoutingError> {
        let mut best_exchange = None;
        let mut highest_reliability = 0.0;
        
        for &exchange in available_exchanges {
            let reliability = self.exchange_metrics.get_reliability_score(exchange).await;
            
            if reliability > highest_reliability {
                highest_reliability = reliability;
                best_exchange = Some(exchange);
            }
        }
        
        best_exchange.ok_or(RoutingError::NoSuitableExchange)
    }
    
    // ğŸ”¥ ç»¼åˆè¯„åˆ†é€‰æ‹©ï¼ˆå¤æ‚ç­–ç•¥ï¼‰
    pub async fn select_best_exchange_comprehensive(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str,
        order: &OrderRequest,
        weights: &RoutingWeights
    ) -> Result<ExchangeType, RoutingError> {
        let mut exchange_scores = Vec::new();
        
        for &exchange in available_exchanges {
            let score = self.calculate_exchange_score(exchange, symbol, order, weights).await?;
            exchange_scores.push(score);
        }
        
        // æŒ‰æ€»åˆ†æ’åº
        exchange_scores.sort_by(|a, b| b.total_score.partial_cmp(&a.total_score).unwrap());
        
        exchange_scores.first()
            .map(|score| score.exchange)
            .ok_or(RoutingError::NoSuitableExchange)
    }
    
    async fn calculate_exchange_score(
        &self,
        exchange: ExchangeType,
        symbol: &str,
        order: &OrderRequest,
        weights: &RoutingWeights
    ) -> Result<ExchangeScore, RoutingError> {
        // 1. æµåŠ¨æ€§å¾—åˆ†
        let orderbook = self.connector_manager
            .get_orderbook_snapshot(&exchange.to_string(), symbol)
            .await?;
        let liquidity_score = self.liquidity_analyzer.calculate_liquidity_score(
            &orderbook,
            order.side,
            order.quantity
        );
        
        // 2. æ‰‹ç»­è´¹å¾—åˆ†
        let fee = self.fee_calculator.get_trading_fee(exchange, symbol, order.market_type).await?;
        let fee_score = self.calculate_fee_score(fee);
        
        // 3. å¯é æ€§å¾—åˆ†
        let reliability_score = self.exchange_metrics.get_reliability_score(exchange).await;
        
        // 4. å»¶è¿Ÿå¾—åˆ†
        let latency_score = self.exchange_metrics.get_latency_score(exchange).await;
        
        // 5. è®¡ç®—åŠ æƒæ€»åˆ†
        let total_score = 
            liquidity_score * weights.liquidity +
            fee_score * weights.fee +
            reliability_score * weights.reliability +
            latency_score * weights.latency;
        
        Ok(ExchangeScore {
            exchange,
            liquidity_score,
            fee_score,
            reliability_score,
            latency_score,
            total_score,
        })
    }
}

#[derive(Debug, Clone)]
pub struct RoutingWeights {
    pub liquidity: f64,
    pub fee: f64,
    pub reliability: f64,
    pub latency: f64,
}

impl Default for RoutingWeights {
    fn default() -> Self {
        Self {
            liquidity: 0.4,
            fee: 0.3,
            reliability: 0.2,
            latency: 0.1,
        }
    }
}
```

## 3. é£é™©ç®¡ç†ç³»ç»Ÿ

### 3.1 å·®å¼‚åŒ–é£æ§ç­–ç•¥

```rust
// src/executors/risk_manager/mod.rs
use async_trait::async_trait;
use crate::types::*;
use crate::connectors::{ExchangeType, MarketType};

pub struct RiskManagerImpl {
    spot_risk_manager: SpotRiskManager,
    futures_risk_manager: FuturesRiskManager,
    portfolio_risk_manager: PortfolioRiskManager,
    risk_config: RiskConfig,
}

#[derive(Debug, Clone)]
pub struct RiskConfig {
    pub spot_config: SpotRiskConfig,
    pub futures_config: FuturesRiskConfig,
    pub portfolio_config: PortfolioRiskConfig,
}

// ğŸ”¥ ç°è´§é£æ§é…ç½®
#[derive(Debug, Clone)]
pub struct SpotRiskConfig {
    pub max_position_value: Decimal,           // å•å¸ç§æœ€å¤§æŒä»“ä»·å€¼
    pub max_order_value: Decimal,              // å•ç¬”è®¢å•æœ€å¤§ä»·å€¼
    pub max_daily_trading_volume: Decimal,     // æ—¥æœ€å¤§äº¤æ˜“é‡
    pub min_account_balance_ratio: Decimal,    // æœ€å°è´¦æˆ·ä½™é¢æ¯”ä¾‹
    pub max_concentration_ratio: Decimal,      // æœ€å¤§é›†ä¸­åº¦æ¯”ä¾‹
    pub blacklisted_symbols: Vec<String>,      // é»‘åå•äº¤æ˜“å¯¹
}

// ğŸ”¥ æœŸè´§é£æ§é…ç½®
#[derive(Debug, Clone)]
pub struct FuturesRiskConfig {
    pub max_leverage: Decimal,                 // æœ€å¤§æ æ†å€æ•°
    pub max_position_value: Decimal,           // å•åˆçº¦æœ€å¤§æŒä»“ä»·å€¼
    pub max_order_value: Decimal,              // å•ç¬”è®¢å•æœ€å¤§ä»·å€¼
    pub min_margin_ratio: Decimal,             // æœ€å°ä¿è¯é‡‘æ¯”ä¾‹
    pub max_funding_rate: Decimal,             // æœ€å¤§èµ„é‡‘è´¹ç‡é˜ˆå€¼
    pub liquidation_buffer: Decimal,           // å¼ºå¹³ç¼“å†²åŒº
    pub max_daily_loss: Decimal,               // æ—¥æœ€å¤§äºæŸ
    pub position_size_limits: HashMap<String, Decimal>, // åˆçº¦æŒä»“é™åˆ¶
}

#[derive(Debug, Clone)]
pub struct PortfolioRiskConfig {
    pub max_total_exposure: Decimal,           // æœ€å¤§æ€»æ•å£
    pub max_correlation_exposure: Decimal,     // æœ€å¤§ç›¸å…³æ€§æ•å£
    pub max_drawdown: Decimal,                 // æœ€å¤§å›æ’¤
    pub var_limit: Decimal,                    // VaRé™åˆ¶
    pub stress_test_scenarios: Vec<StressTestScenario>,
}

impl RiskManagerImpl {
    pub fn new(risk_config: RiskConfig) -> Self {
        Self {
            spot_risk_manager: SpotRiskManager::new(risk_config.spot_config.clone()),
            futures_risk_manager: FuturesRiskManager::new(risk_config.futures_config.clone()),
            portfolio_risk_manager: PortfolioRiskManager::new(risk_config.portfolio_config.clone()),
            risk_config,
        }
    }
}

#[async_trait]
impl RiskManager for RiskManagerImpl {
    async fn check_order_risk(&self, order: &OrderRequest) -> Result<RiskCheckResult, RiskError> {
        let mut violations = Vec::new();
        
        // æ ¹æ®å¸‚åœºç±»å‹é€‰æ‹©ç›¸åº”çš„é£æ§ç­–ç•¥
        match order.market_type {
            MarketType::Spot => {
                let spot_result = self.spot_risk_manager.check_order_risk(order).await?;
                violations.extend(spot_result.violations);
            }
            MarketType::Futures => {
                let futures_result = self.futures_risk_manager.check_order_risk(order).await?;
                violations.extend(futures_result.violations);
            }
        }
        
        // ç»„åˆçº§é£é™©æ£€æŸ¥
        let portfolio_result = self.portfolio_risk_manager.check_order_impact(order).await?;
        violations.extend(portfolio_result.violations);
        
        Ok(RiskCheckResult {
            passed: violations.is_empty(),
            violations,
            risk_score: self.calculate_risk_score(&violations),
        })
    }
    
    async fn check_position_risk(&self, symbol: &str, exchange: ExchangeType) -> Result<PositionRiskResult, RiskError> {
        // è·å–å½“å‰ä»“ä½
        let position = self.get_position(symbol, exchange).await?;
        
        let mut violations = Vec::new();
        
        match position.market_type {
            MarketType::Spot => {
                let spot_result = self.spot_risk_manager.check_position_risk(&position).await?;
                violations.extend(spot_result.violations);
            }
            MarketType::Futures => {
                let futures_result = self.futures_risk_manager.check_position_risk(&position).await?;
                violations.extend(futures_result.violations);
            }
        }
        
        Ok(PositionRiskResult {
            passed: violations.is_empty(),
            violations,
            position_risk_metrics: self.calculate_position_risk_metrics(&position).await?,
        })
    }
    
    async fn check_portfolio_risk(&self) -> Result<PortfolioRiskResult, RiskError> {
        self.portfolio_risk_manager.check_portfolio_risk().await
    }
}
```

### 3.2 ç°è´§é£æ§ç®¡ç†å™¨

```rust
// src/executors/risk_manager/spot_risk_manager.rs
pub struct SpotRiskManager {
    config: SpotRiskConfig,
    position_tracker: Arc<PositionTracker>,
    balance_monitor: Arc<BalanceMonitor>,
}

impl SpotRiskManager {
    pub async fn check_order_risk(&self, order: &OrderRequest) -> Result<RiskCheckResult, RiskError> {
        let mut violations = Vec::new();
        
        // 1. æ£€æŸ¥è®¢å•ä»·å€¼é™åˆ¶
        let order_value = self.calculate_order_value(order).await?;
        if order_value > self.config.max_order_value {
            violations.push(RiskViolation::OrderValueExceeded {
                current: order_value,
                limit: self.config.max_order_value,
            });
        }
        
        // 2. æ£€æŸ¥è´¦æˆ·ä½™é¢
        let account_balance = self.balance_monitor.get_available_balance(&order.symbol).await?;
        let required_balance = match order.side {
            OrderSide::Buy => order_value,
            OrderSide::Sell => order.quantity,
        };
        
        if account_balance < required_balance {
            violations.push(RiskViolation::InsufficientBalance {
                required: required_balance,
                available: account_balance,
            });
        }
        
        // 3. æ£€æŸ¥æŒä»“é›†ä¸­åº¦
        let current_position_value = self.position_tracker.get_position_value(&order.symbol).await?;
        let new_position_value = match order.side {
            OrderSide::Buy => current_position_value + order_value,
            OrderSide::Sell => current_position_value - order_value,
        };
        
        if new_position_value > self.config.max_position_value {
            violations.push(RiskViolation::PositionValueExceeded {
                symbol: order.symbol.clone(),
                current: new_position_value,
                limit: self.config.max_position_value,
            });
        }
        
        // 4. æ£€æŸ¥é»‘åå•
        if self.config.blacklisted_symbols.contains(&order.symbol) {
            violations.push(RiskViolation::BlacklistedSymbol {
                symbol: order.symbol.clone(),
            });
        }
        
        // 5. æ£€æŸ¥æ—¥äº¤æ˜“é‡é™åˆ¶
        let daily_volume = self.get_daily_trading_volume(&order.symbol).await?;
        if daily_volume + order_value > self.config.max_daily_trading_volume {
            violations.push(RiskViolation::DailyVolumeExceeded {
                current: daily_volume + order_value,
                limit: self.config.max_daily_trading_volume,
            });
        }
        
        Ok(RiskCheckResult {
            passed: violations.is_empty(),
            violations,
            risk_score: self.calculate_spot_risk_score(&violations),
        })
    }
}
```

### 3.3 æœŸè´§é£æ§ç®¡ç†å™¨

```rust
// src/executors/risk_manager/futures_risk_manager.rs
pub struct FuturesRiskManager {
    config: FuturesRiskConfig,
    position_tracker: Arc<PositionTracker>,
    margin_calculator: Arc<MarginCalculator>,
    funding_rate_monitor: Arc<FundingRateMonitor>,
}

impl FuturesRiskManager {
    pub async fn check_order_risk(&self, order: &OrderRequest) -> Result<RiskCheckResult, RiskError> {
        let mut violations = Vec::new();
        
        // 1. æ£€æŸ¥æ æ†é™åˆ¶
        if let Some(leverage) = order.leverage {
            if leverage > self.config.max_leverage {
                violations.push(RiskViolation::LeverageExceeded {
                    current: leverage,
                    limit: self.config.max_leverage,
                });
            }
        }
        
        // 2. æ£€æŸ¥ä¿è¯é‡‘è¦æ±‚
        let required_margin = self.margin_calculator.calculate_required_margin(order).await?;
        let available_margin = self.margin_calculator.get_available_margin().await?;
        
        if required_margin > available_margin {
            violations.push(RiskViolation::InsufficientMargin {
                required: required_margin,
                available: available_margin,
            });
        }
        
        // 3. æ£€æŸ¥å¼ºå¹³é£é™©
        let liquidation_price = self.margin_calculator.calculate_liquidation_price(order).await?;
        let current_price = self.get_current_price(&order.symbol).await?;
        let price_distance = (liquidation_price - current_price).abs() / current_price;
        
        if price_distance < self.config.liquidation_buffer {
            violations.push(RiskViolation::LiquidationRisk {
                symbol: order.symbol.clone(),
                liquidation_price,
                current_price,
                buffer: self.config.liquidation_buffer,
            });
        }
        
        // 4. æ£€æŸ¥èµ„é‡‘è´¹ç‡
        let funding_rate = self.funding_rate_monitor.get_current_funding_rate(&order.symbol).await?;
        if funding_rate.abs() > self.config.max_funding_rate {
            violations.push(RiskViolation::HighFundingRate {
                symbol: order.symbol.clone(),
                current_rate: funding_rate,
                limit: self.config.max_funding_rate,
            });
        }
        
        // 5. æ£€æŸ¥æŒä»“é™åˆ¶
        if let Some(&position_limit) = self.config.position_size_limits.get(&order.symbol) {
            let current_position = self.position_tracker.get_position_size(&order.symbol).await?;
            let new_position_size = match order.side {
                OrderSide::Buy => current_position + order.quantity,
                OrderSide::Sell => current_position - order.quantity,
            };
            
            if new_position_size.abs() > position_limit {
                violations.push(RiskViolation::PositionSizeExceeded {
                    symbol: order.symbol.clone(),
                    current: new_position_size.abs(),
                    limit: position_limit,
                });
            }
        }
        
        // 6. æ£€æŸ¥æ—¥äºæŸé™åˆ¶
        let daily_pnl = self.get_daily_pnl().await?;
        if daily_pnl < -self.config.max_daily_loss {
            violations.push(RiskViolation::DailyLossExceeded {
                current_loss: daily_pnl.abs(),
                limit: self.config.max_daily_loss,
            });
        }
        
        Ok(RiskCheckResult {
            passed: violations.is_empty(),
            violations,
            risk_score: self.calculate_futures_risk_score(&violations),
        })
    }
}
```

## 4. å¥—åˆ©æ‰§è¡Œå¼•æ“

### 4.1 å¥—åˆ©å¼•æ“è®¾è®¡

```rust
// src/executors/arbitrage/arbitrage_engine.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::executors::traits::OrderExecutor;
use crate::connectors::{ExchangeType, MarketType};
use crate::types::*;

#[derive(Debug, Clone)]
pub enum ArbitrageOpportunity {
    // ç°è´§å¥—åˆ©
    SpotArbitrage {
        symbol: String,
        buy_exchange: ExchangeType,
        sell_exchange: ExchangeType,
        buy_price: Decimal,
        sell_price: Decimal,
        profit_margin: Decimal,
        max_quantity: Decimal,
    },
    
    // æœŸè´§å¥—åˆ©
    FuturesArbitrage {
        symbol: String,
        buy_exchange: ExchangeType,
        sell_exchange: ExchangeType,
        buy_price: Decimal,
        sell_price: Decimal,
        profit_margin: Decimal,
        max_quantity: Decimal,
        expiry_date: Option<DateTime<Utc>>,
    },
    
    // è·¨å¸‚åœºå¥—åˆ©ï¼ˆç°è´§-æœŸè´§ï¼‰
    CrossMarketArbitrage {
        symbol: String,
        spot_exchange: ExchangeType,
        futures_exchange: ExchangeType,
        spot_price: Decimal,
        futures_price: Decimal,
        basis: Decimal,
        profit_margin: Decimal,
        max_quantity: Decimal,
    },
}

pub struct ArbitrageEngine {
    order_executor: Arc<dyn OrderExecutor>,
    opportunity_scanner: Arc<OpportunityScanner>,
    risk_manager: Arc<dyn RiskManager>,
    
    // å¥—åˆ©é…ç½®
    config: ArbitrageConfig,
    
    // æ´»è·ƒå¥—åˆ©è®¢å•è·Ÿè¸ª
    active_arbitrages: Arc<RwLock<HashMap<String, ActiveArbitrage>>>,
    
    // æ€§èƒ½æŒ‡æ ‡
    arbitrage_metrics: Arc<ArbitrageMetrics>,
}

#[derive(Debug, Clone)]
pub struct ArbitrageConfig {
    pub min_profit_threshold: Decimal,         // æœ€å°åˆ©æ¶¦é˜ˆå€¼
    pub max_position_size: Decimal,            // æœ€å¤§ä»“ä½å¤§å°
    pub execution_timeout: Duration,           // æ‰§è¡Œè¶…æ—¶æ—¶é—´
    pub partial_fill_threshold: Decimal,       // éƒ¨åˆ†æˆäº¤é˜ˆå€¼
    pub enabled_exchanges: Vec<ExchangeType>,  // å¯ç”¨çš„äº¤æ˜“æ‰€
    pub enabled_symbols: Vec<String>,          // å¯ç”¨çš„äº¤æ˜“å¯¹
    pub risk_limits: ArbitrageRiskLimits,
}

#[derive(Debug, Clone)]
pub struct ActiveArbitrage {
    pub id: String,
    pub opportunity: ArbitrageOpportunity,
    pub buy_order_id: Option<String>,
    pub sell_order_id: Option<String>,
    pub status: ArbitrageStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub execution_records: Vec<ArbitrageExecutionRecord>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ArbitrageStatus {
    Pending,
    Executing,
    PartiallyFilled,
    Completed,
    Failed,
    Cancelled,
}

impl ArbitrageEngine {
    pub fn new(
        order_executor: Arc<dyn OrderExecutor>,
        risk_manager: Arc<dyn RiskManager>,
        config: ArbitrageConfig,
    ) -> Self {
        Self {
            order_executor,
            opportunity_scanner: Arc::new(OpportunityScanner::new(config.clone())),
            risk_manager,
            config,
            active_arbitrages: Arc::new(RwLock::new(HashMap::new())),
            arbitrage_metrics: Arc::new(ArbitrageMetrics::new()),
        }
    }
    
    // ğŸ”¥ æ‰§è¡Œå¥—åˆ©æœºä¼š
    pub async fn execute_arbitrage(&self, opportunity: ArbitrageOpportunity) -> Result<String, ArbitrageError> {
        // 1. ç”Ÿæˆå¥—åˆ©ID
        let arbitrage_id = generate_arbitrage_id();
        
        // 2. é£é™©æ£€æŸ¥
        self.check_arbitrage_risk(&opportunity).await?;
        
        // 3. åˆ›å»ºæ´»è·ƒå¥—åˆ©è®°å½•
        let active_arbitrage = ActiveArbitrage {
            id: arbitrage_id.clone(),
            opportunity: opportunity.clone(),
            buy_order_id: None,
            sell_order_id: None,
            status: ArbitrageStatus::Pending,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            execution_records: Vec::new(),
        };
        
        {
            let mut active_arbitrages = self.active_arbitrages.write().await;
            active_arbitrages.insert(arbitrage_id.clone(), active_arbitrage);
        }
        
        // 4. æ‰§è¡Œå¥—åˆ©è®¢å•
        match opportunity {
            ArbitrageOpportunity::SpotArbitrage { .. } => {
                self.execute_spot_arbitrage(&arbitrage_id, &opportunity).await?
            }
            ArbitrageOpportunity::FuturesArbitrage { .. } => {
                self.execute_futures_arbitrage(&arbitrage_id, &opportunity).await?
            }
            ArbitrageOpportunity::CrossMarketArbitrage { .. } => {
                self.execute_cross_market_arbitrage(&arbitrage_id, &opportunity).await?
            }
        }
        
        Ok(arbitrage_id)
    }
    
    // ğŸ”¥ ç°è´§å¥—åˆ©æ‰§è¡Œ
    async fn execute_spot_arbitrage(
        &self,
        arbitrage_id: &str,
        opportunity: &ArbitrageOpportunity
    ) -> Result<(), ArbitrageError> {
        if let ArbitrageOpportunity::SpotArbitrage {
            symbol,
            buy_exchange,
            sell_exchange,
            buy_price,
            sell_price,
            max_quantity,
            ..
        } = opportunity {
            // è®¡ç®—æœ€ä¼˜æ‰§è¡Œæ•°é‡
            let execution_quantity = self.calculate_optimal_quantity(
                *max_quantity,
                *buy_price,
                *sell_price
            ).await?;
            
            // åˆ›å»ºä¹°å–è®¢å•
            let buy_order = OrderRequest {
                symbol: symbol.clone(),
                side: OrderSide::Buy,
                order_type: OrderType::Limit,
                quantity: execution_quantity,
                price: Some(*buy_price),
                market_type: MarketType::Spot,
                time_in_force: Some(TimeInForce::IOC), // ç«‹å³æˆäº¤æˆ–å–æ¶ˆ
                client_order_id: Some(format!("{}_buy", arbitrage_id)),
                ..Default::default()
            };
            
            let sell_order = OrderRequest {
                symbol: symbol.clone(),
                side: OrderSide::Sell,
                order_type: OrderType::Limit,
                quantity: execution_quantity,
                price: Some(*sell_price),
                market_type: MarketType::Spot,
                time_in_force: Some(TimeInForce::IOC),
                client_order_id: Some(format!("{}_sell", arbitrage_id)),
                ..Default::default()
            };
            
            // ğŸ”¥ å¹¶å‘æ‰§è¡ŒåŒè¾¹è®¢å•ï¼ˆå…³é”®ä¼˜åŒ–ï¼‰
            self.execute_dual_orders(arbitrage_id, buy_order, sell_order).await?
        } else {
            return Err(ArbitrageError::InvalidOpportunityType);
        }
        
        Ok(())
    }
    
    // ğŸ”¥ å¹¶å‘åŒè¾¹è®¢å•æ‰§è¡Œï¼ˆæ ¸å¿ƒæ–¹æ³•ï¼‰
    async fn execute_dual_orders(
        &self,
        arbitrage_id: &str,
        buy_order: OrderRequest,
        sell_order: OrderRequest
    ) -> Result<(), ArbitrageError> {
        // æ›´æ–°çŠ¶æ€ä¸ºæ‰§è¡Œä¸­
        self.update_arbitrage_status(arbitrage_id, ArbitrageStatus::Executing).await;
        
        // å¹¶å‘æ‰§è¡Œä¹°å–è®¢å•
        let (buy_result, sell_result) = tokio::join!(
            self.order_executor.execute_order(buy_order.clone()),
            self.order_executor.execute_order(sell_order.clone())
        );
        
        // å¤„ç†æ‰§è¡Œç»“æœ
        match (buy_result, sell_result) {
            (Ok(buy_execution), Ok(sell_execution)) => {
                // åŒè¾¹éƒ½æˆåŠŸ
                self.handle_successful_dual_execution(
                    arbitrage_id,
                    buy_execution,
                    sell_execution
                ).await?
            }
            (Ok(buy_execution), Err(sell_error)) => {
                // ä¹°å•æˆåŠŸï¼Œå–å•å¤±è´¥
                self.handle_partial_execution(
                    arbitrage_id,
                    Some(buy_execution),
                    None,
                    Some(sell_error)
                ).await?
            }
            (Err(buy_error), Ok(sell_execution)) => {
                // å–å•æˆåŠŸï¼Œä¹°å•å¤±è´¥
                self.handle_partial_execution(
                    arbitrage_id,
                    None,
                    Some(sell_execution),
                    Some(buy_error)
                ).await?
            }
            (Err(buy_error), Err(sell_error)) => {
                // åŒè¾¹éƒ½å¤±è´¥
                self.handle_failed_execution(
                    arbitrage_id,
                    buy_error,
                    sell_error
                ).await?
            }
        }
        
        Ok(())
    }
    
    // ğŸ”¥ å¤„ç†éƒ¨åˆ†æˆäº¤ï¼ˆé£é™©æ§åˆ¶ï¼‰
    async fn handle_partial_execution(
        &self,
        arbitrage_id: &str,
        buy_execution: Option<ExecutionResult>,
        sell_execution: Option<ExecutionResult>,
        error: Option<ExecutionError>
    ) -> Result<(), ArbitrageError> {
        log::warn!("Partial arbitrage execution for {}: {:?}", arbitrage_id, error);
        
        // æ›´æ–°çŠ¶æ€
        self.update_arbitrage_status(arbitrage_id, ArbitrageStatus::PartiallyFilled).await;
        
        // å°è¯•æ’¤é”€æˆåŠŸçš„è®¢å•ä»¥é¿å…å•è¾¹é£é™©
        if let Some(buy_exec) = buy_execution {
            if buy_exec.status == OrderStatus::PartiallyFilled || buy_exec.status == OrderStatus::New {
                if let Err(cancel_error) = self.order_executor.cancel_order(
                    &buy_exec.order_id,
                    buy_exec.exchange
                ).await {
                    log::error!("Failed to cancel buy order {}: {:?}", buy_exec.order_id, cancel_error);
                }
            }
        }
        
        if let Some(sell_exec) = sell_execution {
            if sell_exec.status == OrderStatus::PartiallyFilled || sell_exec.status == OrderStatus::New {
                if let Err(cancel_error) = self.order_executor.cancel_order(
                    &sell_exec.order_id,
                    sell_exec.exchange
                ).await {
                    log::error!("Failed to cancel sell order {}: {:?}", sell_exec.order_id, cancel_error);
                }
            }
        }
        
        // è®°å½•éƒ¨åˆ†æ‰§è¡Œäº‹ä»¶
        self.arbitrage_metrics.record_partial_execution(arbitrage_id).await;
        
        Ok(())
    }
    
    // æœŸè´§å¥—åˆ©å’Œè·¨å¸‚åœºå¥—åˆ©çš„å®ç°...
    
    // ğŸ”¥ å¥—åˆ©æœºä¼šæ‰«æ
    pub async fn scan_opportunities(&self) -> Result<Vec<ArbitrageOpportunity>, ArbitrageError> {
        self.opportunity_scanner.scan_all_opportunities().await
    }
    
    // è·å–æ´»è·ƒå¥—åˆ©çŠ¶æ€
    pub async fn get_active_arbitrages(&self) -> Vec<ActiveArbitrage> {
        let active_arbitrages = self.active_arbitrages.read().await;
        active_arbitrages.values().cloned().collect()
    }
    
    // å–æ¶ˆå¥—åˆ©
    pub async fn cancel_arbitrage(&self, arbitrage_id: &str) -> Result<(), ArbitrageError> {
        let active_arbitrage = {
            let active_arbitrages = self.active_arbitrages.read().await;
            active_arbitrages.get(arbitrage_id).cloned()
        };
        
        if let Some(arbitrage) = active_arbitrage {
            // å–æ¶ˆç›¸å…³è®¢å•
            if let Some(buy_order_id) = &arbitrage.buy_order_id {
                // å–æ¶ˆä¹°å•
            }
            
            if let Some(sell_order_id) = &arbitrage.sell_order_id {
                // å–æ¶ˆå–å•
            }
            
            // æ›´æ–°çŠ¶æ€
            self.update_arbitrage_status(arbitrage_id, ArbitrageStatus::Cancelled).await;
        }
        
        Ok(())
    }
}
```

### 4.2 å¥—åˆ©æœºä¼šæ‰«æå™¨

```rust
// src/executors/arbitrage/opportunity_scanner.rs
pub struct OpportunityScanner {
    config: ArbitrageConfig,
    price_monitor: Arc<PriceMonitor>,
    liquidity_analyzer: Arc<LiquidityAnalyzer>,
}

impl OpportunityScanner {
    pub async fn scan_all_opportunities(&self) -> Result<Vec<ArbitrageOpportunity>, ArbitrageError> {
        let mut opportunities = Vec::new();
        
        // æ‰«æç°è´§å¥—åˆ©æœºä¼š
        let spot_opportunities = self.scan_spot_arbitrage().await?;
        opportunities.extend(spot_opportunities);
        
        // æ‰«ææœŸè´§å¥—åˆ©æœºä¼š
        let futures_opportunities = self.scan_futures_arbitrage().await?;
        opportunities.extend(futures_opportunities);
        
        // æ‰«æè·¨å¸‚åœºå¥—åˆ©æœºä¼š
        let cross_market_opportunities = self.scan_cross_market_arbitrage().await?;
        opportunities.extend(cross_market_opportunities);
        
        // æŒ‰åˆ©æ¶¦ç‡æ’åº
        opportunities.sort_by(|a, b| {
            self.get_profit_margin(b).partial_cmp(&self.get_profit_margin(a)).unwrap()
        });
        
        Ok(opportunities)
    }
    
    async fn scan_spot_arbitrage(&self) -> Result<Vec<ArbitrageOpportunity>, ArbitrageError> {
        let mut opportunities = Vec::new();
        
        for symbol in &self.config.enabled_symbols {
            let mut exchange_prices = HashMap::new();
            
            // è·å–å„äº¤æ˜“æ‰€ä»·æ ¼
            for &exchange in &self.config.enabled_exchanges {
                if let Ok(orderbook) = self.price_monitor.get_orderbook(exchange, symbol).await {
                    if let (Some(best_bid), Some(best_ask)) = (orderbook.best_bid(), orderbook.best_ask()) {
                        exchange_prices.insert(exchange, (best_bid.price, best_ask.price));
                    }
                }
            }
            
            // å¯»æ‰¾å¥—åˆ©æœºä¼š
            for (&buy_exchange, &(_, buy_price)) in &exchange_prices {
                for (&sell_exchange, &(sell_price, _)) in &exchange_prices {
                    if buy_exchange != sell_exchange {
                        let profit_margin = (sell_price - buy_price) / buy_price;
                        
                        if profit_margin > self.config.min_profit_threshold {
                            // è®¡ç®—æœ€å¤§å¯æ‰§è¡Œæ•°é‡
                            let max_quantity = self.calculate_max_arbitrage_quantity(
                                buy_exchange,
                                sell_exchange,
                                symbol,
                                buy_price,
                                sell_price
                            ).await?;
                            
                            if max_quantity > Decimal::ZERO {
                                opportunities.push(ArbitrageOpportunity::SpotArbitrage {
                                    symbol: symbol.clone(),
                                    buy_exchange,
                                    sell_exchange,
                                    buy_price,
                                    sell_price,
                                    profit_margin,
                                    max_quantity,
                                });
                            }
                        }
                    }
                }
            }
        }
        
        Ok(opportunities)
    }
}
```

## 5. ä»“ä½ç®¡ç†ç³»ç»Ÿ

### 5.1 ç»Ÿä¸€ä»“ä½ç®¡ç†å™¨

```rust
// src/executors/position_manager.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::connectors::{ExchangeType, MarketType};
use crate::types::*;

#[derive(Debug, Clone)]
pub struct Position {
    pub symbol: String,
    pub exchange: ExchangeType,
    pub market_type: MarketType,
    pub side: PositionSide,
    pub size: Decimal,
    pub entry_price: Decimal,
    pub mark_price: Decimal,
    pub unrealized_pnl: Decimal,
    pub realized_pnl: Decimal,
    pub margin_used: Option<Decimal>,  // æœŸè´§ä¸“ç”¨
    pub leverage: Option<Decimal>,     // æœŸè´§ä¸“ç”¨
    pub last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PositionSide {
    Long,
    Short,
    Flat,
}

pub struct PositionManager {
    // ä»“ä½ç¼“å­˜ï¼šsymbol -> exchange -> position
    positions: Arc<RwLock<HashMap<String, HashMap<ExchangeType, Position>>>>,
    
    // ä»“ä½å†å²è®°å½•
    position_history: Arc<RwLock<Vec<PositionHistoryRecord>>>,
    
    // å®æ—¶ä»·æ ¼ç›‘æ§
    price_monitor: Arc<PriceMonitor>,
    
    // PnL è®¡ç®—å™¨
    pnl_calculator: Arc<PnLCalculator>,
}

impl PositionManager {
    pub fn new(price_monitor: Arc<PriceMonitor>) -> Self {
        Self {
            positions: Arc::new(RwLock::new(HashMap::new())),
            position_history: Arc::new(RwLock::new(Vec::new())),
            price_monitor,
            pnl_calculator: Arc::new(PnLCalculator::new()),
        }
    }
    
    // ğŸ”¥ æ›´æ–°ä»“ä½ï¼ˆè®¢å•æˆäº¤åè°ƒç”¨ï¼‰
    pub async fn update_position(
        &self,
        symbol: &str,
        exchange: ExchangeType,
        side: OrderSide,
        quantity: Decimal,
        price: Decimal
    ) -> Result<(), PositionError> {
        let mut positions = self.positions.write().await;
        let symbol_positions = positions.entry(symbol.to_string()).or_insert_with(HashMap::new);
        
        let position = symbol_positions.entry(exchange).or_insert_with(|| Position {
            symbol: symbol.to_string(),
            exchange,
            market_type: MarketType::Spot, // é»˜è®¤ï¼Œå®é™…åº”æ ¹æ®è®¢å•ç±»å‹è®¾ç½®
            side: PositionSide::Flat,
            size: Decimal::ZERO,
            entry_price: Decimal::ZERO,
            mark_price: Decimal::ZERO,
            unrealized_pnl: Decimal::ZERO,
            realized_pnl: Decimal::ZERO,
            margin_used: None,
            leverage: None,
            last_updated: Utc::now(),
        });
        
        // è®¡ç®—æ–°çš„ä»“ä½
        let (new_size, new_entry_price, realized_pnl) = self.calculate_new_position(
            position.size,
            position.entry_price,
            side,
            quantity,
            price
        );
        
        // æ›´æ–°ä»“ä½ä¿¡æ¯
        position.size = new_size;
        position.entry_price = new_entry_price;
        position.realized_pnl += realized_pnl;
        position.side = if new_size > Decimal::ZERO {
            PositionSide::Long
        } else if new_size < Decimal::ZERO {
            PositionSide::Short
        } else {
            PositionSide::Flat
        };
        position.last_updated = Utc::now();
        
        // æ›´æ–°æœªå®ç°ç›ˆäº
        let current_price = self.price_monitor.get_current_price(symbol, exchange).await?;
        position.mark_price = current_price;
        position.unrealized_pnl = self.pnl_calculator.calculate_unrealized_pnl(
            position.side,
            position.size.abs(),
            position.entry_price,
            current_price
        );
        
        // è®°å½•ä»“ä½å˜æ›´å†å²
        self.record_position_change(symbol, exchange, position.clone()).await;
        
        Ok(())
    }
    
    // è·å–ä»“ä½
    pub async fn get_position(&self, symbol: &str, exchange: ExchangeType) -> Option<Position> {
        let positions = self.positions.read().await;
        positions.get(symbol)?.get(&exchange).cloned()
    }
    
    // è·å–æ‰€æœ‰ä»“ä½
    pub async fn get_all_positions(&self) -> HashMap<String, HashMap<ExchangeType, Position>> {
        self.positions.read().await.clone()
    }
    
    // è®¡ç®—ç»„åˆæ€»ä»·å€¼
    pub async fn get_portfolio_value(&self) -> Result<Decimal, PositionError> {
        let positions = self.positions.read().await;
        let mut total_value = Decimal::ZERO;
        
        for (symbol, exchange_positions) in positions.iter() {
            for (exchange, position) in exchange_positions.iter() {
                let position_value = position.size.abs() * position.mark_price;
                total_value += position_value;
            }
        }
        
        Ok(total_value)
    }
    
    // è®¡ç®—æ€»ç›ˆäº
    pub async fn get_total_pnl(&self) -> Result<Decimal, PositionError> {
        let positions = self.positions.read().await;
        let mut total_pnl = Decimal::ZERO;
        
        for (_, exchange_positions) in positions.iter() {
            for (_, position) in exchange_positions.iter() {
                total_pnl += position.realized_pnl + position.unrealized_pnl;
            }
        }
        
        Ok(total_pnl)
    }
    
    // ç§æœ‰æ–¹æ³•ï¼šè®¡ç®—æ–°ä»“ä½
    fn calculate_new_position(
        &self,
        current_size: Decimal,
        current_entry_price: Decimal,
        trade_side: OrderSide,
        trade_quantity: Decimal,
        trade_price: Decimal
    ) -> (Decimal, Decimal, Decimal) {
        let trade_size = match trade_side {
            OrderSide::Buy => trade_quantity,
            OrderSide::Sell => -trade_quantity,
        };
        
        let new_size = current_size + trade_size;
        
        // è®¡ç®—æ–°çš„å…¥åœºä»·æ ¼å’Œå·²å®ç°ç›ˆäº
        if current_size.is_zero() {
            // å¼€æ–°ä»“
            (new_size, trade_price, Decimal::ZERO)
        } else if current_size.signum() == trade_size.signum() {
            // åŠ ä»“
            let total_cost = current_size.abs() * current_entry_price + trade_quantity * trade_price;
            let new_entry_price = total_cost / new_size.abs();
            (new_size, new_entry_price, Decimal::ZERO)
        } else {
            // å‡ä»“æˆ–åå‘å¼€ä»“
            let close_quantity = current_size.abs().min(trade_quantity);
            let realized_pnl = match current_size.signum() {
                s if s > Decimal::ZERO => close_quantity * (trade_price - current_entry_price),
                _ => close_quantity * (current_entry_price - trade_price),
            };
            
            if new_size.abs() < Decimal::from_f64(1e-8).unwrap() {
                // å®Œå…¨å¹³ä»“
                (Decimal::ZERO, Decimal::ZERO, realized_pnl)
            } else if new_size.signum() == current_size.signum() {
                // éƒ¨åˆ†å¹³ä»“
                (new_size, current_entry_price, realized_pnl)
            } else {
                // åå‘å¼€ä»“
                (new_size, trade_price, realized_pnl)
            }
        }
    }
}

## 6. æ‰¹é‡å¤„ç†ä¼˜åŒ–

### 6.1 æ‰¹é‡è®¢å•å¤„ç†å™¨

```rust
// src/executors/batch_processor.rs
use std::collections::HashMap;
use tokio::time::{Duration, Instant};

pub struct BatchProcessor {
    batch_size: usize,
    batch_timeout: Duration,
    pending_orders: Vec<OrderRequest>,
    last_batch_time: Instant,
}

impl BatchProcessor {
    pub fn new() -> Self {
        Self {
            batch_size: 10,
            batch_timeout: Duration::from_millis(100),
            pending_orders: Vec::new(),
            last_batch_time: Instant::now(),
        }
    }
    
    // æ·»åŠ è®¢å•åˆ°æ‰¹æ¬¡
    pub fn add_order(&mut self, order: OrderRequest) -> Option<Vec<OrderRequest>> {
        self.pending_orders.push(order);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰§è¡Œæ‰¹æ¬¡
        if self.should_execute_batch() {
            Some(self.take_pending_orders())
        } else {
            None
        }
    }
    
    // å¼ºåˆ¶æ‰§è¡Œå½“å‰æ‰¹æ¬¡
    pub fn flush_batch(&mut self) -> Vec<OrderRequest> {
        self.take_pending_orders()
    }
    
    fn should_execute_batch(&self) -> bool {
        self.pending_orders.len() >= self.batch_size ||
        self.last_batch_time.elapsed() >= self.batch_timeout
    }
    
    fn take_pending_orders(&mut self) -> Vec<OrderRequest> {
        let orders = std::mem::take(&mut self.pending_orders);
        self.last_batch_time = Instant::now();
        orders
    }
}
```

## 7. æ€§èƒ½ç›‘æ§å’ŒæŒ‡æ ‡

### 7.1 æ‰§è¡ŒæŒ‡æ ‡æ”¶é›†å™¨

```rust
// src/executors/metrics.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, Instant};

pub struct ExecutionMetrics {
    order_metrics: Arc<RwLock<HashMap<ExchangeType, OrderMetrics>>>,
    arbitrage_metrics: Arc<RwLock<ArbitrageMetrics>>,
    performance_metrics: Arc<RwLock<PerformanceMetrics>>,
}

#[derive(Debug, Clone, Default)]
pub struct OrderMetrics {
    pub total_orders: u64,
    pub successful_orders: u64,
    pub failed_orders: u64,
    pub average_execution_time: Duration,
    pub total_volume: Decimal,
    pub total_fees: Decimal,
}

#[derive(Debug, Clone, Default)]
pub struct ArbitrageMetrics {
    pub total_opportunities: u64,
    pub executed_arbitrages: u64,
    pub successful_arbitrages: u64,
    pub failed_arbitrages: u64,
    pub total_profit: Decimal,
    pub average_profit_margin: Decimal,
}

#[derive(Debug, Clone, Default)]
pub struct PerformanceMetrics {
    pub orders_per_second: f64,
    pub average_latency: Duration,
    pub p99_latency: Duration,
    pub error_rate: f64,
    pub uptime: Duration,
}

impl ExecutionMetrics {
    pub fn new() -> Self {
        Self {
            order_metrics: Arc::new(RwLock::new(HashMap::new())),
            arbitrage_metrics: Arc::new(RwLock::new(ArbitrageMetrics::default())),
            performance_metrics: Arc::new(RwLock::new(PerformanceMetrics::default())),
        }
    }
    
    // è®°å½•è®¢å•æ‰§è¡Œ
    pub async fn record_execution(
        &self,
        exchange: ExchangeType,
        order_type: OrderType,
        execution_time: Duration,
        success: bool
    ) {
        let mut metrics = self.order_metrics.write().await;
        let order_metrics = metrics.entry(exchange).or_insert_with(OrderMetrics::default);
        
        order_metrics.total_orders += 1;
        if success {
            order_metrics.successful_orders += 1;
        } else {
            order_metrics.failed_orders += 1;
        }
        
        // æ›´æ–°å¹³å‡æ‰§è¡Œæ—¶é—´
        order_metrics.average_execution_time = 
            (order_metrics.average_execution_time * (order_metrics.total_orders - 1) + execution_time) / order_metrics.total_orders;
    }
    
    // è·å–æ€§èƒ½æŠ¥å‘Š
    pub async fn get_performance_report(&self) -> PerformanceReport {
        let order_metrics = self.order_metrics.read().await;
        let arbitrage_metrics = self.arbitrage_metrics.read().await;
        let performance_metrics = self.performance_metrics.read().await;
        
        PerformanceReport {
            order_metrics: order_metrics.clone(),
            arbitrage_metrics: arbitrage_metrics.clone(),
            performance_metrics: performance_metrics.clone(),
            generated_at: Utc::now(),
        }
    }
}
```

## 8. é”™è¯¯å¤„ç†å’Œæ¢å¤

### 8.1 æ‰§è¡Œé”™è¯¯å®šä¹‰

```rust
// src/executors/error.rs
#[derive(Debug, thiserror::Error)]
pub enum ExecutionError {
    #[error("Order placement failed: {0}")]
    OrderPlacementFailed(String),
    
    #[error("Order cancellation failed: {0}")]
    OrderCancellationFailed(String),
    
    #[error("Risk check failed: {0}")]
    RiskCheckFailed(String),
    
    #[error("Risk violation: {0:?}")]
    RiskViolation(Vec<RiskViolation>),
    
    #[error("Position risk violation: {0:?}")]
    PositionRiskViolation(Vec<RiskViolation>),
    
    #[error("Portfolio risk violation: {0:?}")]
    PortfolioRiskViolation(Vec<RiskViolation>),
    
    #[error("No available exchange for symbol: {0}")]
    NoAvailableExchange(String),
    
    #[error("Order not found: {0}")]
    OrderNotFound(String),
    
    #[error("Insufficient balance")]
    InsufficientBalance,
    
    #[error("Position error: {0}")]
    PositionError(String),
    
    #[error("Timeout error: {0}")]
    TimeoutError(String),
}

#[derive(Debug, thiserror::Error)]
pub enum ArbitrageError {
    #[error("Invalid opportunity type")]
    InvalidOpportunityType,
    
    #[error("Execution failed: {0}")]
    ExecutionFailed(String),
    
    #[error("Risk check failed: {0}")]
    RiskCheckFailed(String),
    
    #[error("Insufficient liquidity")]
    InsufficientLiquidity,
    
    #[error("Price moved unfavorably")]
    PriceMovedUnfavorably,
    
    #[error("Timeout during execution")]
    ExecutionTimeout,
}
```

## 9. é…ç½®ç®¡ç†

### 9.1 æ‰§è¡Œå™¨é…ç½®

```rust
// src/executors/config.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutorConfig {
    pub order_executor: OrderExecutorConfig,
    pub risk_manager: RiskConfig,
    pub arbitrage_engine: ArbitrageConfig,
    pub position_manager: PositionManagerConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderExecutorConfig {
    pub max_concurrent_orders: usize,
    pub order_timeout: Duration,
    pub retry_attempts: u32,
    pub batch_processing: BatchProcessingConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchProcessingConfig {
    pub enabled: bool,
    pub batch_size: usize,
    pub batch_timeout_ms: u64,
}
```

### 9.2 é…ç½®ç¤ºä¾‹

```toml
# config.toml - æ‰§è¡Œå™¨é…ç½®éƒ¨åˆ†
[executors.order_executor]
max_concurrent_orders = 100
order_timeout = "30s"
retry_attempts = 3

[executors.order_executor.batch_processing]
enabled = true
batch_size = 10
batch_timeout_ms = 100

[executors.risk_manager.spot]
max_position_value = 10000.0
max_order_value = 5000.0
max_daily_trading_volume = 50000.0
min_account_balance_ratio = 0.1
max_concentration_ratio = 0.3

[executors.risk_manager.futures]
max_leverage = 10.0
max_position_value = 50000.0
min_margin_ratio = 0.2
max_funding_rate = 0.01
liquidation_buffer = 0.05
max_daily_loss = 5000.0

[executors.arbitrage_engine]
min_profit_threshold = 0.001
max_position_size = 1000.0
execution_timeout = "10s"
partial_fill_threshold = 0.5
```

## 10. æ€»ç»“

æ‰§è¡Œæ¨¡å—çš„é‡æ„å®ç°äº†ä»¥ä¸‹å…³é”®æ”¹è¿›ï¼š

### 10.1 æ ¸å¿ƒä¼˜åŠ¿
1. **æ™ºèƒ½è®¢å•è·¯ç”±**ï¼šæ ¹æ®è®¢å•ç±»å‹å’Œå¸‚åœºæ¡ä»¶é€‰æ‹©æœ€ä¼˜äº¤æ˜“æ‰€
2. **å·®å¼‚åŒ–é£æ§**ï¼šç°è´§å’ŒæœŸè´§é‡‡ç”¨ä¸åŒçš„é£é™©æ§åˆ¶ç­–ç•¥
3. **é«˜æ•ˆå¥—åˆ©æ‰§è¡Œ**ï¼šæ”¯æŒç°è´§ã€æœŸè´§å’Œè·¨å¸‚åœºå¥—åˆ©
4. **ç»Ÿä¸€ä»“ä½ç®¡ç†**ï¼šè·¨äº¤æ˜“æ‰€çš„ä»“ä½ç»Ÿä¸€è·Ÿè¸ªå’Œç®¡ç†
5. **æ‰¹é‡å¤„ç†ä¼˜åŒ–**ï¼šæé«˜è®¢å•æ‰§è¡Œæ•ˆç‡
6. **å®Œæ•´çš„ç›‘æ§ä½“ç³»**ï¼šå®æ—¶æ€§èƒ½æŒ‡æ ‡å’Œé£é™©ç›‘æ§

### 10.2 æ€§èƒ½ä¿è¯
- å¹¶å‘è®¢å•æ‰§è¡Œå‡å°‘å»¶è¿Ÿ
- æ‰¹é‡å¤„ç†æé«˜ååé‡
- æ™ºèƒ½è·¯ç”±ä¼˜åŒ–æ‰§è¡Œæˆæœ¬
- æœ¬åœ°ç¼“å­˜å‡å°‘ç½‘ç»œè°ƒç”¨

### 10.3 é£é™©æ§åˆ¶
- å¤šå±‚æ¬¡é£é™©æ£€æŸ¥æœºåˆ¶
- å®æ—¶ä»“ä½å’Œä¿è¯é‡‘ç›‘æ§
- è‡ªåŠ¨æ­¢æŸå’Œé£é™©é¢„è­¦
- å®Œæ•´çš„å®¡è®¡æ—¥å¿—

### 10.4 å¯æ‰©å±•æ€§
- æ¨¡å—åŒ–è®¾è®¡ä¾¿äºæ·»åŠ æ–°åŠŸèƒ½
- æ’ä»¶å¼é£æ§ç­–ç•¥
- æ”¯æŒæ–°äº¤æ˜“æ‰€å¿«é€Ÿæ¥å…¥
- é…ç½®é©±åŠ¨çš„å‚æ•°è°ƒæ•´

è¿™ä¸ªæ‰§è¡Œæ¨¡å—ä¸º CrossFury ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„äº¤æ˜“æ‰§è¡Œèƒ½åŠ›ï¼Œç¡®ä¿åœ¨é«˜é¢‘äº¤æ˜“ç¯å¢ƒä¸‹çš„ç¨³å®šæ€§å’Œç›ˆåˆ©èƒ½åŠ›ã€‚

## 11. æ–°ç›®å½•ç»“æ„è®¾è®¡

```
src/
â”œâ”€â”€ executors/                    # æ‰§è¡Œå™¨æ¨¡å—
â”‚   â”œâ”€â”€ mod.rs                    # æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ traits.rs                 # å¼•ç”¨æ ¸å¿ƒtraitå®šä¹‰
â”‚   â”œâ”€â”€ order_executor.rs         # è®¢å•æ‰§è¡Œå™¨å®ç°
â”‚   â”œâ”€â”€ risk_manager.rs           # é£é™©ç®¡ç†å™¨å®ç°
â”‚   â”œâ”€â”€ position_manager.rs       # ä»“ä½ç®¡ç†å™¨å®ç°
â”‚   â”œâ”€â”€ order_router.rs           # è®¢å•è·¯ç”±å™¨å®ç°
â”‚   â”œâ”€â”€ arbitrage_engine.rs       # å¥—åˆ©å¼•æ“å®ç°
â”‚   â”œâ”€â”€ batch_processor.rs        # æ‰¹é‡å¤„ç†å™¨
â”‚   â”œâ”€â”€ metrics.rs                # æ€§èƒ½æŒ‡æ ‡æ”¶é›†
â”‚   â”œâ”€â”€ legacy_adapter.rs         # æ—§ä»£ç é€‚é…å™¨
â”‚   â””â”€â”€ utils.rs                  # æ‰§è¡Œå™¨å·¥å…·å‡½æ•°
â”œâ”€â”€ types/                        # æ•°æ®ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ orders.rs                 # è®¢å•ç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ positions.rs              # ä»“ä½ç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ risk.rs                   # é£é™©ç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ arbitrage.rs              # å¥—åˆ©ç›¸å…³ç±»å‹
â”‚   â””â”€â”€ execution.rs              # æ‰§è¡Œç›¸å…³ç±»å‹
â”œâ”€â”€ legacy_execution/             # æ—§ä»£ç ä¿ç•™
â”‚   â”œâ”€â”€ legacy_cross_exchange.rs  # åŸcross_exchange.rsé‡å‘½å
â”‚   â”œâ”€â”€ legacy_core.rs            # åŸcore.rsæ‰§è¡Œéƒ¨åˆ†
â”‚   â””â”€â”€ legacy_utils.rs           # åŸutils.rsæ‰§è¡Œéƒ¨åˆ†
â””â”€â”€ config/
    â””â”€â”€ execution.rs              # æ‰§è¡Œå™¨é…ç½®ç®¡ç†
```

## 12. åˆ†é˜¶æ®µå®æ–½æ­¥éª¤

### é˜¶æ®µ1ï¼šåŸºç¡€è®¾æ–½æ­å»ºï¼ˆ1-2å‘¨ï¼‰

#### 1.1 åˆ›å»ºæ–°ç›®å½•ç»“æ„
- åˆ›å»º `src/executors/` ç›®å½•åŠå­æ¨¡å—
- åˆ›å»º `src/types/` ç›®å½•åŠç±»å‹å®šä¹‰æ–‡ä»¶
- åˆ›å»º `src/legacy_execution/` ç›®å½•

#### 1.2 ä¿ç•™æ—§ä»£ç 
```bash
# é‡å‘½åç°æœ‰æ–‡ä»¶ï¼Œä¿æŒåŠŸèƒ½ä¸å˜
mv src/cross_exchange.rs src/legacy_execution/legacy_cross_exchange.rs
cp src/core.rs src/legacy_execution/legacy_core.rs  # ä¿ç•™æ‰§è¡Œç›¸å…³éƒ¨åˆ†
cp src/utils.rs src/legacy_execution/legacy_utils.rs  # ä¿ç•™æ‰§è¡Œç›¸å…³å·¥å…·
```

#### 1.3 åˆ›å»ºtraitå¼•ç”¨æ–‡ä»¶
```rust
// src/executors/traits.rs
pub use crate::traits::{
    OrderExecutor, RiskManager, PositionManager, OrderRouter
};
```

### é˜¶æ®µ2ï¼šé€‚é…å™¨å®ç°ï¼ˆ2-3å‘¨ï¼‰

#### 2.1 å®ç°æ—§ä»£ç é€‚é…å™¨
- åˆ›å»º `LegacyExecutorAdapter`
- å®ç° `OrderExecutor` trait çš„é€‚é…
- å®ç° `RiskManager` trait çš„é€‚é…
- ç¡®ä¿ç°æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ

#### 2.2 æ•°æ®ç±»å‹è¿ç§»
- å°† `exchange_types.rs` ä¸­çš„ç±»å‹è¿ç§»åˆ° `src/types/`
- åˆ›å»ºæ–°æ—§ç±»å‹ä¹‹é—´çš„è½¬æ¢å‡½æ•°
- ä¿æŒå‘åå…¼å®¹æ€§

### é˜¶æ®µ3ï¼šæ‰§è¡Œå™¨è¿ç§»ï¼ˆ3-4å‘¨ï¼‰

#### 3.1 è®¢å•æ‰§è¡Œå™¨é‡æ„
- å®ç° `OrderExecutorImpl`
- é›†æˆæ™ºèƒ½è·¯ç”±åŠŸèƒ½
- æ·»åŠ æ‰¹é‡å¤„ç†æ”¯æŒ
- é›†æˆé£é™©æ£€æŸ¥æœºåˆ¶

#### 3.2 é£é™©ç®¡ç†å™¨é‡æ„
- å®ç° `RiskManagerImpl`
- åŒºåˆ†ç°è´§å’ŒæœŸè´§é£æ§ç­–ç•¥
- æ·»åŠ å®æ—¶ç›‘æ§åŠŸèƒ½
- å®ç°ç´§æ€¥åœæ­¢æœºåˆ¶

#### 3.3 ä»“ä½ç®¡ç†å™¨é‡æ„
- å®ç° `PositionManagerImpl`
- ç»Ÿä¸€å¤šäº¤æ˜“æ‰€ä»“ä½ç®¡ç†
- å®ç°å®æ—¶åŒæ­¥æœºåˆ¶
- æ·»åŠ ä»“ä½é£é™©è¯„ä¼°

### é˜¶æ®µ4ï¼šé›†æˆä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰

#### 4.1 å¥—åˆ©å¼•æ“é‡æ„
- é‡æ„ç°æœ‰å¥—åˆ©é€»è¾‘
- é›†æˆæ–°çš„æ‰§è¡Œå™¨æ¥å£
- ä¼˜åŒ–æ‰§è¡Œæ•ˆç‡
- æ·»åŠ æ€§èƒ½ç›‘æ§

#### 4.2 æ€§èƒ½ä¼˜åŒ–
- å®ç°æ‰¹é‡å¤„ç†å™¨
- æ·»åŠ æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- ä¼˜åŒ–å¹¶å‘æ‰§è¡Œ
- å‡å°‘ç½‘ç»œå»¶è¿Ÿ

#### 4.3 é›†æˆæµ‹è¯•
- ç¼–å†™å…¨é¢çš„é›†æˆæµ‹è¯•
- æ€§èƒ½åŸºå‡†æµ‹è¯•
- å‹åŠ›æµ‹è¯•
- æ•…éšœæ¢å¤æµ‹è¯•

### é˜¶æ®µ5ï¼šæ¸…ç†å’Œæ–‡æ¡£ï¼ˆ1å‘¨ï¼‰

#### 5.1 ä»£ç æ¸…ç†
- ç§»é™¤æœªä½¿ç”¨çš„æ—§ä»£ç 
- ä¼˜åŒ–ä»£ç ç»“æ„
- ç»Ÿä¸€ä»£ç é£æ ¼
- æ·»åŠ è¯¦ç»†æ³¨é‡Š

#### 5.2 æ–‡æ¡£å®Œå–„
- æ›´æ–°APIæ–‡æ¡£
- ç¼–å†™ä½¿ç”¨æŒ‡å—
- åˆ›å»ºé…ç½®è¯´æ˜
- æ·»åŠ æ•…éšœæ’é™¤æŒ‡å—

### æ€»æ—¶é—´é¢„ä¼°ï¼š9-13å‘¨

### é£é™©æ§åˆ¶æªæ–½
1. **æ¸è¿›å¼è¿ç§»**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½ä¿æŒç³»ç»Ÿå¯è¿è¡ŒçŠ¶æ€
2. **å¹¶è¡Œå¼€å‘**ï¼šæ–°æ—§ä»£ç å¹¶å­˜ï¼Œé€æ­¥åˆ‡æ¢
3. **å……åˆ†æµ‹è¯•**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯¹åº”çš„æµ‹è¯•éªŒè¯
4. **å›æ»šæœºåˆ¶**ï¼šå‡ºç°é—®é¢˜æ—¶å¯å¿«é€Ÿå›æ»šåˆ°æ—§ç‰ˆæœ¬
5. **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§ç³»ç»Ÿè¿è¡ŒçŠ¶æ€ï¼ŒåŠæ—¶å‘ç°é—®é¢˜