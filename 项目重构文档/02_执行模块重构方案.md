# 执行模块重构方案

## 1. 模块概述

执行模块是 CrossFury 系统的核心交易执行层，负责订单路由、风险控制、仓位管理和套利执行。本模块基于**事件驱动架构**，与连接模块的推送式数据流无缝集成。

**重要：本方案严格遵循 `CrossFury_核心Trait定义.md` 中定义的接口规范。**

### 1.1 核心职责
- **智能订单路由**：根据市场类型和流动性选择最优交易所
- **实时风险控制**：现货和期货差异化风控策略
- **仓位管理**：统一的多交易所仓位跟踪
- **套利执行**：现货套利、期货套利、跨市场套利
- **订单生命周期管理**：从下单到成交的全流程跟踪
- **性能优化**：批量订单处理和并发执行

### 1.2 设计原则
- **事件驱动**：响应连接模块的推送式数据流
- **风险优先**：所有交易操作都经过风险检查
- **原子操作**：确保订单操作的一致性
- **故障隔离**：单个交易所故障不影响其他交易所
- **可观测性**：完整的执行链路追踪
- **Trait统一**：所有执行器实现 `OrderExecutor` trait，风险管理器实现 `RiskManager` trait

### 1.3 旧代码替换规划

#### 1.3.1 现有代码结构分析
```
当前执行相关代码分散在：
src/cross_exchange.rs        -> 重构为 src/executors/arbitrage_executor.rs
src/core.rs                  -> 部分逻辑迁移到 src/executors/order_executor.rs
src/exchange_types.rs        -> 迁移到 src/types/orders.rs 和 src/types/exchange.rs
src/utils.rs                 -> 部分工具函数迁移到 src/executors/utils.rs
```

#### 1.3.2 迁移策略
1. **保留旧代码**：将现有执行相关代码重命名为 `legacy_*` 前缀
2. **创建新结构**：按照新的目录结构创建执行器模块
3. **逐步迁移**：每个执行器单独迁移，确保编译通过
4. **适配器模式**：为旧代码创建适配器，实现新的 trait 接口
5. **渐进替换**：新功能使用新接口，旧功能保持兼容

## 2. 架构设计

### 2.1 核心 Trait 定义

**所有核心 trait 定义已统一到 `CrossFury_核心Trait定义.md`，本模块严格实现以下 trait：**

- **`OrderExecutor`**：订单执行器接口，负责订单路由、执行、取消等操作
- **`RiskManager`**：风险管理器接口，负责风险检查、限制设置、紧急操作等
- **`PositionManager`**：仓位管理器接口，负责多交易所仓位跟踪和管理
- **`OrderRouter`**：订单路由器接口，负责智能选择最优执行交易所

### 2.2 核心 Trait 实现要求

#### OrderExecutor 实现要求
- 支持单笔和批量订单执行
- 实现智能订单路由算法
- 提供订单生命周期管理
- 集成风险检查机制
- 支持异步执行和事件推送

#### RiskManager 实现要求
- 实现多层级风险检查（订单级、仓位级、组合级）
- 支持动态风险限制设置
- 提供实时风险监控
- 支持紧急停止和强制平仓
- 区分现货和期货风险策略

#### PositionManager 实现要求
- 统一管理多交易所仓位
- 实时同步仓位变化
- 支持仓位聚合和分拆
- 提供仓位风险评估

#### OrderRouter 实现要求
- 基于流动性、手续费、延迟等因素选择交易所
- 支持负载均衡和故障转移
- 实现动态路由策略调整

### 2.3 支持的交易所和市场类型

#### 现货交易所
- **主流交易所**：Binance、OKX、Bybit、Gate.io、KuCoin、Huobi
- **新增交易所**：LBank、XTCom、TapBit、HBit、BatonEx、CoinCatch
- **特殊支持**：每个交易所的特定订单类型和执行规则

#### 期货交易所
- **主流期货**：Binance Futures、OKX Futures、Bybit Futures
- **执行特性**：保证金管理、强制平仓、资金费率处理

### 2.4 旧代码适配器实现

```rust
// src/executors/legacy_adapter.rs
use crate::legacy_cross_exchange::CrossExchangeArbitrage;
use crate::traits::{OrderExecutor, RiskManager};

/// 旧代码适配器，将现有执行逻辑包装为新的 trait 接口
pub struct LegacyExecutorAdapter {
    legacy_arbitrage: CrossExchangeArbitrage,
}

#[async_trait]
impl OrderExecutor for LegacyExecutorAdapter {
    async fn execute_order(&self, order: OrderRequest) -> Result<ExecutionResult, ExecutionError> {
        // 将新的 OrderRequest 转换为旧的格式
        let legacy_order = self.convert_to_legacy_order(order)?;
        
        // 调用旧的执行逻辑
        let legacy_result = self.legacy_arbitrage.execute_order(legacy_order).await?;
        
        // 将旧的结果转换为新的格式
        self.convert_to_new_result(legacy_result)
    }
    
    // 其他方法的适配实现...
}
```

### 2.2 订单执行器实现

```rust
// src/executors/order_executor.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use crate::connectors::{ConnectorManager, ExchangeType, MarketType};
use crate::executors::traits::*;
use crate::executors::risk_manager::RiskManager;
use crate::executors::position_manager::PositionManager;
use crate::executors::routing::OrderRouter;

pub struct OrderExecutorImpl {
    connector_manager: Arc<ConnectorManager>,
    risk_manager: Arc<dyn RiskManager>,
    position_manager: Arc<PositionManager>,
    order_router: Arc<OrderRouter>,
    
    // 订单跟踪
    active_orders: Arc<RwLock<HashMap<String, TrackedOrder>>>,
    execution_history: Arc<Mutex<Vec<ExecutionRecord>>>,
    
    // 性能优化
    batch_processor: BatchProcessor,
    execution_metrics: Arc<ExecutionMetrics>,
}

#[derive(Debug, Clone)]
pub struct TrackedOrder {
    pub order_id: String,
    pub client_order_id: String,
    pub exchange: ExchangeType,
    pub symbol: String,
    pub order_type: OrderType,
    pub side: OrderSide,
    pub quantity: Decimal,
    pub price: Option<Decimal>,
    pub status: OrderStatus,
    pub filled_quantity: Decimal,
    pub average_price: Option<Decimal>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub execution_records: Vec<ExecutionRecord>,
}

#[derive(Debug, Clone)]
pub struct ExecutionResult {
    pub order_id: String,
    pub client_order_id: String,
    pub exchange: ExchangeType,
    pub status: OrderStatus,
    pub filled_quantity: Decimal,
    pub remaining_quantity: Decimal,
    pub average_price: Option<Decimal>,
    pub commission: Option<Decimal>,
    pub execution_time: DateTime<Utc>,
}

impl OrderExecutorImpl {
    pub fn new(
        connector_manager: Arc<ConnectorManager>,
        risk_manager: Arc<dyn RiskManager>,
        position_manager: Arc<PositionManager>,
    ) -> Self {
        Self {
            connector_manager: connector_manager.clone(),
            risk_manager,
            position_manager,
            order_router: Arc::new(OrderRouter::new(connector_manager)),
            active_orders: Arc::new(RwLock::new(HashMap::new())),
            execution_history: Arc::new(Mutex::new(Vec::new())),
            batch_processor: BatchProcessor::new(),
            execution_metrics: Arc::new(ExecutionMetrics::new()),
        }
    }
    
    // 🔥 智能订单路由（核心改进）
    async fn route_order(&self, order: &OrderRequest) -> Result<ExchangeType, ExecutionError> {
        // 1. 根据市场类型过滤可用交易所
        let available_exchanges = self.order_router.get_available_exchanges(
            &order.symbol, 
            order.market_type
        ).await?;
        
        if available_exchanges.is_empty() {
            return Err(ExecutionError::NoAvailableExchange(order.symbol.clone()));
        }
        
        // 2. 根据订单类型选择最优交易所
        match order.order_type {
            OrderType::Market => {
                // 市价单：选择流动性最好的交易所
                self.order_router.select_best_liquidity_exchange(
                    &available_exchanges,
                    &order.symbol,
                    order.side,
                    order.quantity
                ).await
            }
            OrderType::Limit => {
                // 限价单：选择手续费最低的交易所
                self.order_router.select_lowest_fee_exchange(
                    &available_exchanges,
                    &order.symbol,
                    order.market_type
                ).await
            }
            OrderType::StopLoss | OrderType::TakeProfit => {
                // 止损/止盈单：选择执行最可靠的交易所
                self.order_router.select_most_reliable_exchange(
                    &available_exchanges,
                    &order.symbol
                ).await
            }
        }
    }
    
    // 🔥 风险检查集成
    async fn perform_risk_checks(&self, order: &OrderRequest) -> Result<(), ExecutionError> {
        // 1. 订单级风险检查
        let order_risk = self.risk_manager.check_order_risk(order).await
            .map_err(|e| ExecutionError::RiskCheckFailed(e.to_string()))?;
        
        if !order_risk.passed {
            return Err(ExecutionError::RiskViolation(order_risk.violations));
        }
        
        // 2. 仓位级风险检查
        let target_exchange = self.route_order(order).await?;
        let position_risk = self.risk_manager.check_position_risk(&order.symbol, target_exchange).await
            .map_err(|e| ExecutionError::RiskCheckFailed(e.to_string()))?;
        
        if !position_risk.passed {
            return Err(ExecutionError::PositionRiskViolation(position_risk.violations));
        }
        
        // 3. 组合级风险检查
        let portfolio_risk = self.risk_manager.check_portfolio_risk().await
            .map_err(|e| ExecutionError::RiskCheckFailed(e.to_string()))?;
        
        if !portfolio_risk.passed {
            return Err(ExecutionError::PortfolioRiskViolation(portfolio_risk.violations));
        }
        
        Ok(())
    }
}

#[async_trait]
impl OrderExecutor for OrderExecutorImpl {
    async fn execute_order(&self, mut order: OrderRequest) -> Result<ExecutionResult, ExecutionError> {
        let start_time = Instant::now();
        
        // 1. 生成客户端订单ID
        order.client_order_id = Some(generate_client_order_id());
        
        // 2. 风险检查
        self.perform_risk_checks(&order).await?;
        
        // 3. 智能路由
        let target_exchange = self.route_order(&order).await?;
        
        // 4. 执行订单
        let order_response = self.connector_manager
            .place_order(&target_exchange.to_string(), &order)
            .await
            .map_err(|e| ExecutionError::OrderPlacementFailed(e.to_string()))?;
        
        // 5. 创建跟踪记录
        let tracked_order = TrackedOrder {
            order_id: order_response.order_id.clone(),
            client_order_id: order.client_order_id.unwrap(),
            exchange: target_exchange,
            symbol: order.symbol.clone(),
            order_type: order.order_type,
            side: order.side,
            quantity: order.quantity,
            price: order.price,
            status: order_response.status.clone(),
            filled_quantity: order_response.filled_quantity,
            average_price: order_response.average_price,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            execution_records: Vec::new(),
        };
        
        // 6. 更新订单跟踪
        {
            let mut active_orders = self.active_orders.write().await;
            active_orders.insert(order_response.order_id.clone(), tracked_order);
        }
        
        // 7. 更新仓位（如果有成交）
        if order_response.filled_quantity > Decimal::ZERO {
            self.position_manager.update_position(
                &order.symbol,
                target_exchange,
                order.side,
                order_response.filled_quantity,
                order_response.average_price.unwrap_or(order.price.unwrap_or_default())
            ).await?;
        }
        
        // 8. 记录执行指标
        let execution_time = start_time.elapsed();
        self.execution_metrics.record_execution(
            target_exchange,
            order.order_type,
            execution_time,
            order_response.status == OrderStatus::Filled
        ).await;
        
        // 9. 构造执行结果
        Ok(ExecutionResult {
            order_id: order_response.order_id,
            client_order_id: order.client_order_id.unwrap(),
            exchange: target_exchange,
            status: order_response.status,
            filled_quantity: order_response.filled_quantity,
            remaining_quantity: order.quantity - order_response.filled_quantity,
            average_price: order_response.average_price,
            commission: order_response.commission,
            execution_time: Utc::now(),
        })
    }
    
    // 🔥 批量订单处理（性能优化）
    async fn execute_batch_orders(&self, orders: Vec<OrderRequest>) -> Vec<Result<ExecutionResult, ExecutionError>> {
        // 按交易所分组
        let mut orders_by_exchange: HashMap<ExchangeType, Vec<OrderRequest>> = HashMap::new();
        
        for order in orders {
            // 预先进行路由决策
            match self.route_order(&order).await {
                Ok(exchange) => {
                    orders_by_exchange.entry(exchange).or_insert_with(Vec::new).push(order);
                }
                Err(e) => {
                    // 记录路由失败的订单
                    continue;
                }
            }
        }
        
        // 并发执行各交易所的订单
        let mut tasks = Vec::new();
        for (exchange, exchange_orders) in orders_by_exchange {
            let executor = self.clone();
            let task = tokio::spawn(async move {
                let mut results = Vec::new();
                for order in exchange_orders {
                    let result = executor.execute_order(order).await;
                    results.push(result);
                }
                results
            });
            tasks.push(task);
        }
        
        // 收集所有结果
        let mut all_results = Vec::new();
        for task in tasks {
            if let Ok(results) = task.await {
                all_results.extend(results);
            }
        }
        
        all_results
    }
    
    async fn cancel_order(&self, order_id: &str, exchange: ExchangeType) -> Result<bool, ExecutionError> {
        // 1. 查找订单信息
        let tracked_order = {
            let active_orders = self.active_orders.read().await;
            active_orders.get(order_id).cloned()
        };
        
        let tracked_order = tracked_order.ok_or_else(|| 
            ExecutionError::OrderNotFound(order_id.to_string())
        )?;
        
        // 2. 执行撤单
        let cancel_result = self.connector_manager
            .cancel_order(&exchange.to_string(), order_id, &tracked_order.symbol)
            .await
            .map_err(|e| ExecutionError::OrderCancellationFailed(e.to_string()))?;
        
        // 3. 更新订单状态
        if cancel_result {
            let mut active_orders = self.active_orders.write().await;
            if let Some(order) = active_orders.get_mut(order_id) {
                order.status = OrderStatus::Cancelled;
                order.updated_at = Utc::now();
            }
        }
        
        Ok(cancel_result)
    }
    
    // 其他方法实现...
}
```

### 2.3 智能订单路由器

```rust
// src/executors/routing/order_router.rs
use std::collections::HashMap;
use std::sync::Arc;
use crate::connectors::{ConnectorManager, ExchangeType, MarketType};
use crate::types::*;

pub struct OrderRouter {
    connector_manager: Arc<ConnectorManager>,
    exchange_metrics: Arc<ExchangeMetrics>,
    liquidity_analyzer: LiquidityAnalyzer,
    fee_calculator: FeeCalculator,
}

#[derive(Debug, Clone)]
pub struct ExchangeScore {
    pub exchange: ExchangeType,
    pub liquidity_score: f64,
    pub fee_score: f64,
    pub reliability_score: f64,
    pub latency_score: f64,
    pub total_score: f64,
}

impl OrderRouter {
    pub fn new(connector_manager: Arc<ConnectorManager>) -> Self {
        Self {
            connector_manager,
            exchange_metrics: Arc::new(ExchangeMetrics::new()),
            liquidity_analyzer: LiquidityAnalyzer::new(),
            fee_calculator: FeeCalculator::new(),
        }
    }
    
    // 🔥 获取可用交易所（支持现货+期货）
    pub async fn get_available_exchanges(
        &self,
        symbol: &str,
        market_type: MarketType
    ) -> Result<Vec<ExchangeType>, RoutingError> {
        let mut available = Vec::new();
        
        // 检查各交易所的连接状态和交易对支持
        for exchange in [ExchangeType::Binance, ExchangeType::Bybit, ExchangeType::Okx] {
            // 检查连接状态
            if !self.connector_manager.is_exchange_connected(&exchange.to_string()).await {
                continue;
            }
            
            // 检查交易对支持
            if self.connector_manager.supports_symbol(&exchange.to_string(), symbol, market_type).await? {
                available.push(exchange);
            }
        }
        
        Ok(available)
    }
    
    // 🔥 选择最佳流动性交易所（市价单优化）
    pub async fn select_best_liquidity_exchange(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str,
        side: OrderSide,
        quantity: Decimal
    ) -> Result<ExchangeType, RoutingError> {
        let mut best_exchange = None;
        let mut best_liquidity_score = 0.0;
        
        for &exchange in available_exchanges {
            // 获取订单簿快照
            let orderbook = self.connector_manager
                .get_orderbook_snapshot(&exchange.to_string(), symbol)
                .await?;
            
            // 计算流动性得分
            let liquidity_score = self.liquidity_analyzer.calculate_liquidity_score(
                &orderbook,
                side,
                quantity
            );
            
            if liquidity_score > best_liquidity_score {
                best_liquidity_score = liquidity_score;
                best_exchange = Some(exchange);
            }
        }
        
        best_exchange.ok_or(RoutingError::NoSuitableExchange)
    }
    
    // 🔥 选择最低手续费交易所（限价单优化）
    pub async fn select_lowest_fee_exchange(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str,
        market_type: MarketType
    ) -> Result<ExchangeType, RoutingError> {
        let mut best_exchange = None;
        let mut lowest_fee = Decimal::MAX;
        
        for &exchange in available_exchanges {
            let fee = self.fee_calculator.get_trading_fee(exchange, symbol, market_type).await?;
            
            if fee < lowest_fee {
                lowest_fee = fee;
                best_exchange = Some(exchange);
            }
        }
        
        best_exchange.ok_or(RoutingError::NoSuitableExchange)
    }
    
    // 🔥 选择最可靠交易所（止损单优化）
    pub async fn select_most_reliable_exchange(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str
    ) -> Result<ExchangeType, RoutingError> {
        let mut best_exchange = None;
        let mut highest_reliability = 0.0;
        
        for &exchange in available_exchanges {
            let reliability = self.exchange_metrics.get_reliability_score(exchange).await;
            
            if reliability > highest_reliability {
                highest_reliability = reliability;
                best_exchange = Some(exchange);
            }
        }
        
        best_exchange.ok_or(RoutingError::NoSuitableExchange)
    }
    
    // 🔥 综合评分选择（复杂策略）
    pub async fn select_best_exchange_comprehensive(
        &self,
        available_exchanges: &[ExchangeType],
        symbol: &str,
        order: &OrderRequest,
        weights: &RoutingWeights
    ) -> Result<ExchangeType, RoutingError> {
        let mut exchange_scores = Vec::new();
        
        for &exchange in available_exchanges {
            let score = self.calculate_exchange_score(exchange, symbol, order, weights).await?;
            exchange_scores.push(score);
        }
        
        // 按总分排序
        exchange_scores.sort_by(|a, b| b.total_score.partial_cmp(&a.total_score).unwrap());
        
        exchange_scores.first()
            .map(|score| score.exchange)
            .ok_or(RoutingError::NoSuitableExchange)
    }
    
    async fn calculate_exchange_score(
        &self,
        exchange: ExchangeType,
        symbol: &str,
        order: &OrderRequest,
        weights: &RoutingWeights
    ) -> Result<ExchangeScore, RoutingError> {
        // 1. 流动性得分
        let orderbook = self.connector_manager
            .get_orderbook_snapshot(&exchange.to_string(), symbol)
            .await?;
        let liquidity_score = self.liquidity_analyzer.calculate_liquidity_score(
            &orderbook,
            order.side,
            order.quantity
        );
        
        // 2. 手续费得分
        let fee = self.fee_calculator.get_trading_fee(exchange, symbol, order.market_type).await?;
        let fee_score = self.calculate_fee_score(fee);
        
        // 3. 可靠性得分
        let reliability_score = self.exchange_metrics.get_reliability_score(exchange).await;
        
        // 4. 延迟得分
        let latency_score = self.exchange_metrics.get_latency_score(exchange).await;
        
        // 5. 计算加权总分
        let total_score = 
            liquidity_score * weights.liquidity +
            fee_score * weights.fee +
            reliability_score * weights.reliability +
            latency_score * weights.latency;
        
        Ok(ExchangeScore {
            exchange,
            liquidity_score,
            fee_score,
            reliability_score,
            latency_score,
            total_score,
        })
    }
}

#[derive(Debug, Clone)]
pub struct RoutingWeights {
    pub liquidity: f64,
    pub fee: f64,
    pub reliability: f64,
    pub latency: f64,
}

impl Default for RoutingWeights {
    fn default() -> Self {
        Self {
            liquidity: 0.4,
            fee: 0.3,
            reliability: 0.2,
            latency: 0.1,
        }
    }
}
```

## 3. 风险管理系统

### 3.1 差异化风控策略

```rust
// src/executors/risk_manager/mod.rs
use async_trait::async_trait;
use crate::types::*;
use crate::connectors::{ExchangeType, MarketType};

pub struct RiskManagerImpl {
    spot_risk_manager: SpotRiskManager,
    futures_risk_manager: FuturesRiskManager,
    portfolio_risk_manager: PortfolioRiskManager,
    risk_config: RiskConfig,
}

#[derive(Debug, Clone)]
pub struct RiskConfig {
    pub spot_config: SpotRiskConfig,
    pub futures_config: FuturesRiskConfig,
    pub portfolio_config: PortfolioRiskConfig,
}

// 🔥 现货风控配置
#[derive(Debug, Clone)]
pub struct SpotRiskConfig {
    pub max_position_value: Decimal,           // 单币种最大持仓价值
    pub max_order_value: Decimal,              // 单笔订单最大价值
    pub max_daily_trading_volume: Decimal,     // 日最大交易量
    pub min_account_balance_ratio: Decimal,    // 最小账户余额比例
    pub max_concentration_ratio: Decimal,      // 最大集中度比例
    pub blacklisted_symbols: Vec<String>,      // 黑名单交易对
}

// 🔥 期货风控配置
#[derive(Debug, Clone)]
pub struct FuturesRiskConfig {
    pub max_leverage: Decimal,                 // 最大杠杆倍数
    pub max_position_value: Decimal,           // 单合约最大持仓价值
    pub max_order_value: Decimal,              // 单笔订单最大价值
    pub min_margin_ratio: Decimal,             // 最小保证金比例
    pub max_funding_rate: Decimal,             // 最大资金费率阈值
    pub liquidation_buffer: Decimal,           // 强平缓冲区
    pub max_daily_loss: Decimal,               // 日最大亏损
    pub position_size_limits: HashMap<String, Decimal>, // 合约持仓限制
}

#[derive(Debug, Clone)]
pub struct PortfolioRiskConfig {
    pub max_total_exposure: Decimal,           // 最大总敞口
    pub max_correlation_exposure: Decimal,     // 最大相关性敞口
    pub max_drawdown: Decimal,                 // 最大回撤
    pub var_limit: Decimal,                    // VaR限制
    pub stress_test_scenarios: Vec<StressTestScenario>,
}

impl RiskManagerImpl {
    pub fn new(risk_config: RiskConfig) -> Self {
        Self {
            spot_risk_manager: SpotRiskManager::new(risk_config.spot_config.clone()),
            futures_risk_manager: FuturesRiskManager::new(risk_config.futures_config.clone()),
            portfolio_risk_manager: PortfolioRiskManager::new(risk_config.portfolio_config.clone()),
            risk_config,
        }
    }
}

#[async_trait]
impl RiskManager for RiskManagerImpl {
    async fn check_order_risk(&self, order: &OrderRequest) -> Result<RiskCheckResult, RiskError> {
        let mut violations = Vec::new();
        
        // 根据市场类型选择相应的风控策略
        match order.market_type {
            MarketType::Spot => {
                let spot_result = self.spot_risk_manager.check_order_risk(order).await?;
                violations.extend(spot_result.violations);
            }
            MarketType::Futures => {
                let futures_result = self.futures_risk_manager.check_order_risk(order).await?;
                violations.extend(futures_result.violations);
            }
        }
        
        // 组合级风险检查
        let portfolio_result = self.portfolio_risk_manager.check_order_impact(order).await?;
        violations.extend(portfolio_result.violations);
        
        Ok(RiskCheckResult {
            passed: violations.is_empty(),
            violations,
            risk_score: self.calculate_risk_score(&violations),
        })
    }
    
    async fn check_position_risk(&self, symbol: &str, exchange: ExchangeType) -> Result<PositionRiskResult, RiskError> {
        // 获取当前仓位
        let position = self.get_position(symbol, exchange).await?;
        
        let mut violations = Vec::new();
        
        match position.market_type {
            MarketType::Spot => {
                let spot_result = self.spot_risk_manager.check_position_risk(&position).await?;
                violations.extend(spot_result.violations);
            }
            MarketType::Futures => {
                let futures_result = self.futures_risk_manager.check_position_risk(&position).await?;
                violations.extend(futures_result.violations);
            }
        }
        
        Ok(PositionRiskResult {
            passed: violations.is_empty(),
            violations,
            position_risk_metrics: self.calculate_position_risk_metrics(&position).await?,
        })
    }
    
    async fn check_portfolio_risk(&self) -> Result<PortfolioRiskResult, RiskError> {
        self.portfolio_risk_manager.check_portfolio_risk().await
    }
}
```

### 3.2 现货风控管理器

```rust
// src/executors/risk_manager/spot_risk_manager.rs
pub struct SpotRiskManager {
    config: SpotRiskConfig,
    position_tracker: Arc<PositionTracker>,
    balance_monitor: Arc<BalanceMonitor>,
}

impl SpotRiskManager {
    pub async fn check_order_risk(&self, order: &OrderRequest) -> Result<RiskCheckResult, RiskError> {
        let mut violations = Vec::new();
        
        // 1. 检查订单价值限制
        let order_value = self.calculate_order_value(order).await?;
        if order_value > self.config.max_order_value {
            violations.push(RiskViolation::OrderValueExceeded {
                current: order_value,
                limit: self.config.max_order_value,
            });
        }
        
        // 2. 检查账户余额
        let account_balance = self.balance_monitor.get_available_balance(&order.symbol).await?;
        let required_balance = match order.side {
            OrderSide::Buy => order_value,
            OrderSide::Sell => order.quantity,
        };
        
        if account_balance < required_balance {
            violations.push(RiskViolation::InsufficientBalance {
                required: required_balance,
                available: account_balance,
            });
        }
        
        // 3. 检查持仓集中度
        let current_position_value = self.position_tracker.get_position_value(&order.symbol).await?;
        let new_position_value = match order.side {
            OrderSide::Buy => current_position_value + order_value,
            OrderSide::Sell => current_position_value - order_value,
        };
        
        if new_position_value > self.config.max_position_value {
            violations.push(RiskViolation::PositionValueExceeded {
                symbol: order.symbol.clone(),
                current: new_position_value,
                limit: self.config.max_position_value,
            });
        }
        
        // 4. 检查黑名单
        if self.config.blacklisted_symbols.contains(&order.symbol) {
            violations.push(RiskViolation::BlacklistedSymbol {
                symbol: order.symbol.clone(),
            });
        }
        
        // 5. 检查日交易量限制
        let daily_volume = self.get_daily_trading_volume(&order.symbol).await?;
        if daily_volume + order_value > self.config.max_daily_trading_volume {
            violations.push(RiskViolation::DailyVolumeExceeded {
                current: daily_volume + order_value,
                limit: self.config.max_daily_trading_volume,
            });
        }
        
        Ok(RiskCheckResult {
            passed: violations.is_empty(),
            violations,
            risk_score: self.calculate_spot_risk_score(&violations),
        })
    }
}
```

### 3.3 期货风控管理器

```rust
// src/executors/risk_manager/futures_risk_manager.rs
pub struct FuturesRiskManager {
    config: FuturesRiskConfig,
    position_tracker: Arc<PositionTracker>,
    margin_calculator: Arc<MarginCalculator>,
    funding_rate_monitor: Arc<FundingRateMonitor>,
}

impl FuturesRiskManager {
    pub async fn check_order_risk(&self, order: &OrderRequest) -> Result<RiskCheckResult, RiskError> {
        let mut violations = Vec::new();
        
        // 1. 检查杠杆限制
        if let Some(leverage) = order.leverage {
            if leverage > self.config.max_leverage {
                violations.push(RiskViolation::LeverageExceeded {
                    current: leverage,
                    limit: self.config.max_leverage,
                });
            }
        }
        
        // 2. 检查保证金要求
        let required_margin = self.margin_calculator.calculate_required_margin(order).await?;
        let available_margin = self.margin_calculator.get_available_margin().await?;
        
        if required_margin > available_margin {
            violations.push(RiskViolation::InsufficientMargin {
                required: required_margin,
                available: available_margin,
            });
        }
        
        // 3. 检查强平风险
        let liquidation_price = self.margin_calculator.calculate_liquidation_price(order).await?;
        let current_price = self.get_current_price(&order.symbol).await?;
        let price_distance = (liquidation_price - current_price).abs() / current_price;
        
        if price_distance < self.config.liquidation_buffer {
            violations.push(RiskViolation::LiquidationRisk {
                symbol: order.symbol.clone(),
                liquidation_price,
                current_price,
                buffer: self.config.liquidation_buffer,
            });
        }
        
        // 4. 检查资金费率
        let funding_rate = self.funding_rate_monitor.get_current_funding_rate(&order.symbol).await?;
        if funding_rate.abs() > self.config.max_funding_rate {
            violations.push(RiskViolation::HighFundingRate {
                symbol: order.symbol.clone(),
                current_rate: funding_rate,
                limit: self.config.max_funding_rate,
            });
        }
        
        // 5. 检查持仓限制
        if let Some(&position_limit) = self.config.position_size_limits.get(&order.symbol) {
            let current_position = self.position_tracker.get_position_size(&order.symbol).await?;
            let new_position_size = match order.side {
                OrderSide::Buy => current_position + order.quantity,
                OrderSide::Sell => current_position - order.quantity,
            };
            
            if new_position_size.abs() > position_limit {
                violations.push(RiskViolation::PositionSizeExceeded {
                    symbol: order.symbol.clone(),
                    current: new_position_size.abs(),
                    limit: position_limit,
                });
            }
        }
        
        // 6. 检查日亏损限制
        let daily_pnl = self.get_daily_pnl().await?;
        if daily_pnl < -self.config.max_daily_loss {
            violations.push(RiskViolation::DailyLossExceeded {
                current_loss: daily_pnl.abs(),
                limit: self.config.max_daily_loss,
            });
        }
        
        Ok(RiskCheckResult {
            passed: violations.is_empty(),
            violations,
            risk_score: self.calculate_futures_risk_score(&violations),
        })
    }
}
```

## 4. 套利执行引擎

### 4.1 套利引擎设计

```rust
// src/executors/arbitrage/arbitrage_engine.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::executors::traits::OrderExecutor;
use crate::connectors::{ExchangeType, MarketType};
use crate::types::*;

#[derive(Debug, Clone)]
pub enum ArbitrageOpportunity {
    // 现货套利
    SpotArbitrage {
        symbol: String,
        buy_exchange: ExchangeType,
        sell_exchange: ExchangeType,
        buy_price: Decimal,
        sell_price: Decimal,
        profit_margin: Decimal,
        max_quantity: Decimal,
    },
    
    // 期货套利
    FuturesArbitrage {
        symbol: String,
        buy_exchange: ExchangeType,
        sell_exchange: ExchangeType,
        buy_price: Decimal,
        sell_price: Decimal,
        profit_margin: Decimal,
        max_quantity: Decimal,
        expiry_date: Option<DateTime<Utc>>,
    },
    
    // 跨市场套利（现货-期货）
    CrossMarketArbitrage {
        symbol: String,
        spot_exchange: ExchangeType,
        futures_exchange: ExchangeType,
        spot_price: Decimal,
        futures_price: Decimal,
        basis: Decimal,
        profit_margin: Decimal,
        max_quantity: Decimal,
    },
}

pub struct ArbitrageEngine {
    order_executor: Arc<dyn OrderExecutor>,
    opportunity_scanner: Arc<OpportunityScanner>,
    risk_manager: Arc<dyn RiskManager>,
    
    // 套利配置
    config: ArbitrageConfig,
    
    // 活跃套利订单跟踪
    active_arbitrages: Arc<RwLock<HashMap<String, ActiveArbitrage>>>,
    
    // 性能指标
    arbitrage_metrics: Arc<ArbitrageMetrics>,
}

#[derive(Debug, Clone)]
pub struct ArbitrageConfig {
    pub min_profit_threshold: Decimal,         // 最小利润阈值
    pub max_position_size: Decimal,            // 最大仓位大小
    pub execution_timeout: Duration,           // 执行超时时间
    pub partial_fill_threshold: Decimal,       // 部分成交阈值
    pub enabled_exchanges: Vec<ExchangeType>,  // 启用的交易所
    pub enabled_symbols: Vec<String>,          // 启用的交易对
    pub risk_limits: ArbitrageRiskLimits,
}

#[derive(Debug, Clone)]
pub struct ActiveArbitrage {
    pub id: String,
    pub opportunity: ArbitrageOpportunity,
    pub buy_order_id: Option<String>,
    pub sell_order_id: Option<String>,
    pub status: ArbitrageStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub execution_records: Vec<ArbitrageExecutionRecord>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ArbitrageStatus {
    Pending,
    Executing,
    PartiallyFilled,
    Completed,
    Failed,
    Cancelled,
}

impl ArbitrageEngine {
    pub fn new(
        order_executor: Arc<dyn OrderExecutor>,
        risk_manager: Arc<dyn RiskManager>,
        config: ArbitrageConfig,
    ) -> Self {
        Self {
            order_executor,
            opportunity_scanner: Arc::new(OpportunityScanner::new(config.clone())),
            risk_manager,
            config,
            active_arbitrages: Arc::new(RwLock::new(HashMap::new())),
            arbitrage_metrics: Arc::new(ArbitrageMetrics::new()),
        }
    }
    
    // 🔥 执行套利机会
    pub async fn execute_arbitrage(&self, opportunity: ArbitrageOpportunity) -> Result<String, ArbitrageError> {
        // 1. 生成套利ID
        let arbitrage_id = generate_arbitrage_id();
        
        // 2. 风险检查
        self.check_arbitrage_risk(&opportunity).await?;
        
        // 3. 创建活跃套利记录
        let active_arbitrage = ActiveArbitrage {
            id: arbitrage_id.clone(),
            opportunity: opportunity.clone(),
            buy_order_id: None,
            sell_order_id: None,
            status: ArbitrageStatus::Pending,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            execution_records: Vec::new(),
        };
        
        {
            let mut active_arbitrages = self.active_arbitrages.write().await;
            active_arbitrages.insert(arbitrage_id.clone(), active_arbitrage);
        }
        
        // 4. 执行套利订单
        match opportunity {
            ArbitrageOpportunity::SpotArbitrage { .. } => {
                self.execute_spot_arbitrage(&arbitrage_id, &opportunity).await?
            }
            ArbitrageOpportunity::FuturesArbitrage { .. } => {
                self.execute_futures_arbitrage(&arbitrage_id, &opportunity).await?
            }
            ArbitrageOpportunity::CrossMarketArbitrage { .. } => {
                self.execute_cross_market_arbitrage(&arbitrage_id, &opportunity).await?
            }
        }
        
        Ok(arbitrage_id)
    }
    
    // 🔥 现货套利执行
    async fn execute_spot_arbitrage(
        &self,
        arbitrage_id: &str,
        opportunity: &ArbitrageOpportunity
    ) -> Result<(), ArbitrageError> {
        if let ArbitrageOpportunity::SpotArbitrage {
            symbol,
            buy_exchange,
            sell_exchange,
            buy_price,
            sell_price,
            max_quantity,
            ..
        } = opportunity {
            // 计算最优执行数量
            let execution_quantity = self.calculate_optimal_quantity(
                *max_quantity,
                *buy_price,
                *sell_price
            ).await?;
            
            // 创建买卖订单
            let buy_order = OrderRequest {
                symbol: symbol.clone(),
                side: OrderSide::Buy,
                order_type: OrderType::Limit,
                quantity: execution_quantity,
                price: Some(*buy_price),
                market_type: MarketType::Spot,
                time_in_force: Some(TimeInForce::IOC), // 立即成交或取消
                client_order_id: Some(format!("{}_buy", arbitrage_id)),
                ..Default::default()
            };
            
            let sell_order = OrderRequest {
                symbol: symbol.clone(),
                side: OrderSide::Sell,
                order_type: OrderType::Limit,
                quantity: execution_quantity,
                price: Some(*sell_price),
                market_type: MarketType::Spot,
                time_in_force: Some(TimeInForce::IOC),
                client_order_id: Some(format!("{}_sell", arbitrage_id)),
                ..Default::default()
            };
            
            // 🔥 并发执行双边订单（关键优化）
            self.execute_dual_orders(arbitrage_id, buy_order, sell_order).await?
        } else {
            return Err(ArbitrageError::InvalidOpportunityType);
        }
        
        Ok(())
    }
    
    // 🔥 并发双边订单执行（核心方法）
    async fn execute_dual_orders(
        &self,
        arbitrage_id: &str,
        buy_order: OrderRequest,
        sell_order: OrderRequest
    ) -> Result<(), ArbitrageError> {
        // 更新状态为执行中
        self.update_arbitrage_status(arbitrage_id, ArbitrageStatus::Executing).await;
        
        // 并发执行买卖订单
        let (buy_result, sell_result) = tokio::join!(
            self.order_executor.execute_order(buy_order.clone()),
            self.order_executor.execute_order(sell_order.clone())
        );
        
        // 处理执行结果
        match (buy_result, sell_result) {
            (Ok(buy_execution), Ok(sell_execution)) => {
                // 双边都成功
                self.handle_successful_dual_execution(
                    arbitrage_id,
                    buy_execution,
                    sell_execution
                ).await?
            }
            (Ok(buy_execution), Err(sell_error)) => {
                // 买单成功，卖单失败
                self.handle_partial_execution(
                    arbitrage_id,
                    Some(buy_execution),
                    None,
                    Some(sell_error)
                ).await?
            }
            (Err(buy_error), Ok(sell_execution)) => {
                // 卖单成功，买单失败
                self.handle_partial_execution(
                    arbitrage_id,
                    None,
                    Some(sell_execution),
                    Some(buy_error)
                ).await?
            }
            (Err(buy_error), Err(sell_error)) => {
                // 双边都失败
                self.handle_failed_execution(
                    arbitrage_id,
                    buy_error,
                    sell_error
                ).await?
            }
        }
        
        Ok(())
    }
    
    // 🔥 处理部分成交（风险控制）
    async fn handle_partial_execution(
        &self,
        arbitrage_id: &str,
        buy_execution: Option<ExecutionResult>,
        sell_execution: Option<ExecutionResult>,
        error: Option<ExecutionError>
    ) -> Result<(), ArbitrageError> {
        log::warn!("Partial arbitrage execution for {}: {:?}", arbitrage_id, error);
        
        // 更新状态
        self.update_arbitrage_status(arbitrage_id, ArbitrageStatus::PartiallyFilled).await;
        
        // 尝试撤销成功的订单以避免单边风险
        if let Some(buy_exec) = buy_execution {
            if buy_exec.status == OrderStatus::PartiallyFilled || buy_exec.status == OrderStatus::New {
                if let Err(cancel_error) = self.order_executor.cancel_order(
                    &buy_exec.order_id,
                    buy_exec.exchange
                ).await {
                    log::error!("Failed to cancel buy order {}: {:?}", buy_exec.order_id, cancel_error);
                }
            }
        }
        
        if let Some(sell_exec) = sell_execution {
            if sell_exec.status == OrderStatus::PartiallyFilled || sell_exec.status == OrderStatus::New {
                if let Err(cancel_error) = self.order_executor.cancel_order(
                    &sell_exec.order_id,
                    sell_exec.exchange
                ).await {
                    log::error!("Failed to cancel sell order {}: {:?}", sell_exec.order_id, cancel_error);
                }
            }
        }
        
        // 记录部分执行事件
        self.arbitrage_metrics.record_partial_execution(arbitrage_id).await;
        
        Ok(())
    }
    
    // 期货套利和跨市场套利的实现...
    
    // 🔥 套利机会扫描
    pub async fn scan_opportunities(&self) -> Result<Vec<ArbitrageOpportunity>, ArbitrageError> {
        self.opportunity_scanner.scan_all_opportunities().await
    }
    
    // 获取活跃套利状态
    pub async fn get_active_arbitrages(&self) -> Vec<ActiveArbitrage> {
        let active_arbitrages = self.active_arbitrages.read().await;
        active_arbitrages.values().cloned().collect()
    }
    
    // 取消套利
    pub async fn cancel_arbitrage(&self, arbitrage_id: &str) -> Result<(), ArbitrageError> {
        let active_arbitrage = {
            let active_arbitrages = self.active_arbitrages.read().await;
            active_arbitrages.get(arbitrage_id).cloned()
        };
        
        if let Some(arbitrage) = active_arbitrage {
            // 取消相关订单
            if let Some(buy_order_id) = &arbitrage.buy_order_id {
                // 取消买单
            }
            
            if let Some(sell_order_id) = &arbitrage.sell_order_id {
                // 取消卖单
            }
            
            // 更新状态
            self.update_arbitrage_status(arbitrage_id, ArbitrageStatus::Cancelled).await;
        }
        
        Ok(())
    }
}
```

### 4.2 套利机会扫描器

```rust
// src/executors/arbitrage/opportunity_scanner.rs
pub struct OpportunityScanner {
    config: ArbitrageConfig,
    price_monitor: Arc<PriceMonitor>,
    liquidity_analyzer: Arc<LiquidityAnalyzer>,
}

impl OpportunityScanner {
    pub async fn scan_all_opportunities(&self) -> Result<Vec<ArbitrageOpportunity>, ArbitrageError> {
        let mut opportunities = Vec::new();
        
        // 扫描现货套利机会
        let spot_opportunities = self.scan_spot_arbitrage().await?;
        opportunities.extend(spot_opportunities);
        
        // 扫描期货套利机会
        let futures_opportunities = self.scan_futures_arbitrage().await?;
        opportunities.extend(futures_opportunities);
        
        // 扫描跨市场套利机会
        let cross_market_opportunities = self.scan_cross_market_arbitrage().await?;
        opportunities.extend(cross_market_opportunities);
        
        // 按利润率排序
        opportunities.sort_by(|a, b| {
            self.get_profit_margin(b).partial_cmp(&self.get_profit_margin(a)).unwrap()
        });
        
        Ok(opportunities)
    }
    
    async fn scan_spot_arbitrage(&self) -> Result<Vec<ArbitrageOpportunity>, ArbitrageError> {
        let mut opportunities = Vec::new();
        
        for symbol in &self.config.enabled_symbols {
            let mut exchange_prices = HashMap::new();
            
            // 获取各交易所价格
            for &exchange in &self.config.enabled_exchanges {
                if let Ok(orderbook) = self.price_monitor.get_orderbook(exchange, symbol).await {
                    if let (Some(best_bid), Some(best_ask)) = (orderbook.best_bid(), orderbook.best_ask()) {
                        exchange_prices.insert(exchange, (best_bid.price, best_ask.price));
                    }
                }
            }
            
            // 寻找套利机会
            for (&buy_exchange, &(_, buy_price)) in &exchange_prices {
                for (&sell_exchange, &(sell_price, _)) in &exchange_prices {
                    if buy_exchange != sell_exchange {
                        let profit_margin = (sell_price - buy_price) / buy_price;
                        
                        if profit_margin > self.config.min_profit_threshold {
                            // 计算最大可执行数量
                            let max_quantity = self.calculate_max_arbitrage_quantity(
                                buy_exchange,
                                sell_exchange,
                                symbol,
                                buy_price,
                                sell_price
                            ).await?;
                            
                            if max_quantity > Decimal::ZERO {
                                opportunities.push(ArbitrageOpportunity::SpotArbitrage {
                                    symbol: symbol.clone(),
                                    buy_exchange,
                                    sell_exchange,
                                    buy_price,
                                    sell_price,
                                    profit_margin,
                                    max_quantity,
                                });
                            }
                        }
                    }
                }
            }
        }
        
        Ok(opportunities)
    }
}
```

## 5. 仓位管理系统

### 5.1 统一仓位管理器

```rust
// src/executors/position_manager.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::connectors::{ExchangeType, MarketType};
use crate::types::*;

#[derive(Debug, Clone)]
pub struct Position {
    pub symbol: String,
    pub exchange: ExchangeType,
    pub market_type: MarketType,
    pub side: PositionSide,
    pub size: Decimal,
    pub entry_price: Decimal,
    pub mark_price: Decimal,
    pub unrealized_pnl: Decimal,
    pub realized_pnl: Decimal,
    pub margin_used: Option<Decimal>,  // 期货专用
    pub leverage: Option<Decimal>,     // 期货专用
    pub last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PositionSide {
    Long,
    Short,
    Flat,
}

pub struct PositionManager {
    // 仓位缓存：symbol -> exchange -> position
    positions: Arc<RwLock<HashMap<String, HashMap<ExchangeType, Position>>>>,
    
    // 仓位历史记录
    position_history: Arc<RwLock<Vec<PositionHistoryRecord>>>,
    
    // 实时价格监控
    price_monitor: Arc<PriceMonitor>,
    
    // PnL 计算器
    pnl_calculator: Arc<PnLCalculator>,
}

impl PositionManager {
    pub fn new(price_monitor: Arc<PriceMonitor>) -> Self {
        Self {
            positions: Arc::new(RwLock::new(HashMap::new())),
            position_history: Arc::new(RwLock::new(Vec::new())),
            price_monitor,
            pnl_calculator: Arc::new(PnLCalculator::new()),
        }
    }
    
    // 🔥 更新仓位（订单成交后调用）
    pub async fn update_position(
        &self,
        symbol: &str,
        exchange: ExchangeType,
        side: OrderSide,
        quantity: Decimal,
        price: Decimal
    ) -> Result<(), PositionError> {
        let mut positions = self.positions.write().await;
        let symbol_positions = positions.entry(symbol.to_string()).or_insert_with(HashMap::new);
        
        let position = symbol_positions.entry(exchange).or_insert_with(|| Position {
            symbol: symbol.to_string(),
            exchange,
            market_type: MarketType::Spot, // 默认，实际应根据订单类型设置
            side: PositionSide::Flat,
            size: Decimal::ZERO,
            entry_price: Decimal::ZERO,
            mark_price: Decimal::ZERO,
            unrealized_pnl: Decimal::ZERO,
            realized_pnl: Decimal::ZERO,
            margin_used: None,
            leverage: None,
            last_updated: Utc::now(),
        });
        
        // 计算新的仓位
        let (new_size, new_entry_price, realized_pnl) = self.calculate_new_position(
            position.size,
            position.entry_price,
            side,
            quantity,
            price
        );
        
        // 更新仓位信息
        position.size = new_size;
        position.entry_price = new_entry_price;
        position.realized_pnl += realized_pnl;
        position.side = if new_size > Decimal::ZERO {
            PositionSide::Long
        } else if new_size < Decimal::ZERO {
            PositionSide::Short
        } else {
            PositionSide::Flat
        };
        position.last_updated = Utc::now();
        
        // 更新未实现盈亏
        let current_price = self.price_monitor.get_current_price(symbol, exchange).await?;
        position.mark_price = current_price;
        position.unrealized_pnl = self.pnl_calculator.calculate_unrealized_pnl(
            position.side,
            position.size.abs(),
            position.entry_price,
            current_price
        );
        
        // 记录仓位变更历史
        self.record_position_change(symbol, exchange, position.clone()).await;
        
        Ok(())
    }
    
    // 获取仓位
    pub async fn get_position(&self, symbol: &str, exchange: ExchangeType) -> Option<Position> {
        let positions = self.positions.read().await;
        positions.get(symbol)?.get(&exchange).cloned()
    }
    
    // 获取所有仓位
    pub async fn get_all_positions(&self) -> HashMap<String, HashMap<ExchangeType, Position>> {
        self.positions.read().await.clone()
    }
    
    // 计算组合总价值
    pub async fn get_portfolio_value(&self) -> Result<Decimal, PositionError> {
        let positions = self.positions.read().await;
        let mut total_value = Decimal::ZERO;
        
        for (symbol, exchange_positions) in positions.iter() {
            for (exchange, position) in exchange_positions.iter() {
                let position_value = position.size.abs() * position.mark_price;
                total_value += position_value;
            }
        }
        
        Ok(total_value)
    }
    
    // 计算总盈亏
    pub async fn get_total_pnl(&self) -> Result<Decimal, PositionError> {
        let positions = self.positions.read().await;
        let mut total_pnl = Decimal::ZERO;
        
        for (_, exchange_positions) in positions.iter() {
            for (_, position) in exchange_positions.iter() {
                total_pnl += position.realized_pnl + position.unrealized_pnl;
            }
        }
        
        Ok(total_pnl)
    }
    
    // 私有方法：计算新仓位
    fn calculate_new_position(
        &self,
        current_size: Decimal,
        current_entry_price: Decimal,
        trade_side: OrderSide,
        trade_quantity: Decimal,
        trade_price: Decimal
    ) -> (Decimal, Decimal, Decimal) {
        let trade_size = match trade_side {
            OrderSide::Buy => trade_quantity,
            OrderSide::Sell => -trade_quantity,
        };
        
        let new_size = current_size + trade_size;
        
        // 计算新的入场价格和已实现盈亏
        if current_size.is_zero() {
            // 开新仓
            (new_size, trade_price, Decimal::ZERO)
        } else if current_size.signum() == trade_size.signum() {
            // 加仓
            let total_cost = current_size.abs() * current_entry_price + trade_quantity * trade_price;
            let new_entry_price = total_cost / new_size.abs();
            (new_size, new_entry_price, Decimal::ZERO)
        } else {
            // 减仓或反向开仓
            let close_quantity = current_size.abs().min(trade_quantity);
            let realized_pnl = match current_size.signum() {
                s if s > Decimal::ZERO => close_quantity * (trade_price - current_entry_price),
                _ => close_quantity * (current_entry_price - trade_price),
            };
            
            if new_size.abs() < Decimal::from_f64(1e-8).unwrap() {
                // 完全平仓
                (Decimal::ZERO, Decimal::ZERO, realized_pnl)
            } else if new_size.signum() == current_size.signum() {
                // 部分平仓
                (new_size, current_entry_price, realized_pnl)
            } else {
                // 反向开仓
                (new_size, trade_price, realized_pnl)
            }
        }
    }
}

## 6. 批量处理优化

### 6.1 批量订单处理器

```rust
// src/executors/batch_processor.rs
use std::collections::HashMap;
use tokio::time::{Duration, Instant};

pub struct BatchProcessor {
    batch_size: usize,
    batch_timeout: Duration,
    pending_orders: Vec<OrderRequest>,
    last_batch_time: Instant,
}

impl BatchProcessor {
    pub fn new() -> Self {
        Self {
            batch_size: 10,
            batch_timeout: Duration::from_millis(100),
            pending_orders: Vec::new(),
            last_batch_time: Instant::now(),
        }
    }
    
    // 添加订单到批次
    pub fn add_order(&mut self, order: OrderRequest) -> Option<Vec<OrderRequest>> {
        self.pending_orders.push(order);
        
        // 检查是否需要执行批次
        if self.should_execute_batch() {
            Some(self.take_pending_orders())
        } else {
            None
        }
    }
    
    // 强制执行当前批次
    pub fn flush_batch(&mut self) -> Vec<OrderRequest> {
        self.take_pending_orders()
    }
    
    fn should_execute_batch(&self) -> bool {
        self.pending_orders.len() >= self.batch_size ||
        self.last_batch_time.elapsed() >= self.batch_timeout
    }
    
    fn take_pending_orders(&mut self) -> Vec<OrderRequest> {
        let orders = std::mem::take(&mut self.pending_orders);
        self.last_batch_time = Instant::now();
        orders
    }
}
```

## 7. 性能监控和指标

### 7.1 执行指标收集器

```rust
// src/executors/metrics.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, Instant};

pub struct ExecutionMetrics {
    order_metrics: Arc<RwLock<HashMap<ExchangeType, OrderMetrics>>>,
    arbitrage_metrics: Arc<RwLock<ArbitrageMetrics>>,
    performance_metrics: Arc<RwLock<PerformanceMetrics>>,
}

#[derive(Debug, Clone, Default)]
pub struct OrderMetrics {
    pub total_orders: u64,
    pub successful_orders: u64,
    pub failed_orders: u64,
    pub average_execution_time: Duration,
    pub total_volume: Decimal,
    pub total_fees: Decimal,
}

#[derive(Debug, Clone, Default)]
pub struct ArbitrageMetrics {
    pub total_opportunities: u64,
    pub executed_arbitrages: u64,
    pub successful_arbitrages: u64,
    pub failed_arbitrages: u64,
    pub total_profit: Decimal,
    pub average_profit_margin: Decimal,
}

#[derive(Debug, Clone, Default)]
pub struct PerformanceMetrics {
    pub orders_per_second: f64,
    pub average_latency: Duration,
    pub p99_latency: Duration,
    pub error_rate: f64,
    pub uptime: Duration,
}

impl ExecutionMetrics {
    pub fn new() -> Self {
        Self {
            order_metrics: Arc::new(RwLock::new(HashMap::new())),
            arbitrage_metrics: Arc::new(RwLock::new(ArbitrageMetrics::default())),
            performance_metrics: Arc::new(RwLock::new(PerformanceMetrics::default())),
        }
    }
    
    // 记录订单执行
    pub async fn record_execution(
        &self,
        exchange: ExchangeType,
        order_type: OrderType,
        execution_time: Duration,
        success: bool
    ) {
        let mut metrics = self.order_metrics.write().await;
        let order_metrics = metrics.entry(exchange).or_insert_with(OrderMetrics::default);
        
        order_metrics.total_orders += 1;
        if success {
            order_metrics.successful_orders += 1;
        } else {
            order_metrics.failed_orders += 1;
        }
        
        // 更新平均执行时间
        order_metrics.average_execution_time = 
            (order_metrics.average_execution_time * (order_metrics.total_orders - 1) + execution_time) / order_metrics.total_orders;
    }
    
    // 获取性能报告
    pub async fn get_performance_report(&self) -> PerformanceReport {
        let order_metrics = self.order_metrics.read().await;
        let arbitrage_metrics = self.arbitrage_metrics.read().await;
        let performance_metrics = self.performance_metrics.read().await;
        
        PerformanceReport {
            order_metrics: order_metrics.clone(),
            arbitrage_metrics: arbitrage_metrics.clone(),
            performance_metrics: performance_metrics.clone(),
            generated_at: Utc::now(),
        }
    }
}
```

## 8. 错误处理和恢复

### 8.1 执行错误定义

```rust
// src/executors/error.rs
#[derive(Debug, thiserror::Error)]
pub enum ExecutionError {
    #[error("Order placement failed: {0}")]
    OrderPlacementFailed(String),
    
    #[error("Order cancellation failed: {0}")]
    OrderCancellationFailed(String),
    
    #[error("Risk check failed: {0}")]
    RiskCheckFailed(String),
    
    #[error("Risk violation: {0:?}")]
    RiskViolation(Vec<RiskViolation>),
    
    #[error("Position risk violation: {0:?}")]
    PositionRiskViolation(Vec<RiskViolation>),
    
    #[error("Portfolio risk violation: {0:?}")]
    PortfolioRiskViolation(Vec<RiskViolation>),
    
    #[error("No available exchange for symbol: {0}")]
    NoAvailableExchange(String),
    
    #[error("Order not found: {0}")]
    OrderNotFound(String),
    
    #[error("Insufficient balance")]
    InsufficientBalance,
    
    #[error("Position error: {0}")]
    PositionError(String),
    
    #[error("Timeout error: {0}")]
    TimeoutError(String),
}

#[derive(Debug, thiserror::Error)]
pub enum ArbitrageError {
    #[error("Invalid opportunity type")]
    InvalidOpportunityType,
    
    #[error("Execution failed: {0}")]
    ExecutionFailed(String),
    
    #[error("Risk check failed: {0}")]
    RiskCheckFailed(String),
    
    #[error("Insufficient liquidity")]
    InsufficientLiquidity,
    
    #[error("Price moved unfavorably")]
    PriceMovedUnfavorably,
    
    #[error("Timeout during execution")]
    ExecutionTimeout,
}
```

## 9. 配置管理

### 9.1 执行器配置

```rust
// src/executors/config.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutorConfig {
    pub order_executor: OrderExecutorConfig,
    pub risk_manager: RiskConfig,
    pub arbitrage_engine: ArbitrageConfig,
    pub position_manager: PositionManagerConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderExecutorConfig {
    pub max_concurrent_orders: usize,
    pub order_timeout: Duration,
    pub retry_attempts: u32,
    pub batch_processing: BatchProcessingConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchProcessingConfig {
    pub enabled: bool,
    pub batch_size: usize,
    pub batch_timeout_ms: u64,
}
```

### 9.2 配置示例

```toml
# config.toml - 执行器配置部分
[executors.order_executor]
max_concurrent_orders = 100
order_timeout = "30s"
retry_attempts = 3

[executors.order_executor.batch_processing]
enabled = true
batch_size = 10
batch_timeout_ms = 100

[executors.risk_manager.spot]
max_position_value = 10000.0
max_order_value = 5000.0
max_daily_trading_volume = 50000.0
min_account_balance_ratio = 0.1
max_concentration_ratio = 0.3

[executors.risk_manager.futures]
max_leverage = 10.0
max_position_value = 50000.0
min_margin_ratio = 0.2
max_funding_rate = 0.01
liquidation_buffer = 0.05
max_daily_loss = 5000.0

[executors.arbitrage_engine]
min_profit_threshold = 0.001
max_position_size = 1000.0
execution_timeout = "10s"
partial_fill_threshold = 0.5
```

## 10. 总结

执行模块的重构实现了以下关键改进：

### 10.1 核心优势
1. **智能订单路由**：根据订单类型和市场条件选择最优交易所
2. **差异化风控**：现货和期货采用不同的风险控制策略
3. **高效套利执行**：支持现货、期货和跨市场套利
4. **统一仓位管理**：跨交易所的仓位统一跟踪和管理
5. **批量处理优化**：提高订单执行效率
6. **完整的监控体系**：实时性能指标和风险监控

### 10.2 性能保证
- 并发订单执行减少延迟
- 批量处理提高吞吐量
- 智能路由优化执行成本
- 本地缓存减少网络调用

### 10.3 风险控制
- 多层次风险检查机制
- 实时仓位和保证金监控
- 自动止损和风险预警
- 完整的审计日志

### 10.4 可扩展性
- 模块化设计便于添加新功能
- 插件式风控策略
- 支持新交易所快速接入
- 配置驱动的参数调整

这个执行模块为 CrossFury 系统提供了强大的交易执行能力，确保在高频交易环境下的稳定性和盈利能力。

## 11. 新目录结构设计

```
src/
├── executors/                    # 执行器模块
│   ├── mod.rs                    # 模块导出
│   ├── traits.rs                 # 引用核心trait定义
│   ├── order_executor.rs         # 订单执行器实现
│   ├── risk_manager.rs           # 风险管理器实现
│   ├── position_manager.rs       # 仓位管理器实现
│   ├── order_router.rs           # 订单路由器实现
│   ├── arbitrage_engine.rs       # 套利引擎实现
│   ├── batch_processor.rs        # 批量处理器
│   ├── metrics.rs                # 性能指标收集
│   ├── legacy_adapter.rs         # 旧代码适配器
│   └── utils.rs                  # 执行器工具函数
├── types/                        # 数据类型定义
│   ├── orders.rs                 # 订单相关类型
│   ├── positions.rs              # 仓位相关类型
│   ├── risk.rs                   # 风险相关类型
│   ├── arbitrage.rs              # 套利相关类型
│   └── execution.rs              # 执行相关类型
├── legacy_execution/             # 旧代码保留
│   ├── legacy_cross_exchange.rs  # 原cross_exchange.rs重命名
│   ├── legacy_core.rs            # 原core.rs执行部分
│   └── legacy_utils.rs           # 原utils.rs执行部分
└── config/
    └── execution.rs              # 执行器配置管理
```

## 12. 分阶段实施步骤

### 阶段1：基础设施搭建（1-2周）

#### 1.1 创建新目录结构
- 创建 `src/executors/` 目录及子模块
- 创建 `src/types/` 目录及类型定义文件
- 创建 `src/legacy_execution/` 目录

#### 1.2 保留旧代码
```bash
# 重命名现有文件，保持功能不变
mv src/cross_exchange.rs src/legacy_execution/legacy_cross_exchange.rs
cp src/core.rs src/legacy_execution/legacy_core.rs  # 保留执行相关部分
cp src/utils.rs src/legacy_execution/legacy_utils.rs  # 保留执行相关工具
```

#### 1.3 创建trait引用文件
```rust
// src/executors/traits.rs
pub use crate::traits::{
    OrderExecutor, RiskManager, PositionManager, OrderRouter
};
```

### 阶段2：适配器实现（2-3周）

#### 2.1 实现旧代码适配器
- 创建 `LegacyExecutorAdapter`
- 实现 `OrderExecutor` trait 的适配
- 实现 `RiskManager` trait 的适配
- 确保现有功能正常工作

#### 2.2 数据类型迁移
- 将 `exchange_types.rs` 中的类型迁移到 `src/types/`
- 创建新旧类型之间的转换函数
- 保持向后兼容性

### 阶段3：执行器迁移（3-4周）

#### 3.1 订单执行器重构
- 实现 `OrderExecutorImpl`
- 集成智能路由功能
- 添加批量处理支持
- 集成风险检查机制

#### 3.2 风险管理器重构
- 实现 `RiskManagerImpl`
- 区分现货和期货风控策略
- 添加实时监控功能
- 实现紧急停止机制

#### 3.3 仓位管理器重构
- 实现 `PositionManagerImpl`
- 统一多交易所仓位管理
- 实现实时同步机制
- 添加仓位风险评估

### 阶段4：集成优化（2-3周）

#### 4.1 套利引擎重构
- 重构现有套利逻辑
- 集成新的执行器接口
- 优化执行效率
- 添加性能监控

#### 4.2 性能优化
- 实现批量处理器
- 添加性能指标收集
- 优化并发执行
- 减少网络延迟

#### 4.3 集成测试
- 编写全面的集成测试
- 性能基准测试
- 压力测试
- 故障恢复测试

### 阶段5：清理和文档（1周）

#### 5.1 代码清理
- 移除未使用的旧代码
- 优化代码结构
- 统一代码风格
- 添加详细注释

#### 5.2 文档完善
- 更新API文档
- 编写使用指南
- 创建配置说明
- 添加故障排除指南

### 总时间预估：9-13周

### 风险控制措施
1. **渐进式迁移**：每个阶段都保持系统可运行状态
2. **并行开发**：新旧代码并存，逐步切换
3. **充分测试**：每个阶段都有对应的测试验证
4. **回滚机制**：出现问题时可快速回滚到旧版本
5. **监控告警**：实时监控系统运行状态，及时发现问题