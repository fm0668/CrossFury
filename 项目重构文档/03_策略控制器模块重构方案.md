# ç­–ç•¥æ§åˆ¶å™¨æ¨¡å—é‡æ„æ–¹æ¡ˆ

## 1. æ¨¡å—æ¦‚è¿°

ç­–ç•¥æ§åˆ¶å™¨æ¨¡å—æ˜¯ CrossFury ç³»ç»Ÿçš„å†³ç­–å¤§è„‘ï¼Œè´Ÿè´£ç­–ç•¥é€»è¾‘å®ç°ã€ç³»ç»Ÿç»„è£…ã€é…ç½®ç®¡ç†å’Œæ•´ä½“åè°ƒã€‚æœ¬æ¨¡å—é‡‡ç”¨**é…ç½®é©±åŠ¨æ¶æ„**ï¼Œå®ç°ç­–ç•¥çƒ­æ’æ‹”å’ŒåŠ¨æ€ç³»ç»Ÿç»„è£…ã€‚

**é‡è¦ï¼šæœ¬æ–¹æ¡ˆä¸¥æ ¼éµå¾ª `CrossFury_æ ¸å¿ƒTraitå®šä¹‰.md` ä¸­å®šä¹‰çš„æ¥å£è§„èŒƒã€‚**

### 1.1 æ ¸å¿ƒèŒè´£
- **ç­–ç•¥æ¡†æ¶**ï¼šæä¾›ç»Ÿä¸€çš„ç­–ç•¥å¼€å‘æ¥å£å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- **é…ç½®é©±åŠ¨ç»„è£…**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶åŠ¨æ€ç»„è£…ç³»ç»Ÿç»„ä»¶
- **äº‹ä»¶åè°ƒ**ï¼šåè°ƒè¿æ¥æ¨¡å—å’Œæ‰§è¡Œæ¨¡å—çš„æ•°æ®æµ
- **ç­–ç•¥çƒ­æ’æ‹”**ï¼šæ”¯æŒè¿è¡Œæ—¶ç­–ç•¥åŠ è½½ã€å¸è½½å’Œæ›´æ–°
- **ç³»ç»Ÿç›‘æ§**ï¼šæ•´ä½“ç³»ç»ŸçŠ¶æ€ç›‘æ§å’Œæ€§èƒ½è°ƒä¼˜
- **æ’ä»¶ç®¡ç†**ï¼šæ”¯æŒç¬¬ä¸‰æ–¹ç­–ç•¥æ’ä»¶

### 1.2 è®¾è®¡åŸåˆ™
- **é…ç½®é©±åŠ¨**ï¼šæ‰€æœ‰ç»„ä»¶é€šè¿‡é…ç½®æ–‡ä»¶ç»„è£…ï¼Œæ”¯æŒåŠ¨æ€é‡é…ç½®
- **æ’ä»¶åŒ–æ¶æ„**ï¼šç­–ç•¥ä½œä¸ºæ’ä»¶åŠ¨æ€åŠ è½½ï¼Œæ”¯æŒçƒ­æ›´æ–°
- **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºäº‹ä»¶æ€»çº¿çš„æ¾è€¦åˆæ¶æ„
- **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„ç›‘æ§ã€æ—¥å¿—å’Œè°ƒè¯•æ”¯æŒ
- **å®¹é”™æ€§**ï¼šå•ä¸ªç­–ç•¥æ•…éšœä¸å½±å“ç³»ç»Ÿæ•´ä½“è¿è¡Œ
- **Traitç»Ÿä¸€**ï¼šæ‰€æœ‰ç­–ç•¥å®ç° `Strategy` traitï¼Œç­–ç•¥ç®¡ç†å™¨å®ç° `StrategyManager` trait

### 1.3 æ—§ä»£ç æ›¿æ¢è§„åˆ’

#### 1.3.1 ç°æœ‰ä»£ç ç»“æ„åˆ†æ
```
å½“å‰ç­–ç•¥ç›¸å…³ä»£ç åˆ†æ•£åœ¨ï¼š
src/core.rs                  -> éƒ¨åˆ†ç­–ç•¥é€»è¾‘è¿ç§»åˆ° src/strategies/strategy_manager.rs
src/cross_exchange.rs        -> å¥—åˆ©ç­–ç•¥è¿ç§»åˆ° src/strategies/arbitrage_strategy.rs
src/config.rs                -> ç­–ç•¥é…ç½®è¿ç§»åˆ° src/strategies/config.rs
src/utils.rs                 -> ç­–ç•¥å·¥å…·å‡½æ•°è¿ç§»åˆ° src/strategies/utils.rs
```

#### 1.3.2 è¿ç§»ç­–ç•¥
1. **ä¿ç•™æ—§ä»£ç **ï¼šå°†ç°æœ‰ç­–ç•¥ç›¸å…³ä»£ç é‡å‘½åä¸º `legacy_*` å‰ç¼€
2. **åˆ›å»ºæ–°ç»“æ„**ï¼šæŒ‰ç…§æ–°çš„ç›®å½•ç»“æ„åˆ›å»ºç­–ç•¥æ¨¡å—
3. **é€æ­¥è¿ç§»**ï¼šæ¯ä¸ªç­–ç•¥å•ç‹¬è¿ç§»ï¼Œç¡®ä¿ç¼–è¯‘é€šè¿‡
4. **é€‚é…å™¨æ¨¡å¼**ï¼šä¸ºæ—§ä»£ç åˆ›å»ºé€‚é…å™¨ï¼Œå®ç°æ–°çš„ trait æ¥å£
5. **æ¸è¿›æ›¿æ¢**ï¼šæ–°ç­–ç•¥ä½¿ç”¨æ–°æ¥å£ï¼Œæ—§ç­–ç•¥ä¿æŒå…¼å®¹

## 2. ç­–ç•¥æ¡†æ¶è®¾è®¡

### 2.1 æ ¸å¿ƒ Trait å®šä¹‰

**æ‰€æœ‰æ ¸å¿ƒ trait å®šä¹‰å·²ç»Ÿä¸€åˆ° `CrossFury_æ ¸å¿ƒTraitå®šä¹‰.md`ï¼Œæœ¬æ¨¡å—ä¸¥æ ¼å®ç°ä»¥ä¸‹ traitï¼š**

- **`Strategy`**ï¼šç­–ç•¥æ¥å£ï¼Œå®šä¹‰ç­–ç•¥ç”Ÿå‘½å‘¨æœŸã€æ•°æ®å¤„ç†ã€æ‰§è¡Œåé¦ˆç­‰æ–¹æ³•
- **`StrategyManager`**ï¼šç­–ç•¥ç®¡ç†å™¨æ¥å£ï¼Œè´Ÿè´£ç­–ç•¥åŠ è½½ã€å¸è½½ã€ç›‘æ§ç­‰
- **`EventBus`**ï¼šäº‹ä»¶æ€»çº¿æ¥å£ï¼Œè´Ÿè´£äº‹ä»¶åˆ†å‘å’Œè®¢é˜…ç®¡ç†

### 2.2 æ ¸å¿ƒ Trait å®ç°è¦æ±‚

#### Strategy å®ç°è¦æ±‚
- å®ç°å®Œæ•´çš„ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å“åº”æ¨é€å¼æ•°æ®æµï¼ˆå¸‚åœºæ•°æ®ã€ç”¨æˆ·æ•°æ®ã€ç³»ç»Ÿäº‹ä»¶ï¼‰
- å¤„ç†æ‰§è¡Œåé¦ˆï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰
- æ”¯æŒåŠ¨æ€å‚æ•°è°ƒæ•´
- æä¾›é£é™©ç®¡ç†æ¥å£
- æ”¯æŒå®šæ—¶å™¨å’Œè‡ªå®šä¹‰äº‹ä»¶

#### StrategyManager å®ç°è¦æ±‚
- æ”¯æŒç­–ç•¥çƒ­æ’æ‹”ï¼ˆè¿è¡Œæ—¶åŠ è½½/å¸è½½ï¼‰
- æä¾›ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å®ç°ç­–ç•¥ç›‘æ§å’Œæ€§èƒ½ç»Ÿè®¡
- æ”¯æŒç­–ç•¥é…ç½®åŠ¨æ€æ›´æ–°
- æä¾›ç­–ç•¥é—´é€šä¿¡æœºåˆ¶

#### EventBus å®ç°è¦æ±‚
- é«˜æ€§èƒ½äº‹ä»¶åˆ†å‘æœºåˆ¶
- æ”¯æŒäº‹ä»¶ä¼˜å…ˆçº§å’Œè¿‡æ»¤
- æä¾›äº‹ä»¶æŒä¹…åŒ–å’Œé‡æ”¾
- æ”¯æŒäº‹ä»¶ç›‘æ§å’Œè°ƒè¯•

### 2.3 æ”¯æŒçš„ç­–ç•¥ç±»å‹

#### å¥—åˆ©ç­–ç•¥
- **ç°è´§å¥—åˆ©**ï¼šè·¨äº¤æ˜“æ‰€ç°è´§ä»·å·®å¥—åˆ©
- **æœŸè´§å¥—åˆ©**ï¼šæœŸè´§åˆçº¦é—´ä»·å·®å¥—åˆ©
- **è·¨å¸‚åœºå¥—åˆ©**ï¼šç°è´§ä¸æœŸè´§é—´å¥—åˆ©
- **ç»Ÿè®¡å¥—åˆ©**ï¼šåŸºäºç»Ÿè®¡æ¨¡å‹çš„é…å¯¹äº¤æ˜“

#### åšå¸‚ç­–ç•¥
- **ç½‘æ ¼åšå¸‚**ï¼šåŸºäºç½‘æ ¼çš„æµåŠ¨æ€§æä¾›
- **åŠ¨æ€åšå¸‚**ï¼šæ ¹æ®å¸‚åœºæ³¢åŠ¨è°ƒæ•´æŠ¥ä»·
- **è·¨äº¤æ˜“æ‰€åšå¸‚**ï¼šå¤šäº¤æ˜“æ‰€åŒæ—¶åšå¸‚

#### è¶‹åŠ¿ç­–ç•¥
- **åŠ¨é‡ç­–ç•¥**ï¼šåŸºäºä»·æ ¼åŠ¨é‡çš„è¶‹åŠ¿è·Ÿè¸ª
- **å‡å€¼å›å½’**ï¼šåŸºäºä»·æ ¼å‡å€¼å›å½’çš„åè½¬ç­–ç•¥
- **æŠ€æœ¯æŒ‡æ ‡ç­–ç•¥**ï¼šåŸºäºæŠ€æœ¯åˆ†ææŒ‡æ ‡çš„äº¤æ˜“

### 2.4 æ—§ä»£ç é€‚é…å™¨å®ç°

```rust
// src/strategies/legacy_adapter.rs
use crate::legacy_strategies::LegacyArbitrageStrategy;
use crate::traits::{Strategy, StrategyManager};

/// æ—§ä»£ç é€‚é…å™¨ï¼Œå°†ç°æœ‰ç­–ç•¥é€»è¾‘åŒ…è£…ä¸ºæ–°çš„ trait æ¥å£
pub struct LegacyStrategyAdapter {
    legacy_strategy: LegacyArbitrageStrategy,
    strategy_name: String,
}

#[async_trait]
impl Strategy for LegacyStrategyAdapter {
    fn get_strategy_name(&self) -> &str {
        &self.strategy_name
    }
    
    async fn on_market_data(&mut self, data: MarketDataEvent) -> Result<Vec<StrategySignal>, StrategyError> {
        // å°†æ–°çš„ MarketDataEvent è½¬æ¢ä¸ºæ—§çš„æ ¼å¼
        let legacy_data = self.convert_to_legacy_market_data(data)?;
        
        // è°ƒç”¨æ—§çš„ç­–ç•¥é€»è¾‘
        let legacy_signals = self.legacy_strategy.process_market_data(legacy_data).await?;
        
        // å°†æ—§çš„ä¿¡å·è½¬æ¢ä¸ºæ–°çš„æ ¼å¼
        self.convert_to_new_signals(legacy_signals)
    }
    
    // å…¶ä»–æ–¹æ³•çš„é€‚é…å®ç°...
}
```

### 2.2 ç­–ç•¥çŠ¶æ€ç®¡ç†

```rust
// src/strategies/state.rs
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum StrategyState {
    Uninitialized,
    Initializing,
    Ready,
    Running,
    Paused,
    Stopping,
    Stopped,
    Error { error: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyMetrics {
    pub total_signals: u64,
    pub successful_orders: u64,
    pub failed_orders: u64,
    pub total_pnl: Decimal,
    pub win_rate: f64,
    pub sharpe_ratio: Option<f64>,
    pub max_drawdown: Decimal,
    pub average_execution_time: Duration,
    pub last_signal_time: Option<DateTime<Utc>>,
    pub uptime: Duration,
    pub custom_metrics: HashMap<String, MetricValue>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MetricValue {
    Integer(i64),
    Float(f64),
    Decimal(Decimal),
    String(String),
    Boolean(bool),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskLimits {
    pub max_position_size: Option<Decimal>,
    pub max_daily_loss: Option<Decimal>,
    pub max_drawdown: Option<Decimal>,
    pub position_concentration_limit: Option<f64>,
    pub max_leverage: Option<Decimal>,
    pub allowed_symbols: Option<Vec<String>>,
    pub blocked_symbols: Option<Vec<String>>,
    pub trading_hours: Option<TradingHours>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingHours {
    pub start_time: String, // "09:00:00"
    pub end_time: String,   // "17:00:00"
    pub timezone: String,   // "UTC"
    pub trading_days: Vec<u8>, // [1,2,3,4,5] for Mon-Fri
}
```

### 2.3 ç­–ç•¥åŸºç±»å®ç°

```rust
// src/strategies/base_strategy.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use crate::strategies::traits::*;
use crate::strategies::state::*;

// ğŸ”¥ ç­–ç•¥åŸºç±»ï¼ˆæä¾›é€šç”¨åŠŸèƒ½ï¼‰
pub struct BaseStrategy {
    // åŸºæœ¬ä¿¡æ¯
    name: String,
    version: String,
    description: String,
    
    // çŠ¶æ€ç®¡ç†
    state: Arc<RwLock<StrategyState>>,
    config: Arc<RwLock<Option<StrategyConfig>>>,
    metrics: Arc<RwLock<StrategyMetrics>>,
    
    // å‚æ•°ç®¡ç†
    parameters: Arc<RwLock<HashMap<String, StrategyParameter>>>,
    
    // å®šæ—¶å™¨ç®¡ç†
    timers: Arc<Mutex<HashMap<String, tokio::task::JoinHandle<()>>>>,
    
    // æ—¥å¿—è®°å½•
    logger: Arc<StrategyLogger>,
}

impl BaseStrategy {
    pub fn new(name: String, version: String, description: String) -> Self {
        Self {
            name,
            version,
            description,
            state: Arc::new(RwLock::new(StrategyState::Uninitialized)),
            config: Arc::new(RwLock::new(None)),
            metrics: Arc::new(RwLock::new(StrategyMetrics::default())),
            parameters: Arc::new(RwLock::new(HashMap::new())),
            timers: Arc::new(Mutex::new(HashMap::new())),
            logger: Arc::new(StrategyLogger::new()),
        }
    }
    
    // ğŸ”¥ çŠ¶æ€è½¬æ¢æ–¹æ³•
    pub async fn set_state(&self, new_state: StrategyState) {
        let mut state = self.state.write().await;
        let old_state = state.clone();
        *state = new_state.clone();
        
        self.logger.info(&format!(
            "Strategy {} state changed: {:?} -> {:?}",
            self.name, old_state, new_state
        )).await;
    }
    
    // ğŸ”¥ å‚æ•°ç®¡ç†
    pub async fn get_parameter<T>(&self, key: &str) -> Option<T>
    where
        T: TryFrom<StrategyParameter>,
    {
        let parameters = self.parameters.read().await;
        if let Some(param) = parameters.get(key) {
            T::try_from(param.clone()).ok()
        } else {
            None
        }
    }
    
    pub async fn set_parameter(&self, key: String, value: StrategyParameter) {
        let mut parameters = self.parameters.write().await;
        parameters.insert(key, value);
    }
    
    // ğŸ”¥ æŒ‡æ ‡æ›´æ–°
    pub async fn update_metrics<F>(&self, updater: F)
    where
        F: FnOnce(&mut StrategyMetrics),
    {
        let mut metrics = self.metrics.write().await;
        updater(&mut *metrics);
    }
    
    // ğŸ”¥ å®šæ—¶å™¨ç®¡ç†
    pub async fn set_timer(&self, timer_id: String, interval: Duration, callback: impl Fn() + Send + 'static) {
        let mut timers = self.timers.lock().await;
        
        // å–æ¶ˆç°æœ‰å®šæ—¶å™¨
        if let Some(handle) = timers.remove(&timer_id) {
            handle.abort();
        }
        
        // åˆ›å»ºæ–°å®šæ—¶å™¨
        let handle = tokio::spawn(async move {
            let mut interval_timer = tokio::time::interval(interval);
            loop {
                interval_timer.tick().await;
                callback();
            }
        });
        
        timers.insert(timer_id, handle);
    }
    
    pub async fn cancel_timer(&self, timer_id: &str) {
        let mut timers = self.timers.lock().await;
        if let Some(handle) = timers.remove(timer_id) {
            handle.abort();
        }
    }
    
    // ğŸ”¥ æ—¥å¿—æ–¹æ³•
    pub async fn log_info(&self, message: &str) {
        self.logger.info(&format!("[{}] {}", self.name, message)).await;
    }
    
    pub async fn log_warn(&self, message: &str) {
        self.logger.warn(&format!("[{}] {}", self.name, message)).await;
    }
    
    pub async fn log_error(&self, message: &str) {
        self.logger.error(&format!("[{}] {}", self.name, message)).await;
    }
}

// ğŸ”¥ ç­–ç•¥æ—¥å¿—è®°å½•å™¨
pub struct StrategyLogger {
    // å®ç°ç­–ç•¥ä¸“ç”¨çš„æ—¥å¿—è®°å½•
}

impl StrategyLogger {
    pub fn new() -> Self {
        Self {}
    }
    
    pub async fn info(&self, message: &str) {
        log::info!("{}", message);
    }
    
    pub async fn warn(&self, message: &str) {
        log::warn!("{}", message);
    }
    
    pub async fn error(&self, message: &str) {
        log::error!("{}", message);
    }
}
```

## 3. é…ç½®é©±åŠ¨ç³»ç»Ÿç»„è£…

### 3.1 ç³»ç»Ÿé…ç½®å®šä¹‰

```rust
// src/config/system_config.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use crate::connectors::ConnectorConfig;
use crate::executors::ExecutorConfig;
use crate::strategies::StrategyConfig;

// ğŸ”¥ ç³»ç»Ÿæ€»é…ç½®ï¼ˆé…ç½®é©±åŠ¨çš„æ ¸å¿ƒï¼‰
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemConfig {
    pub system: SystemSettings,
    pub connectors: ConnectorConfig,
    pub executors: ExecutorConfig,
    pub strategies: HashMap<String, StrategyConfig>,
    pub event_bus: EventBusConfig,
    pub monitoring: MonitoringConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemSettings {
    pub name: String,
    pub version: String,
    pub environment: Environment,
    pub data_directory: String,
    pub log_directory: String,
    pub plugin_directory: String,
    pub max_memory_usage: Option<u64>, // bytes
    pub max_cpu_usage: Option<f64>,    // percentage
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum Environment {
    Development,
    Testing,
    Staging,
    Production,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventBusConfig {
    pub high_frequency_buffer_size: usize,
    pub event_buffer_size: usize,
    pub max_subscribers: usize,
    pub enable_persistence: bool,
    pub persistence_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub enabled: bool,
    pub metrics_port: u16,
    pub health_check_interval: Duration,
    pub performance_sampling_rate: f64,
    pub alert_thresholds: AlertThresholds,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertThresholds {
    pub max_memory_usage: f64,
    pub max_cpu_usage: f64,
    pub max_error_rate: f64,
    pub min_uptime: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub format: LogFormat,
    pub output: Vec<LogOutput>,
    pub rotation: LogRotation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogFormat {
    Json,
    Text,
    Structured,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogOutput {
    Console,
    File { path: String },
    Network { endpoint: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogRotation {
    pub max_size: String,    // "100MB"
    pub max_files: u32,
    pub compress: bool,
}
```

### 3.2 åŠ¨æ€ç³»ç»Ÿç»„è£…å™¨

```rust
// src/config/system_assembler.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::config::SystemConfig;
use crate::connectors::{ConnectorManager, ExchangeConnector};
use crate::executors::{OrderExecutor, RiskManager, ArbitrageEngine};
use crate::strategies::{Strategy, StrategyManager};
use crate::event_bus::EventBus;

// ğŸ”¥ ç³»ç»Ÿç»„è£…å™¨ï¼ˆé…ç½®é©±åŠ¨çš„æ ¸å¿ƒå®ç°ï¼‰
pub struct SystemAssembler {
    config: Arc<RwLock<SystemConfig>>,
    component_registry: Arc<ComponentRegistry>,
    plugin_loader: Arc<PluginLoader>,
}

// ğŸ”¥ ç»„ä»¶æ³¨å†Œè¡¨
pub struct ComponentRegistry {
    connector_factories: HashMap<String, Box<dyn ConnectorFactory>>,
    executor_factories: HashMap<String, Box<dyn ExecutorFactory>>,
    strategy_factories: HashMap<String, Box<dyn StrategyFactory>>,
}

// ğŸ”¥ ç»„ä»¶å·¥å‚æ¥å£
pub trait ConnectorFactory: Send + Sync {
    fn create_connector(&self, config: &ConnectorConfig) -> Result<Box<dyn ExchangeConnector>, AssemblyError>;
    fn get_connector_type(&self) -> &str;
}

pub trait ExecutorFactory: Send + Sync {
    fn create_executor(&self, config: &ExecutorConfig) -> Result<Box<dyn OrderExecutor>, AssemblyError>;
    fn get_executor_type(&self) -> &str;
}

pub trait StrategyFactory: Send + Sync {
    fn create_strategy(&self, config: &StrategyConfig) -> Result<Box<dyn Strategy>, AssemblyError>;
    fn get_strategy_type(&self) -> &str;
    fn get_strategy_metadata(&self) -> StrategyMetadata;
}

#[derive(Debug, Clone)]
pub struct StrategyMetadata {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub supported_markets: Vec<MarketType>,
    pub required_parameters: Vec<ParameterDefinition>,
}

#[derive(Debug, Clone)]
pub struct ParameterDefinition {
    pub name: String,
    pub parameter_type: String,
    pub required: bool,
    pub default_value: Option<StrategyParameter>,
    pub description: String,
    pub validation_rules: Vec<ValidationRule>,
}

impl SystemAssembler {
    pub fn new() -> Self {
        Self {
            config: Arc::new(RwLock::new(SystemConfig::default())),
            component_registry: Arc::new(ComponentRegistry::new()),
            plugin_loader: Arc::new(PluginLoader::new()),
        }
    }
    
    // ğŸ”¥ ä»é…ç½®æ–‡ä»¶ç»„è£…æ•´ä¸ªç³»ç»Ÿ
    pub async fn assemble_system(&self, config_path: &str) -> Result<AssembledSystem, AssemblyError> {
        // 1. åŠ è½½é…ç½®
        let config = self.load_config(config_path).await?;
        *self.config.write().await = config.clone();
        
        // 2. åˆå§‹åŒ–äº‹ä»¶æ€»çº¿
        let event_bus = self.create_event_bus(&config.event_bus).await?;
        
        // 3. ç»„è£…è¿æ¥å™¨
        let connector_manager = self.assemble_connectors(&config.connectors, event_bus.clone()).await?;
        
        // 4. ç»„è£…æ‰§è¡Œå™¨
        let executor_manager = self.assemble_executors(&config.executors, connector_manager.clone()).await?;
        
        // 5. ç»„è£…ç­–ç•¥
        let strategy_manager = self.assemble_strategies(&config.strategies, event_bus.clone(), executor_manager.clone()).await?;
        
        // 6. åˆ›å»ºç³»ç»Ÿæ§åˆ¶å™¨
        let system_controller = SystemController::new(
            config.clone(),
            event_bus.clone(),
            connector_manager,
            executor_manager,
            strategy_manager,
        );
        
        Ok(AssembledSystem {
            config,
            event_bus,
            system_controller,
        })
    }
    
    // ğŸ”¥ çƒ­é‡è½½é…ç½®
    pub async fn reload_config(&self, config_path: &str) -> Result<(), AssemblyError> {
        let new_config = self.load_config(config_path).await?;
        let old_config = self.config.read().await.clone();
        
        // æ¯”è¾ƒé…ç½®å·®å¼‚
        let diff = self.compare_configs(&old_config, &new_config);
        
        // åº”ç”¨é…ç½®å˜æ›´
        self.apply_config_changes(diff).await?;
        
        // æ›´æ–°é…ç½®
        *self.config.write().await = new_config;
        
        Ok(())
    }
    
    // ğŸ”¥ æ³¨å†Œç»„ä»¶å·¥å‚
    pub async fn register_connector_factory(&self, factory: Box<dyn ConnectorFactory>) {
        let mut registry = self.component_registry.write().await;
        registry.connector_factories.insert(
            factory.get_connector_type().to_string(),
            factory
        );
    }
    
    pub async fn register_strategy_factory(&self, factory: Box<dyn StrategyFactory>) {
        let mut registry = self.component_registry.write().await;
        registry.strategy_factories.insert(
            factory.get_strategy_type().to_string(),
            factory
        );
    }
    
    // ğŸ”¥ åŠ¨æ€åŠ è½½æ’ä»¶
    pub async fn load_plugin(&self, plugin_path: &str) -> Result<(), AssemblyError> {
        self.plugin_loader.load_plugin(plugin_path).await
    }
    
    // ç§æœ‰æ–¹æ³•å®ç°...
    async fn load_config(&self, config_path: &str) -> Result<SystemConfig, AssemblyError> {
        let config_content = tokio::fs::read_to_string(config_path).await
            .map_err(|e| AssemblyError::ConfigLoadError(e.to_string()))?;
        
        // æ”¯æŒå¤šç§é…ç½®æ ¼å¼
        if config_path.ends_with(".toml") {
            toml::from_str(&config_content)
                .map_err(|e| AssemblyError::ConfigParseError(e.to_string()))
        } else if config_path.ends_with(".yaml") || config_path.ends_with(".yml") {
            serde_yaml::from_str(&config_content)
                .map_err(|e| AssemblyError::ConfigParseError(e.to_string()))
        } else if config_path.ends_with(".json") {
            serde_json::from_str(&config_content)
                .map_err(|e| AssemblyError::ConfigParseError(e.to_string()))
        } else {
            Err(AssemblyError::UnsupportedConfigFormat(config_path.to_string()))
        }
    }
    
    async fn assemble_connectors(
        &self,
        config: &ConnectorConfig,
        event_bus: Arc<EventBus>
    ) -> Result<Arc<ConnectorManager>, AssemblyError> {
        let connector_manager = Arc::new(ConnectorManager::new(event_bus));
        
        // æ ¹æ®é…ç½®åˆ›å»ºå„ä¸ªè¿æ¥å™¨
        if let Some(binance_config) = &config.binance {
            if binance_config.enabled {
                for &market_type in &binance_config.markets {
                    let connector = self.create_binance_connector(binance_config, market_type)?;
                    let connector_name = format!("binance_{:?}", market_type).to_lowercase();
                    connector_manager.add_connector(connector_name, connector).await;
                }
            }
        }
        
        // ç±»ä¼¼åœ°å¤„ç†å…¶ä»–äº¤æ˜“æ‰€...
        
        Ok(connector_manager)
    }
    
    async fn assemble_strategies(
        &self,
        configs: &HashMap<String, StrategyConfig>,
        event_bus: Arc<EventBus>,
        executor_manager: Arc<ExecutorManager>
    ) -> Result<Arc<StrategyManager>, AssemblyError> {
        let strategy_manager = Arc::new(StrategyManager::new(event_bus, executor_manager));
        
        for (strategy_name, strategy_config) in configs {
            if strategy_config.enabled {
                let strategy = self.create_strategy(strategy_config).await?;
                strategy_manager.add_strategy(strategy_name.clone(), strategy).await?;
            }
        }
        
        Ok(strategy_manager)
    }
}

// ğŸ”¥ ç»„è£…åçš„ç³»ç»Ÿ
pub struct AssembledSystem {
    pub config: SystemConfig,
    pub event_bus: Arc<EventBus>,
    pub system_controller: SystemController,
}

impl AssembledSystem {
    // ğŸ”¥ å¯åŠ¨æ•´ä¸ªç³»ç»Ÿ
    pub async fn start(&self) -> Result<(), SystemError> {
        self.system_controller.start().await
    }
    
    // ğŸ”¥ åœæ­¢æ•´ä¸ªç³»ç»Ÿ
    pub async fn stop(&self) -> Result<(), SystemError> {
        self.system_controller.stop().await
    }
    
    // ğŸ”¥ è·å–ç³»ç»ŸçŠ¶æ€
    pub async fn get_system_status(&self) -> SystemStatus {
        self.system_controller.get_system_status().await
    }
}
```

### 3.3 æ’ä»¶åŠ è½½å™¨

```rust
// src/config/plugin_loader.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

// ğŸ”¥ æ’ä»¶åŠ è½½å™¨ï¼ˆæ”¯æŒç­–ç•¥çƒ­æ’æ‹”ï¼‰
pub struct PluginLoader {
    loaded_plugins: Arc<RwLock<HashMap<String, LoadedPlugin>>>,
    plugin_registry: Arc<RwLock<PluginRegistry>>,
}

#[derive(Debug)]
pub struct LoadedPlugin {
    pub name: String,
    pub version: String,
    pub path: String,
    pub loaded_at: DateTime<Utc>,
    pub plugin_handle: PluginHandle,
}

// ğŸ”¥ æ’ä»¶æ³¨å†Œè¡¨
pub struct PluginRegistry {
    strategy_plugins: HashMap<String, StrategyPluginInfo>,
    connector_plugins: HashMap<String, ConnectorPluginInfo>,
}

#[derive(Debug, Clone)]
pub struct StrategyPluginInfo {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub supported_markets: Vec<MarketType>,
    pub entry_point: String,
    pub dependencies: Vec<String>,
}

impl PluginLoader {
    pub fn new() -> Self {
        Self {
            loaded_plugins: Arc::new(RwLock::new(HashMap::new())),
            plugin_registry: Arc::new(RwLock::new(PluginRegistry::new())),
        }
    }
    
    // ğŸ”¥ åŠ è½½ç­–ç•¥æ’ä»¶
    pub async fn load_strategy_plugin(&self, plugin_path: &str) -> Result<String, PluginError> {
        // 1. éªŒè¯æ’ä»¶æ–‡ä»¶
        self.validate_plugin_file(plugin_path).await?;
        
        // 2. è¯»å–æ’ä»¶å…ƒæ•°æ®
        let plugin_info = self.read_plugin_metadata(plugin_path).await?;
        
        // 3. æ£€æŸ¥ä¾èµ–
        self.check_plugin_dependencies(&plugin_info.dependencies).await?;
        
        // 4. åŠ è½½æ’ä»¶
        let plugin_handle = self.load_plugin_binary(plugin_path).await?;
        
        // 5. æ³¨å†Œæ’ä»¶
        let plugin_id = format!("{}_{}", plugin_info.name, plugin_info.version);
        let loaded_plugin = LoadedPlugin {
            name: plugin_info.name.clone(),
            version: plugin_info.version.clone(),
            path: plugin_path.to_string(),
            loaded_at: Utc::now(),
            plugin_handle,
        };
        
        {
            let mut plugins = self.loaded_plugins.write().await;
            plugins.insert(plugin_id.clone(), loaded_plugin);
        }
        
        {
            let mut registry = self.plugin_registry.write().await;
            registry.strategy_plugins.insert(plugin_info.name.clone(), plugin_info);
        }
        
        Ok(plugin_id)
    }
    
    // ğŸ”¥ å¸è½½æ’ä»¶
    pub async fn unload_plugin(&self, plugin_id: &str) -> Result<(), PluginError> {
        let mut plugins = self.loaded_plugins.write().await;
        
        if let Some(plugin) = plugins.remove(plugin_id) {
            // å®‰å…¨å¸è½½æ’ä»¶
            plugin.plugin_handle.unload().await?;
            
            // ä»æ³¨å†Œè¡¨ä¸­ç§»é™¤
            let mut registry = self.plugin_registry.write().await;
            registry.strategy_plugins.remove(&plugin.name);
            
            Ok(())
        } else {
            Err(PluginError::PluginNotFound(plugin_id.to_string()))
        }
    }
    
    // ğŸ”¥ çƒ­æ›´æ–°æ’ä»¶
    pub async fn reload_plugin(&self, plugin_id: &str, new_plugin_path: &str) -> Result<(), PluginError> {
        // 1. å¸è½½æ—§æ’ä»¶
        self.unload_plugin(plugin_id).await?;
        
        // 2. åŠ è½½æ–°æ’ä»¶
        self.load_strategy_plugin(new_plugin_path).await?;
        
        Ok(())
    }
    
    // ğŸ”¥ è·å–å·²åŠ è½½æ’ä»¶åˆ—è¡¨
    pub async fn get_loaded_plugins(&self) -> Vec<LoadedPlugin> {
        let plugins = self.loaded_plugins.read().await;
        plugins.values().cloned().collect()
    }
    
    // ğŸ”¥ è·å–å¯ç”¨ç­–ç•¥æ’ä»¶
    pub async fn get_available_strategies(&self) -> Vec<StrategyPluginInfo> {
        let registry = self.plugin_registry.read().await;
        registry.strategy_plugins.values().cloned().collect()
    }
    
    // ç§æœ‰æ–¹æ³•å®ç°...
    async fn validate_plugin_file(&self, plugin_path: &str) -> Result<(), PluginError> {
        // éªŒè¯æ–‡ä»¶å­˜åœ¨æ€§ã€æƒé™ã€ç­¾åç­‰
        if !tokio::fs::metadata(plugin_path).await.is_ok() {
            return Err(PluginError::FileNotFound(plugin_path.to_string()));
        }
        
        // å¯ä»¥æ·»åŠ æ›´å¤šéªŒè¯é€»è¾‘ï¼Œå¦‚æ•°å­—ç­¾åéªŒè¯
        Ok(())
    }
    
    async fn read_plugin_metadata(&self, plugin_path: &str) -> Result<StrategyPluginInfo, PluginError> {
        // è¯»å–æ’ä»¶çš„å…ƒæ•°æ®æ–‡ä»¶ï¼ˆå¦‚ plugin.tomlï¼‰
        let metadata_path = format!("{}/plugin.toml", plugin_path);
        let metadata_content = tokio::fs::read_to_string(metadata_path).await
            .map_err(|e| PluginError::MetadataReadError(e.to_string()))?;
        
        toml::from_str(&metadata_content)
            .map_err(|e| PluginError::MetadataParseError(e.to_string()))
    }
}
```

## 4. ç³»ç»Ÿæ§åˆ¶å™¨

### 4.1 ä¸»æ§åˆ¶å™¨è®¾è®¡

```rust
// src/controller/system_controller.rs
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use crate::config::SystemConfig;
use crate::event_bus::EventBus;
use crate::connectors::ConnectorManager;
use crate::executors::ExecutorManager;
use crate::strategies::StrategyManager;

// ğŸ”¥ ç³»ç»Ÿä¸»æ§åˆ¶å™¨
pub struct SystemController {
    config: Arc<RwLock<SystemConfig>>,
    event_bus: Arc<EventBus>,
    connector_manager: Arc<ConnectorManager>,
    executor_manager: Arc<ExecutorManager>,
    strategy_manager: Arc<StrategyManager>,
    
    // ç³»ç»ŸçŠ¶æ€
    system_state: Arc<RwLock<SystemState>>,
    
    // ç›‘æ§å’ŒæŒ‡æ ‡
    system_monitor: Arc<SystemMonitor>,
    performance_tracker: Arc<PerformanceTracker>,
    
    // æ§åˆ¶ä»»åŠ¡
    control_tasks: Arc<Mutex<Vec<tokio::task::JoinHandle<()>>>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum SystemState {
    Uninitialized,
    Initializing,
    Starting,
    Running,
    Pausing,
    Paused,
    Stopping,
    Stopped,
    Error { error: String },
}

#[derive(Debug, Clone)]
pub struct SystemStatus {
    pub state: SystemState,
    pub uptime: Duration,
    pub connector_status: HashMap<String, ConnectionStatus>,
    pub strategy_status: HashMap<String, StrategyState>,
    pub system_metrics: SystemMetrics,
    pub resource_usage: ResourceUsage,
}

#[derive(Debug, Clone)]
pub struct SystemMetrics {
    pub total_orders: u64,
    pub successful_orders: u64,
    pub failed_orders: u64,
    pub total_volume: Decimal,
    pub total_pnl: Decimal,
    pub active_strategies: u32,
    pub active_connections: u32,
    pub events_processed: u64,
    pub average_latency: Duration,
}

#[derive(Debug, Clone)]
pub struct ResourceUsage {
    pub memory_usage: u64,      // bytes
    pub cpu_usage: f64,         // percentage
    pub network_io: NetworkIO,
    pub disk_io: DiskIO,
}

impl SystemController {
    pub fn new(
        config: SystemConfig,
        event_bus: Arc<EventBus>,
        connector_manager: Arc<ConnectorManager>,
        executor_manager: Arc<ExecutorManager>,
        strategy_manager: Arc<StrategyManager>,
    ) -> Self {
        Self {
            config: Arc::new(RwLock::new(config)),
            event_bus: event_bus.clone(),
            connector_manager,
            executor_manager,
            strategy_manager,
            system_state: Arc::new(RwLock::new(SystemState::Uninitialized)),
            system_monitor: Arc::new(SystemMonitor::new(event_bus.clone())),
            performance_tracker: Arc::new(PerformanceTracker::new()),
            control_tasks: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    // ğŸ”¥ å¯åŠ¨ç³»ç»Ÿ
    pub async fn start(&self) -> Result<(), SystemError> {
        self.set_system_state(SystemState::Starting).await;
        
        // 1. å¯åŠ¨äº‹ä»¶æ€»çº¿
        self.event_bus.start().await?;
        
        // 2. å¯åŠ¨è¿æ¥å™¨ç®¡ç†å™¨
        self.connector_manager.start().await?;
        
        // 3. å¯åŠ¨æ‰§è¡Œå™¨ç®¡ç†å™¨
        self.executor_manager.start().await?;
        
        // 4. å¯åŠ¨ç­–ç•¥ç®¡ç†å™¨
        self.strategy_manager.start().await?;
        
        // 5. å¯åŠ¨ç³»ç»Ÿç›‘æ§
        self.start_system_monitoring().await?;
        
        // 6. å¯åŠ¨äº‹ä»¶å¤„ç†å¾ªç¯
        self.start_event_processing().await?;
        
        self.set_system_state(SystemState::Running).await;
        
        log::info!("CrossFury system started successfully");
        Ok(())
    }
    
    // ğŸ”¥ åœæ­¢ç³»ç»Ÿ
    pub async fn stop(&self) -> Result<(), SystemError> {
        self.set_system_state(SystemState::Stopping).await;
        
        // 1. åœæ­¢ç­–ç•¥ç®¡ç†å™¨
        self.strategy_manager.stop().await?;
        
        // 2. åœæ­¢æ‰§è¡Œå™¨ç®¡ç†å™¨
        self.executor_manager.stop().await?;
        
        // 3. åœæ­¢è¿æ¥å™¨ç®¡ç†å™¨
        self.connector_manager.stop().await?;
        
        // 4. åœæ­¢æ§åˆ¶ä»»åŠ¡
        self.stop_control_tasks().await;
        
        // 5. åœæ­¢äº‹ä»¶æ€»çº¿
        self.event_bus.stop().await?;
        
        self.set_system_state(SystemState::Stopped).await;
        
        log::info!("CrossFury system stopped successfully");
        Ok(())
    }
    
    // ğŸ”¥ æš‚åœç³»ç»Ÿ
    pub async fn pause(&self) -> Result<(), SystemError> {
        self.set_system_state(SystemState::Pausing).await;
        
        // æš‚åœç­–ç•¥æ‰§è¡Œ
        self.strategy_manager.pause_all().await?;
        
        self.set_system_state(SystemState::Paused).await;
        Ok(())
    }
    
    // ğŸ”¥ æ¢å¤ç³»ç»Ÿ
    pub async fn resume(&self) -> Result<(), SystemError> {
        if *self.system_state.read().await == SystemState::Paused {
            // æ¢å¤ç­–ç•¥æ‰§è¡Œ
            self.strategy_manager.resume_all().await?;
            
            self.set_system_state(SystemState::Running).await;
        }
        Ok(())
    }
    
    // ğŸ”¥ è·å–ç³»ç»ŸçŠ¶æ€
    pub async fn get_system_status(&self) -> SystemStatus {
        let state = self.system_state.read().await.clone();
        let uptime = self.performance_tracker.get_uptime().await;
        let connector_status = self.connector_manager.get_all_status().await;
        let strategy_status = self.strategy_manager.get_all_status().await;
        let system_metrics = self.collect_system_metrics().await;
        let resource_usage = self.system_monitor.get_resource_usage().await;
        
        SystemStatus {
            state,
            uptime,
            connector_status,
            strategy_status,
            system_metrics,
            resource_usage,
        }
    }
    
    // ğŸ”¥ åŠ¨æ€æ·»åŠ ç­–ç•¥
    pub async fn add_strategy(&self, name: String, config: StrategyConfig) -> Result<(), SystemError> {
        self.strategy_manager.add_strategy_from_config(name, config).await
            .map_err(|e| SystemError::StrategyError(e.to_string()))
    }
    
    // ğŸ”¥ åŠ¨æ€ç§»é™¤ç­–ç•¥
    pub async fn remove_strategy(&self, name: &str) -> Result<(), SystemError> {
        self.strategy_manager.remove_strategy(name).await
            .map_err(|e| SystemError::StrategyError(e.to_string()))
    }
    
    // ğŸ”¥ æ›´æ–°ç­–ç•¥å‚æ•°
    pub async fn update_strategy_parameters(
        &self,
        strategy_name: &str,
        parameters: HashMap<String, StrategyParameter>
    ) -> Result<(), SystemError> {
        self.strategy_manager.update_strategy_parameters(strategy_name, parameters).await
            .map_err(|e| SystemError::StrategyError(e.to_string()))
    }
    
    // ç§æœ‰æ–¹æ³•å®ç°...
    async fn set_system_state(&self, new_state: SystemState) {
        let mut state = self.system_state.write().await;
        let old_state = state.clone();
        *state = new_state.clone();
        
        log::info!("System state changed: {:?} -> {:?}", old_state, new_state);
        
        // å‘é€ç³»ç»ŸçŠ¶æ€å˜æ›´äº‹ä»¶
        self.event_bus.publish_system_event(SystemEvent::StateChanged {
            old_state,
            new_state,
        }).await;
    }
    
    async fn start_system_monitoring(&self) -> Result<(), SystemError> {
        let monitor = self.system_monitor.clone();
        let config = self.config.read().await.clone();
        
        let monitoring_task = tokio::spawn(async move {
            monitor.start_monitoring(config.monitoring).await;
        });
        
        let mut tasks = self.control_tasks.lock().await;
        tasks.push(monitoring_task);
        
        Ok(())
    }
    
    async fn start_event_processing(&self) -> Result<(), SystemError> {
        let event_bus = self.event_bus.clone();
        let strategy_manager = self.strategy_manager.clone();
        
        // å¯åŠ¨é«˜é¢‘æ•°æ®å¤„ç†
        let high_freq_task = tokio::spawn(async move {
            let mut receiver = event_bus.subscribe_high_frequency_data().await;
            
            while let Some(data) = receiver.recv().await {
                if let Err(e) = strategy_manager.process_market_data(data).await {
                    log::error!("Error processing market data: {:?}", e);
                }
            }
        });
        
        // å¯åŠ¨ç³»ç»Ÿäº‹ä»¶å¤„ç†
        let system_event_task = tokio::spawn(async move {
            let mut receiver = event_bus.subscribe_system_events().await;
            
            while let Ok(event) = receiver.recv().await {
                if let Err(e) = strategy_manager.process_system_event(event).await {
                    log::error!("Error processing system event: {:?}", e);
                }
            }
        });
        
        let mut tasks = self.control_tasks.lock().await;
        tasks.push(high_freq_task);
        tasks.push(system_event_task);
        
        Ok(())
    }
    
    async fn stop_control_tasks(&self) {
        let mut tasks = self.control_tasks.lock().await;
        
        for task in tasks.drain(..) {
            task.abort();
        }
    }
    
    async fn collect_system_metrics(&self) -> SystemMetrics {
        // æ”¶é›†å„æ¨¡å—çš„æŒ‡æ ‡å¹¶æ±‡æ€»
        let connector_metrics = self.connector_manager.get_metrics().await;
        let executor_metrics = self.executor_manager.get_metrics().await;
        let strategy_metrics = self.strategy_manager.get_metrics().await;
        
        SystemMetrics {
            total_orders: executor_metrics.total_orders,
            successful_orders: executor_metrics.successful_orders,
            failed_orders: executor_metrics.failed_orders,
            total_volume: executor_metrics.total_volume,
            total_pnl: strategy_metrics.total_pnl,
            active_strategies: strategy_metrics.active_strategies,
            active_connections: connector_metrics.active_connections,
            events_processed: self.event_bus.get_processed_events_count().await,
            average_latency: executor_metrics.average_latency,
        }
    }
}
```

## 5. ç­–ç•¥ç®¡ç†å™¨

### 5.1 ç­–ç•¥ç®¡ç†å™¨å®ç°

```rust
// src/strategies/strategy_manager.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use crate::strategies::traits::*;
use crate::strategies::state::*;
use crate::event_bus::EventBus;
use crate::executors::ExecutorManager;

// ğŸ”¥ ç­–ç•¥ç®¡ç†å™¨
pub struct StrategyManager {
    strategies: Arc<RwLock<HashMap<String, Arc<Mutex<Box<dyn Strategy>>>>>>,
    strategy_states: Arc<RwLock<HashMap<String, StrategyState>>>,
    event_bus: Arc<EventBus>,
    executor_manager: Arc<ExecutorManager>,
    
    // ç­–ç•¥æ‰§è¡Œä»»åŠ¡
    strategy_tasks: Arc<Mutex<HashMap<String, tokio::task::JoinHandle<()>>>>,
    
    // ç­–ç•¥æŒ‡æ ‡
    strategy_metrics: Arc<RwLock<HashMap<String, StrategyMetrics>>>,
}

impl StrategyManager {
    pub fn new(
        event_bus: Arc<EventBus>,
        executor_manager: Arc<ExecutorManager>
    ) -> Self {
        Self {
            strategies: Arc::new(RwLock::new(HashMap::new())),
            strategy_states: Arc::new(RwLock::new(HashMap::new())),
            event_bus,
            executor_manager,
            strategy_tasks: Arc::new(Mutex::new(HashMap::new())),
            strategy_metrics: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    // ğŸ”¥ æ·»åŠ ç­–ç•¥
    pub async fn add_strategy(
        &self,
        name: String,
        strategy: Box<dyn Strategy>
    ) -> Result<(), StrategyError> {
        // 1. åˆå§‹åŒ–ç­–ç•¥
        let mut strategy = strategy;
        strategy.initialize(StrategyConfig::default()).await?;
        
        // 2. æ·»åŠ åˆ°ç®¡ç†å™¨
        {
            let mut strategies = self.strategies.write().await;
            strategies.insert(name.clone(), Arc::new(Mutex::new(strategy)));
        }
        
        // 3. è®¾ç½®åˆå§‹çŠ¶æ€
        {
            let mut states = self.strategy_states.write().await;
            states.insert(name.clone(), StrategyState::Ready);
        }
        
        // 4. åˆå§‹åŒ–æŒ‡æ ‡
        {
            let mut metrics = self.strategy_metrics.write().await;
            metrics.insert(name.clone(), StrategyMetrics::default());
        }
        
        log::info!("Strategy '{}' added successfully", name);
        Ok(())
    }
    
    // ğŸ”¥ å¯åŠ¨ç­–ç•¥
    pub async fn start_strategy(&self, name: &str) -> Result<(), StrategyError> {
        let strategy = {
            let strategies = self.strategies.read().await;
            strategies.get(name).cloned()
                .ok_or_else(|| StrategyError::StrategyNotFound(name.to_string()))?
        };
        
        // å¯åŠ¨ç­–ç•¥
        {
            let mut strategy = strategy.lock().await;
            strategy.start().await?;
        }
        
        // æ›´æ–°çŠ¶æ€
        {
            let mut states = self.strategy_states.write().await;
            states.insert(name.to_string(), StrategyState::Running);
        }
        
        // å¯åŠ¨ç­–ç•¥äº‹ä»¶å¤„ç†ä»»åŠ¡
        self.start_strategy_task(name.to_string(), strategy).await;
        
        log::info!("Strategy '{}' started", name);
        Ok(())
    }
    
    // ğŸ”¥ åœæ­¢ç­–ç•¥
    pub async fn stop_strategy(&self, name: &str) -> Result<(), StrategyError> {
        // 1. åœæ­¢ç­–ç•¥ä»»åŠ¡
        {
            let mut tasks = self.strategy_tasks.lock().await;
            if let Some(task) = tasks.remove(name) {
                task.abort();
            }
        }
        
        // 2. åœæ­¢ç­–ç•¥
        let strategies = self.strategies.read().await;
        if let Some(strategy) = strategies.get(name) {
            let mut strategy = strategy.lock().await;
            strategy.stop().await?;
        }
        
        // 3. æ›´æ–°çŠ¶æ€
        {
            let mut states = self.strategy_states.write().await;
            states.insert(name.to_string(), StrategyState::Stopped);
        }
        
        log::info!("Strategy '{}' stopped", name);
        Ok(())
    }
    
    // ğŸ”¥ å¤„ç†å¸‚åœºæ•°æ®
    pub async fn process_market_data(&self, data: HighFrequencyData) -> Result<(), StrategyError> {
        let strategies = self.strategies.read().await;
        
        for (name, strategy) in strategies.iter() {
            let strategy = strategy.clone();
            let data = data.clone();
            let executor_manager = self.executor_manager.clone();
            let name = name.clone();
            
            // å¼‚æ­¥å¤„ç†æ¯ä¸ªç­–ç•¥
            tokio::spawn(async move {
                let mut strategy = strategy.lock().await;
                
                match strategy.on_market_data(MarketDataEvent::from(data)).await {
                    Ok(signals) => {
                        for signal in signals {
                            if let Err(e) = Self::execute_strategy_signal(&executor_manager, signal).await {
                                log::error!("Error executing signal from strategy '{}': {:?}", name, e);
                            }
                        }
                    }
                    Err(e) => {
                        log::error!("Error in strategy '{}' market data processing: {:?}", name, e);
                    }
                }
            });
        }
        
        Ok(())
    }
    
    // ğŸ”¥ æ‰§è¡Œç­–ç•¥ä¿¡å·
    async fn execute_strategy_signal(
        executor_manager: &ExecutorManager,
        signal: StrategySignal
    ) -> Result<(), StrategyError> {
        match signal {
            StrategySignal::PlaceOrder(order_request) => {
                executor_manager.execute_order(order_request).await
                    .map_err(|e| StrategyError::ExecutionError(e.to_string()))?;
            }
            StrategySignal::CancelOrder { order_id, exchange } => {
                executor_manager.cancel_order(&order_id, exchange).await
                    .map_err(|e| StrategyError::ExecutionError(e.to_string()))?;
            }
            StrategySignal::PlaceBatchOrders(orders) => {
                executor_manager.execute_batch_orders(orders).await;
            }
            StrategySignal::ExecuteArbitrage(opportunity) => {
                executor_manager.execute_arbitrage(opportunity).await
                    .map_err(|e| StrategyError::ExecutionError(e.to_string()))?;
            }
            // å¤„ç†å…¶ä»–ä¿¡å·ç±»å‹...
            _ => {
                log::warn!("Unhandled strategy signal: {:?}", signal);
            }
        }
        
        Ok(())
    }
    
    // ğŸ”¥ åŠ¨æ€æ›´æ–°ç­–ç•¥å‚æ•°
    pub async fn update_strategy_parameters(
        &self,
        strategy_name: &str,
        parameters: HashMap<String, StrategyParameter>
    ) -> Result<(), StrategyError> {
        let strategies = self.strategies.read().await;
        
        if let Some(strategy) = strategies.get(strategy_name) {
            let mut strategy = strategy.lock().await;
            strategy.set_strategy_parameters(parameters).await?;
            
            log::info!("Strategy '{}' parameters updated", strategy_name);
            Ok(())
        } else {
            Err(StrategyError::StrategyNotFound(strategy_name.to_string()))
        }
    }
    
    // ğŸ”¥ è·å–ç­–ç•¥æŒ‡æ ‡
    pub async fn get_strategy_metrics(&self, strategy_name: &str) -> Option<StrategyMetrics> {
        let metrics = self.strategy_metrics.read().await;
        metrics.get(strategy_name).cloned()
    }
    
    // ğŸ”¥ è·å–æ‰€æœ‰ç­–ç•¥çŠ¶æ€
    pub async fn get_all_status(&self) -> HashMap<String, StrategyState> {
        self.strategy_states.read().await.clone()
    }
    
    // ç§æœ‰æ–¹æ³•ï¼šå¯åŠ¨ç­–ç•¥ä»»åŠ¡
    async fn start_strategy_task(
        &self,
        name: String,
        strategy: Arc<Mutex<Box<dyn Strategy>>>
    ) {
        let event_bus = self.event_bus.clone();
        let executor_manager = self.executor_manager.clone();
        
        let task = tokio::spawn(async move {
            let mut market_data_receiver = event_bus.subscribe_high_frequency_data().await;
            let mut system_event_receiver = event_bus.subscribe_system_events().await;
            
            loop {
                tokio::select! {
                    Some(market_data) = market_data_receiver.recv() => {
                        let mut strategy = strategy.lock().await;
                        
                        match strategy.on_market_data(MarketDataEvent::from(market_data)).await {
                            Ok(signals) => {
                                for signal in signals {
                                    if let Err(e) = Self::execute_strategy_signal(&executor_manager, signal).await {
                                        log::error!("Error executing signal from strategy '{}': {:?}", name, e);
                                    }
                                }
                            }
                            Err(e) => {
                                log::error!("Error in strategy '{}': {:?}", name, e);
                            }
                        }
                    }
                    
                    Ok(system_event) = system_event_receiver.recv() => {
                        let mut strategy = strategy.lock().await;
                        
                        match strategy.on_system_event(system_event).await {
                            Ok(signals) => {
                                for signal in signals {
                                    if let Err(e) = Self::execute_strategy_signal(&executor_manager, signal).await {
                                        log::error!("Error executing signal from strategy '{}': {:?}", name, e);
                                    }
                                }
                            }
                            Err(e) => {
                                log::error!("Error in strategy '{}' system event processing: {:?}", name, e);
                            }
                        }
                    }
                    
                    else => break,
                }
            }
        });
        
        let mut tasks = self.strategy_tasks.lock().await;
        tasks.insert(name, task);
    }
}
```

## 6. é…ç½®ç¤ºä¾‹

### 6.1 å®Œæ•´ç³»ç»Ÿé…ç½®

```toml
# config/system.toml - å®Œæ•´ç³»ç»Ÿé…ç½®ç¤ºä¾‹

[system]
name = "CrossFury Trading System"
version = "2.0.0"
environment = "Production"
data_directory = "./data"
log_directory = "./logs"
plugin_directory = "./plugins"
max_memory_usage = 8589934592  # 8GB
max_cpu_usage = 80.0

[event_bus]
high_frequency_buffer_size = 10000
event_buffer_size = 1000
max_subscribers = 100
enable_persistence = true
persistence_path = "./data/events"

[monitoring]
enabled = true
metrics_port = 9090
health_check_interval = "30s"
performance_sampling_rate = 0.1

[monitoring.alert_thresholds]
max_memory_usage = 85.0
max_cpu_usage = 90.0
max_error_rate = 5.0
min_uptime = "1h"

[logging]
level = "info"
format = "json"
output = ["console", {file = {path = "./logs/system.log"}}]

[logging.rotation]
max_size = "100MB"
max_files = 10
compress = true

# ğŸ”¥ ç­–ç•¥é…ç½®
[strategies.arbitrage_spot]
type = "arbitrage"
enabled = true
market_types = ["spot"]
min_profit_threshold = 0.001
max_position_size = 10000.0
risk_limits = { max_daily_loss = 1000.0 }

[strategies.arbitrage_spot.parameters]
profit_threshold = 0.002
max_spread = 0.01
min_volume = 1000.0
execution_timeout = "5s"

[strategies.grid_trading]
type = "grid"
enabled = true
market_types = ["spot"]
symbols = ["BTC/USDT", "ETH/USDT"]

[strategies.grid_trading.parameters]
grid_count = 10
grid_spacing = 0.005
base_order_size = 100.0
take_profit_ratio = 0.01
stop_loss_ratio = 0.05

# ğŸ”¥ è¿æ¥å™¨é…ç½®å¼•ç”¨
[connectors]
# å¼•ç”¨è¿æ¥æ¨¡å—çš„é…ç½®

[executors]
# å¼•ç”¨æ‰§è¡Œæ¨¡å—çš„é…ç½®
```

### 6.2 ç­–ç•¥æ’ä»¶é…ç½®

```toml
# plugins/my_strategy/plugin.toml
[plugin]
name = "my_custom_strategy"
version = "1.0.0"
description = "è‡ªå®šä¹‰å¥—åˆ©ç­–ç•¥"
author = "Trading Team"
entry_point = "strategy.so"

[plugin.metadata]
supported_markets = ["spot", "futures"]
required_symbols = ["BTC/USDT", "ETH/USDT"]
min_capital = 1000.0

[plugin.parameters]
profit_threshold = { type = "float", default = 0.001, required = true }
max_position = { type = "float", default = 10000.0, required = false }
risk_level = { type = "string", default = "medium", options = ["low", "medium", "high"] }

[plugin.dependencies]
required_crates = ["tokio", "serde"]
min_rust_version = "1.70.0"
```

## 7. é”™è¯¯å¤„ç†

### 7.1 é”™è¯¯ç±»å‹å®šä¹‰

```rust
// src/strategies/errors.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum StrategyError {
    #[error("Strategy not found: {0}")]
    StrategyNotFound(String),
    
    #[error("Strategy initialization failed: {0}")]
    InitializationError(String),
    
    #[error("Strategy execution error: {0}")]
    ExecutionError(String),
    
    #[error("Invalid parameter: {0}")]
    InvalidParameter(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    #[error("Plugin error: {0}")]
    PluginError(String),
    
    #[error("Risk limit exceeded: {0}")]
    RiskLimitExceeded(String),
    
    #[error("Market data error: {0}")]
    MarketDataError(String),
    
    #[error("System error: {0}")]
    SystemError(String),
}

#[derive(Error, Debug)]
pub enum AssemblyError {
    #[error("Config load error: {0}")]
    ConfigLoadError(String),
    
    #[error("Config parse error: {0}")]
    ConfigParseError(String),
    
    #[error("Unsupported config format: {0}")]
    UnsupportedConfigFormat(String),
    
    #[error("Component creation failed: {0}")]
    ComponentCreationError(String),
    
    #[error("Dependency resolution failed: {0}")]
    DependencyError(String),
}

#[derive(Error, Debug)]
pub enum PluginError {
    #[error("Plugin file not found: {0}")]
    FileNotFound(String),
    
    #[error("Plugin metadata read error: {0}")]
    MetadataReadError(String),
    
    #[error("Plugin metadata parse error: {0}")]
    MetadataParseError(String),
    
    #[error("Plugin load error: {0}")]
    LoadError(String),
    
    #[error("Plugin not found: {0}")]
    PluginNotFound(String),
    
    #[error("Dependency check failed: {0}")]
    DependencyCheckFailed(String),
    
    #[error("Plugin validation failed: {0}")]
    ValidationFailed(String),
}
```

## 8. é‡æ„ä¼˜åŠ¿æ€»ç»“

### 8.1 æ ¸å¿ƒä¼˜åŠ¿

1. **ğŸ”¥ é…ç½®é©±åŠ¨æ¶æ„**
   - é€šè¿‡é…ç½®æ–‡ä»¶åŠ¨æ€ç»„è£…ç³»ç»Ÿç»„ä»¶
   - æ”¯æŒè¿è¡Œæ—¶é…ç½®çƒ­é‡è½½
   - é™ä½ä»£ç è€¦åˆåº¦ï¼Œæé«˜çµæ´»æ€§

2. **ğŸ”¥ ç­–ç•¥çƒ­æ’æ‹”**
   - æ”¯æŒç­–ç•¥åŠ¨æ€åŠ è½½ã€å¸è½½å’Œæ›´æ–°
   - æ’ä»¶åŒ–æ¶æ„ï¼Œæ”¯æŒç¬¬ä¸‰æ–¹ç­–ç•¥å¼€å‘
   - ç­–ç•¥æ•…éšœéš”ç¦»ï¼Œä¸å½±å“ç³»ç»Ÿæ•´ä½“è¿è¡Œ

3. **ğŸ”¥ äº‹ä»¶é©±åŠ¨åè°ƒ**
   - åŸºäºäº‹ä»¶æ€»çº¿çš„æ¾è€¦åˆæ¶æ„
   - é«˜æ•ˆçš„æ•°æ®æµå¤„ç†å’Œäº‹ä»¶åˆ†å‘
   - æ”¯æŒå¼‚æ­¥å¹¶å‘å¤„ç†

4. **ğŸ”¥ ç»Ÿä¸€ç­–ç•¥æ¥å£**
   - æ ‡å‡†åŒ–çš„ç­–ç•¥å¼€å‘æ¥å£
   - å®Œæ•´çš„ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
   - ä¸°å¯Œçš„ç­–ç•¥ä¿¡å·ç±»å‹æ”¯æŒ

5. **ğŸ”¥ å®Œæ•´çš„ç›‘æ§ä½“ç³»**
   - å®æ—¶ç³»ç»ŸçŠ¶æ€ç›‘æ§
   - è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   - æ™ºèƒ½å‘Šè­¦å’Œæ•…éšœè¯Šæ–­

### 8.2 æŠ€æœ¯ç‰¹æ€§

- **é«˜æ€§èƒ½**ï¼šå¼‚æ­¥äº‹ä»¶å¤„ç†ï¼Œé›¶æ‹·è´æ•°æ®ä¼ è¾“
- **é«˜å¯ç”¨**ï¼šæ•…éšœéš”ç¦»ï¼Œè‡ªåŠ¨æ¢å¤æœºåˆ¶
- **å¯æ‰©å±•**ï¼šæ’ä»¶åŒ–æ¶æ„ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **å¯ç»´æŠ¤**ï¼šæ¸…æ™°çš„æ¨¡å—åˆ’åˆ†ï¼Œæ ‡å‡†åŒ–æ¥å£
- **å¯è§‚æµ‹**ï¼šå…¨é¢çš„æ—¥å¿—ã€æŒ‡æ ‡å’Œè°ƒè¯•æ”¯æŒ

### 8.3 å®æ–½å»ºè®®

1. **åˆ†é˜¶æ®µå®æ–½**
   - ç¬¬ä¸€é˜¶æ®µï¼šå®ç°åŸºç¡€æ¡†æ¶å’Œé…ç½®ç³»ç»Ÿ
   - ç¬¬äºŒé˜¶æ®µï¼šå®ç°ç­–ç•¥ç®¡ç†å’Œæ’ä»¶ç³»ç»Ÿ
   - ç¬¬ä¸‰é˜¶æ®µï¼šå®Œå–„ç›‘æ§å’Œè¿ç»´åŠŸèƒ½

2. **å‘åå…¼å®¹**
   - ä¿æŒç°æœ‰ç­–ç•¥æ¥å£çš„å…¼å®¹æ€§
   - æä¾›è¿ç§»å·¥å…·å’Œæ–‡æ¡£
   - é€æ­¥è¿ç§»ç°æœ‰ç­–ç•¥

3. **æµ‹è¯•ç­–ç•¥**
   - å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰æ ¸å¿ƒç»„ä»¶
   - é›†æˆæµ‹è¯•éªŒè¯ç³»ç»Ÿåè°ƒåŠŸèƒ½
   - æ€§èƒ½æµ‹è¯•ç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§

4. **æ–‡æ¡£å®Œå–„**
   - è¯¦ç»†çš„APIæ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—
   - ç­–ç•¥å¼€å‘æ•™ç¨‹å’Œæœ€ä½³å®è·µ
   - è¿ç»´æ‰‹å†Œå’Œæ•…éšœæ’æŸ¥æŒ‡å—

---

**ç­–ç•¥æ§åˆ¶å™¨æ¨¡å—é‡æ„å°†ä¸º CrossFury ç³»ç»Ÿå¸¦æ¥æ›´å¼ºçš„çµæ´»æ€§ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œæ”¯æŒå¿«é€Ÿçš„ç­–ç•¥å¼€å‘å’Œéƒ¨ç½²ï¼Œä¸ºé‡åŒ–äº¤æ˜“ä¸šåŠ¡çš„å¿«é€Ÿå‘å±•æä¾›åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚**

## 9. æ–°ç›®å½•ç»“æ„è®¾è®¡

```
src/
â”œâ”€â”€ strategies/                   # ç­–ç•¥æ¨¡å—
â”‚   â”œâ”€â”€ mod.rs                   # æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ traits.rs                # å¼•ç”¨æ ¸å¿ƒtraitå®šä¹‰
â”‚   â”œâ”€â”€ strategy_manager.rs      # ç­–ç•¥ç®¡ç†å™¨å®ç°
â”‚   â”œâ”€â”€ event_bus.rs             # äº‹ä»¶æ€»çº¿å®ç°
â”‚   â”œâ”€â”€ plugin_manager.rs        # æ’ä»¶ç®¡ç†å™¨
â”‚   â”œâ”€â”€ config_manager.rs        # é…ç½®ç®¡ç†å™¨
â”‚   â”œâ”€â”€ arbitrage_strategy.rs    # å¥—åˆ©ç­–ç•¥å®ç°
â”‚   â”œâ”€â”€ grid_strategy.rs         # ç½‘æ ¼ç­–ç•¥å®ç°
â”‚   â”œâ”€â”€ trend_strategy.rs        # è¶‹åŠ¿ç­–ç•¥å®ç°
â”‚   â”œâ”€â”€ base_strategy.rs         # ç­–ç•¥åŸºç±»
â”‚   â”œâ”€â”€ signal_processor.rs      # ä¿¡å·å¤„ç†å™¨
â”‚   â”œâ”€â”€ metrics_collector.rs     # æŒ‡æ ‡æ”¶é›†å™¨
â”‚   â”œâ”€â”€ legacy_adapter.rs        # æ—§ä»£ç é€‚é…å™¨
â”‚   â””â”€â”€ utils.rs                 # ç­–ç•¥å·¥å…·å‡½æ•°
â”œâ”€â”€ types/                       # æ•°æ®ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ strategy.rs              # ç­–ç•¥ç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ events.rs                # äº‹ä»¶ç›¸å…³ç±»å‹
â”‚   â”œâ”€â”€ signals.rs               # ä¿¡å·ç›¸å…³ç±»å‹
â”‚   â””â”€â”€ config.rs                # é…ç½®ç›¸å…³ç±»å‹
â”œâ”€â”€ legacy_strategies/           # æ—§ä»£ç ä¿ç•™
â”‚   â”œâ”€â”€ legacy_core.rs           # åŸcore.rsç­–ç•¥éƒ¨åˆ†
â”‚   â”œâ”€â”€ legacy_cross_exchange.rs # åŸcross_exchange.rsç­–ç•¥éƒ¨åˆ†
â”‚   â””â”€â”€ legacy_config.rs         # åŸconfig.rsç­–ç•¥éƒ¨åˆ†
â”œâ”€â”€ plugins/                     # ç­–ç•¥æ’ä»¶ç›®å½•
â”‚   â”œâ”€â”€ arbitrage_plugin/        # å¥—åˆ©ç­–ç•¥æ’ä»¶
â”‚   â”œâ”€â”€ grid_plugin/             # ç½‘æ ¼ç­–ç•¥æ’ä»¶
â”‚   â””â”€â”€ custom_plugins/          # è‡ªå®šä¹‰ç­–ç•¥æ’ä»¶
â””â”€â”€ config/
    â”œâ”€â”€ strategies.rs            # ç­–ç•¥é…ç½®ç®¡ç†
    â””â”€â”€ plugins.rs              # æ’ä»¶é…ç½®ç®¡ç†
```

## 10. åˆ†é˜¶æ®µå®æ–½æ­¥éª¤

### é˜¶æ®µ1ï¼šåŸºç¡€è®¾æ–½æ­å»ºï¼ˆ2-3å‘¨ï¼‰

#### 1.1 åˆ›å»ºæ–°ç›®å½•ç»“æ„
- åˆ›å»º `src/strategies/` ç›®å½•åŠå­æ¨¡å—
- åˆ›å»º `src/types/` ç›®å½•åŠç±»å‹å®šä¹‰æ–‡ä»¶
- åˆ›å»º `src/legacy_strategies/` ç›®å½•
- åˆ›å»º `src/plugins/` ç›®å½•ç»“æ„

#### 1.2 ä¿ç•™æ—§ä»£ç 
```bash
# é‡å‘½åç°æœ‰æ–‡ä»¶ï¼Œä¿æŒåŠŸèƒ½ä¸å˜
cp src/core.rs src/legacy_strategies/legacy_core.rs  # ä¿ç•™ç­–ç•¥ç›¸å…³éƒ¨åˆ†
cp src/cross_exchange.rs src/legacy_strategies/legacy_cross_exchange.rs  # ä¿ç•™ç­–ç•¥é€»è¾‘
cp src/config.rs src/legacy_strategies/legacy_config.rs  # ä¿ç•™ç­–ç•¥é…ç½®
```

#### 1.3 åˆ›å»ºtraitå¼•ç”¨æ–‡ä»¶
```rust
// src/strategies/traits.rs
pub use crate::traits::{
    Strategy, StrategyManager, EventBus
};
```

### é˜¶æ®µ2ï¼šé€‚é…å™¨å®ç°ï¼ˆ2-3å‘¨ï¼‰

#### 2.1 å®ç°æ—§ä»£ç é€‚é…å™¨
- åˆ›å»º `LegacyStrategyAdapter`
- å®ç° `Strategy` trait çš„é€‚é…
- å®ç° `StrategyManager` trait çš„é€‚é…
- ç¡®ä¿ç°æœ‰ç­–ç•¥åŠŸèƒ½æ­£å¸¸å·¥ä½œ

#### 2.2 äº‹ä»¶ç³»ç»Ÿè¿ç§»
- åˆ›å»ºæ–°çš„äº‹ä»¶ç±»å‹å®šä¹‰
- å®ç°äº‹ä»¶æ€»çº¿åŸºç¡€åŠŸèƒ½
- åˆ›å»ºæ–°æ—§äº‹ä»¶ä¹‹é—´çš„è½¬æ¢å‡½æ•°
- ä¿æŒå‘åå…¼å®¹æ€§

### é˜¶æ®µ3ï¼šç­–ç•¥ç®¡ç†å™¨é‡æ„ï¼ˆ3-4å‘¨ï¼‰

#### 3.1 ç­–ç•¥ç®¡ç†å™¨å®ç°
- å®ç° `StrategyManagerImpl`
- æ·»åŠ ç­–ç•¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å®ç°ç­–ç•¥çƒ­æ’æ‹”åŠŸèƒ½
- é›†æˆé…ç½®ç®¡ç†ç³»ç»Ÿ

#### 3.2 äº‹ä»¶æ€»çº¿å®ç°
- å®ç° `EventBusImpl`
- æ·»åŠ é«˜æ€§èƒ½äº‹ä»¶åˆ†å‘æœºåˆ¶
- å®ç°äº‹ä»¶ä¼˜å…ˆçº§å’Œè¿‡æ»¤
- æ·»åŠ äº‹ä»¶ç›‘æ§å’Œè°ƒè¯•åŠŸèƒ½

#### 3.3 é…ç½®ç®¡ç†å™¨å®ç°
- å®ç° `ConfigManagerImpl`
- æ”¯æŒåŠ¨æ€é…ç½®åŠ è½½å’Œçƒ­é‡è½½
- å®ç°é…ç½®éªŒè¯å’Œé”™è¯¯å¤„ç†
- æ·»åŠ é…ç½®ç‰ˆæœ¬ç®¡ç†

### é˜¶æ®µ4ï¼šç­–ç•¥è¿ç§»ï¼ˆ3-4å‘¨ï¼‰

#### 4.1 å¥—åˆ©ç­–ç•¥é‡æ„
- é‡æ„ç°æœ‰å¥—åˆ©é€»è¾‘
- å®ç°æ–°çš„ `Strategy` trait
- ä¼˜åŒ–æ‰§è¡Œæ•ˆç‡
- æ·»åŠ è¯¦ç»†çš„æ€§èƒ½ç›‘æ§

#### 4.2 æ–°ç­–ç•¥ç±»å‹å®ç°
- å®ç°ç½‘æ ¼ç­–ç•¥
- å®ç°è¶‹åŠ¿ç­–ç•¥
- å®ç°åšå¸‚ç­–ç•¥
- æ·»åŠ ç­–ç•¥æ¨¡æ¿å’Œç¤ºä¾‹

#### 4.3 æ’ä»¶ç³»ç»Ÿå®ç°
- å®ç°æ’ä»¶ç®¡ç†å™¨
- æ”¯æŒåŠ¨æ€æ’ä»¶åŠ è½½
- å®ç°æ’ä»¶å®‰å…¨éªŒè¯
- æ·»åŠ æ’ä»¶å¼€å‘å·¥å…·

### é˜¶æ®µ5ï¼šé›†æˆä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰

#### 5.1 ç³»ç»Ÿé›†æˆ
- é›†æˆè¿æ¥æ¨¡å—å’Œæ‰§è¡Œæ¨¡å—
- å®ç°å®Œæ•´çš„æ•°æ®æµå¤„ç†
- ä¼˜åŒ–äº‹ä»¶å¤„ç†æ€§èƒ½
- æ·»åŠ ç³»ç»Ÿç›‘æ§åŠŸèƒ½

#### 5.2 æ€§èƒ½ä¼˜åŒ–
- ä¼˜åŒ–äº‹ä»¶åˆ†å‘æœºåˆ¶
- å‡å°‘å†…å­˜åˆ†é…å’Œæ‹·è´
- å®ç°æ‰¹é‡å¤„ç†ä¼˜åŒ–
- æ·»åŠ æ€§èƒ½åŸºå‡†æµ‹è¯•

#### 5.3 é›†æˆæµ‹è¯•
- ç¼–å†™å…¨é¢çš„é›†æˆæµ‹è¯•
- ç­–ç•¥æ€§èƒ½åŸºå‡†æµ‹è¯•
- å‹åŠ›æµ‹è¯•å’Œç¨³å®šæ€§æµ‹è¯•
- æ•…éšœæ¢å¤å’Œå®¹é”™æµ‹è¯•

### é˜¶æ®µ6ï¼šæ¸…ç†å’Œæ–‡æ¡£ï¼ˆ1-2å‘¨ï¼‰

#### 6.1 ä»£ç æ¸…ç†
- ç§»é™¤æœªä½¿ç”¨çš„æ—§ä»£ç 
- ä¼˜åŒ–ä»£ç ç»“æ„å’Œæ€§èƒ½
- ç»Ÿä¸€ä»£ç é£æ ¼å’Œæ³¨é‡Š
- æ·»åŠ è¯¦ç»†çš„APIæ–‡æ¡£

#### 6.2 æ–‡æ¡£å®Œå–„
- ç¼–å†™ç­–ç•¥å¼€å‘æŒ‡å—
- åˆ›å»ºæ’ä»¶å¼€å‘æ•™ç¨‹
- æ·»åŠ é…ç½®è¯´æ˜æ–‡æ¡£
- ç¼–å†™è¿ç»´å’Œæ•…éšœæ’é™¤æŒ‡å—

### æ€»æ—¶é—´é¢„ä¼°ï¼š13-19å‘¨

### é£é™©æ§åˆ¶æªæ–½
1. **æ¸è¿›å¼è¿ç§»**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½ä¿æŒç³»ç»Ÿå¯è¿è¡ŒçŠ¶æ€
2. **å¹¶è¡Œå¼€å‘**ï¼šæ–°æ—§ä»£ç å¹¶å­˜ï¼Œé€æ­¥åˆ‡æ¢
3. **å……åˆ†æµ‹è¯•**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯¹åº”çš„æµ‹è¯•éªŒè¯
4. **å›æ»šæœºåˆ¶**ï¼šå‡ºç°é—®é¢˜æ—¶å¯å¿«é€Ÿå›æ»šåˆ°æ—§ç‰ˆæœ¬
5. **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§ç³»ç»Ÿè¿è¡ŒçŠ¶æ€ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
6. **æ–‡æ¡£åŒæ­¥**ï¼šå¼€å‘è¿‡ç¨‹ä¸­åŒæ­¥æ›´æ–°æ–‡æ¡£ï¼Œç¡®ä¿å¯ç»´æŠ¤æ€§